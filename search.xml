<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux-shell</title>
      <link href="/2021/05/28/linux-shell/"/>
      <url>/2021/05/28/linux-shell/</url>
      
        <content type="html"><![CDATA[<p>linux系统中各种命令的学习<br>shell编程<br>使用过程中的各种问题处理<br><a id="more"></a></p><h1 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>查找文件里符合条件的字符串<br><code>grep &quot;word&quot; file</code></p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>利用wc指令我们可以计算文件的Byte数、字数、或是行数<br><code>wc -l file</code></p><h2 id="查看目录中的文件数量"><a href="#查看目录中的文件数量" class="headerlink" title="查看目录中的文件数量"></a>查看目录中的文件数量</h2><p>通过ls、grep、wc三个命令的组合可以实现查看目录下文件的数量，ls获取目录所有的文件，grep筛选调.和..，wc用于行记数<br><code>ls -l | grep &quot;-&quot; | wc -l</code></p><h2 id="查看分区以及文件所占大小"><a href="#查看分区以及文件所占大小" class="headerlink" title="查看分区以及文件所占大小"></a>查看分区以及文件所占大小</h2><h3 id="1-du命令"><a href="#1-du命令" class="headerlink" title="1.du命令"></a>1.du命令</h3><p>du会显示指定的目录或文件所占用的磁盘空间。<br>语法<br>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][—block-size][—exclude=&lt;目录或文件&gt;][—max-depth=&lt;目录层数&gt;][—help][—version][目录或文件]<br>参数说明：<br>    -a或-all 显示目录中个别文件的大小。<br>    -b或-bytes 显示目录或文件大小时，以byte为单位。<br>    -c或—total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>    -D或—dereference-args 显示指定符号连接的源文件大小。<br>    -h或—human-readable 以K，M，G为单位，提高信息的可读性。<br>    -H或—si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>    -k或—kilobytes 以1024 bytes为单位。<br>    -l或—count-links 重复计算硬件连接的文件。<br>    -L&lt;符号连接&gt;或—dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>    -m或—megabytes 以1MB为单位。<br>    -s或—summarize 仅显示总计。<br>    -S或—separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>    -x或—one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>    -X&lt;文件&gt;或—exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>    —exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>    —max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>    —help 显示帮助。<br>    —version 显示版本信息。</p><p>   sudo du —max-depth=1 -h /<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0/proc</span><br><span class="line">4.0K/cdrom</span><br><span class="line">1002M/var</span><br><span class="line">505M/lib</span><br><span class="line">16K/lost+found</span><br><span class="line">59M/boot</span><br><span class="line">8.0K/snap</span><br><span class="line">359G/media</span><br><span class="line">13M/sbin</span><br><span class="line">4.0K/srv</span><br></pre></td></tr></table></figure></p><p>du -sh * (同上)</p><h3 id="2-df命令"><a href="#2-df命令" class="headerlink" title="2. df命令"></a>2. df命令</h3><p>看到当前系统分区（包括交换分区swap）的”文件系统、容量、已用 、可用、已用% 、挂载点“等实时装况<br>df -l /home<br>df -h /home #-h,显示Ｍ、Ｇ更直观</p><h3 id="3-fdisk命令"><a href="#3-fdisk命令" class="headerlink" title="3.fdisk命令"></a>3.fdisk命令</h3><p>fdisk -l　＃查看所有挂着的磁盘</p><h1 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h1><h2 id="一、获取用户输入内容，并进行判断"><a href="#一、获取用户输入内容，并进行判断" class="headerlink" title="一、获取用户输入内容，并进行判断"></a>一、获取用户输入内容，并进行判断</h2><p> read -p “please input(Y/N):”  yn</p><h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.定义数组</span><br><span class="line">$ a=(1 2 3 4 5)</span><br><span class="line"></span><br><span class="line">2.数组长度</span><br><span class="line">$ echo $&#123;#a[@]&#125;</span><br><span class="line">用$&#123;#数组名[@或*]&#125; 可以得到数组长度</span><br><span class="line"></span><br><span class="line">3.读取数组</span><br><span class="line">$ echo $&#123;a[2]&#125;</span><br><span class="line">$ echo $&#123;a[*]&#125;</span><br><span class="line">用$&#123;数组名[下标]&#125; 下标是从0开始  下标是：*或者@ 得到整个数组内容</span><br><span class="line"></span><br><span class="line">4.赋值</span><br><span class="line">$ a[1]=100</span><br><span class="line">直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素</span><br><span class="line"></span><br><span class="line">5.删除</span><br><span class="line">$ unset a</span><br><span class="line">$ unset a[1]   </span><br><span class="line">直接通过：unset 数组[下标] 可以清除相应的元素，不带下标，清除整个数据。</span><br></pre></td></tr></table></figure><p>6.循环数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for value in $&#123;a[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $value</span><br><span class="line">done</span><br><span class="line">for ((i=0;i&lt;$&#123;#a[@]&#125;;i++)) #不加双括号会报错</span><br><span class="line">do</span><br><span class="line">    echo $&#123;a[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>7.特殊使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）分片:</span><br><span class="line"># a=(1 2 3 4 5 6)</span><br><span class="line"># echo $&#123;a[@]:0:3&#125;</span><br><span class="line">1 2 3</span><br><span class="line"># echo $&#123;a[@]:1:4&#125;</span><br><span class="line">2 3 4 5</span><br><span class="line"># c=($&#123;a[@]:1:4&#125;)</span><br><span class="line"># echo $&#123;#c[@]&#125;</span><br><span class="line">4</span><br><span class="line"># echo $&#123;c[*]&#125;</span><br><span class="line">2 3 4 5</span><br></pre></td></tr></table></figure></p><p>直接通过 ${数组名[@或*]:起始位置:长度} 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</p><p>2）替换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># a=(1 2 3 4 5 3)</span><br><span class="line"># echo $&#123;a[@]/3/8&#125;</span><br><span class="line">1 2 8 4 5 8</span><br><span class="line"># echo $&#123;a[@]&#125;</span><br><span class="line">1 2 3 4 5 3</span><br></pre></td></tr></table></figure></p><p>调用方法是：${数组名[@或*]/查找字符/替换字符} 该操作不会改变原先数组内容。</p><h2 id="三、脚本批量压缩"><a href="#三、脚本批量压缩" class="headerlink" title="三、脚本批量压缩"></a>三、脚本批量压缩</h2><h3 id="1-将当前目录下的所有文件夹压缩"><a href="#1-将当前目录下的所有文件夹压缩" class="headerlink" title="1.将当前目录下的所有文件夹压缩"></a>1.将当前目录下的所有文件夹压缩</h3><p>找到所有的文件夹进行压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">dirnames=$(ls -d */)</span><br><span class="line">for dir in $dirnames</span><br><span class="line">do</span><br><span class="line">    temp=$&#123;dir%/&#125;</span><br><span class="line">    echo $temp </span><br><span class="line">    echo $(tar -cvf $temp&quot;.tar.gz&quot; $temp)</span><br><span class="line">    testing=$(test -e $temp&quot;.tar.gz&quot; &amp;&amp; echo yes)</span><br><span class="line">    if [ &quot;$testing&quot;==&quot;yes&quot; ]; then</span><br><span class="line">         echo $(scp $temp&quot;.tar.gz&quot; user@IP:/home/user )</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p> 找到当前目录下所有的文件和文件夹，选出文件夹进行压缩<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">for dir in $(ls)</span><br><span class="line">do</span><br><span class="line">    if [ -d $dir ]; then</span><br><span class="line">       echo $dir </span><br><span class="line">       echo $(tar -cvf $dir&quot;.tar.gz&quot; $dir)</span><br><span class="line">       testing=$(test -e $dir&quot;.tar.gz&quot; &amp;&amp; echo yes)</span><br><span class="line">       if [ &quot;$testing&quot;==&quot;yes&quot; ]; then</span><br><span class="line">          echo $(scp $dir&quot;.tar.gz&quot; user@IP:/home/user )</span><br><span class="line">       fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h1><h2 id="ubuntu文件夹打不开，点击文件夹没反应"><a href="#ubuntu文件夹打不开，点击文件夹没反应" class="headerlink" title="ubuntu文件夹打不开，点击文件夹没反应"></a>ubuntu文件夹打不开，点击文件夹没反应</h2><p>直接在命令行输入：<br><code>killall nautilus</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux，shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2021/05/13/git/"/>
      <url>/2021/05/13/git/</url>
      
        <content type="html"><![CDATA[<p>github的各指令的使用<br><a id="more"></a></p><h1 id="git整体结构说明"><a href="#git整体结构说明" class="headerlink" title="git整体结构说明"></a>git整体结构说明</h1><p><a href="https://mp.weixin.qq.com/s/rqYbIEYUWgKWxOkA7Eyz9A" target="_blank" rel="noopener">参考</a></p><h1 id="在终端通过命令创建仓库"><a href="#在终端通过命令创建仓库" class="headerlink" title="在终端通过命令创建仓库"></a>在终端通过命令创建仓库</h1><ol><li>在.zshrc中添加以下函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">github-create() </span><br><span class="line">&#123;</span><br><span class="line">    if [ $1 ]</span><br><span class="line">    then</span><br><span class="line">        repo_name=$1</span><br><span class="line">    else</span><br><span class="line">        repo_name=`basename $(pwd)`</span><br><span class="line">        echo &quot;set Repo name to $&#123;repo_name&#125;&quot;</span><br><span class="line">    fi </span><br><span class="line">    curl -u &apos;username:token&apos; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos;</span><br><span class="line">    echo &quot;# $&#123;repo_name&#125;&quot; &gt;&gt; README.md</span><br><span class="line">    git init</span><br><span class="line">    git add README.md</span><br><span class="line">    git commit -m &quot;first commit&quot;</span><br><span class="line">    git remote add origin git@github.com:username/$repo_name.git</span><br><span class="line">    git push -u origin master</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>username是github的用户名<br>token需要在<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">github</a>中申请</p><p>在终端中执行以下命令<br><code>github-create repository-name</code></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2021/03/07/python/"/>
      <url>/2021/03/07/python/</url>
      
        <content type="html"><![CDATA[<p>python 学习中的一些理解<br><a id="more"></a></p><h1 id="成员函数、类函数、静态函数"><a href="#成员函数、类函数、静态函数" class="headerlink" title="成员函数、类函数、静态函数"></a>成员函数、类函数、静态函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def plain_func(self): # 普通方法</span><br><span class="line">        print(&quot;plain_func&quot;)</span><br><span class="line"> </span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func(cls):  # 类方法</span><br><span class="line">        print(&quot;class_func&quot;)</span><br><span class="line"> </span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_func():    # 静态方法</span><br><span class="line">        print(&quot;static_func&quot;)</span><br><span class="line"> </span><br><span class="line"># 必须实例化进行调用</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.plain_func()</span><br><span class="line"># 可通过类名进行调用</span><br><span class="line">Foo.class_func()</span><br><span class="line">Foo.static_func()</span><br></pre></td></tr></table></figure><h2 id="普通成员函数"><a href="#普通成员函数" class="headerlink" title="普通成员函数"></a>普通成员函数</h2><p>普通成员函数是最一般的方法，从调用方式来看，普通函数只能在类的实例中被调用，而后两者可以通过类名进行调用。</p><h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><p>classmethod 增加了一个 cls 参数，它引用了一个类实例。cls 类似于类中其他函数的 self 参数，例如 <strong>init</strong>(self)，只不过 self 代表创建的实例对象，而 cls 代表类本身。classmethod 可以用于写一个只在类中运行而不在实例中运行的方法，直接通过类进行调用。不管这个方法是从实例调用还是从类调用，它都用第一个参数把类传递过来。对类的用户可见的功能可使用 classmethod。</p><p>好处：</p><ul><li>方法可以判断出自己是通过基类被调用，还是通过某个子类被调用；</li><li>通过子类调用时，方法可以返回子类的实例而非基类的实例；</li><li>通过子类调用时，方法可以调用子类的其他 classmethod。</li></ul><h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>staticmethod 用于跟类有关系的功能但在运行时又不需要实例和类参与的情况，比如更改环境变量或者修改其他类的属性等。在通过类调用时，staticmethod 与 classmethod 对于调用者来说是不可区分的。<br>好处：</p><ul><li>调用时返回的是一个真正的函数，而且每次调用时返回同一个实例（classmethod 则会对基类和子类返回不同的 bound method 实例）</li></ul><p><strong> classmethod 与 staticmethod </strong><br>这两个方法的用法是类似的，在大多数情况下，classmethod 也可以通过 staticmethod 代替，staticmethod 也可以在子类上被重写为 classmethod，反之亦然。</p><h1 id="self"><a href="#self" class="headerlink" title="self"></a>self</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo&apos;)</span><br></pre></td></tr></table></figure><p>Foo().x() 等同于 Foo.x(Foo()), 对象调用成员函数，相当于默认输入了一个对象给self。<br>而且self不是必须用的只是通常用法，所以有没有self并不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Box(object):</span><br><span class="line">    def myInit(this, boxname, size, color):</span><br><span class="line">        print(this.__dict__)#显示为&#123;&#125;空字典</span><br><span class="line">        this.boxname = boxname</span><br><span class="line">        this.__dict__[&apos;aa&apos;] = &apos;w&apos;#甚至可以像字典一样操作</span><br><span class="line">        this.size = size</span><br><span class="line">        this.color = color  # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self</span><br><span class="line"> </span><br><span class="line">    def open(this):</span><br><span class="line">        print(&apos;--&gt;用自己的myself，打开那个%s,%s的%s&apos; % (this.color, this.size, this.boxname))</span><br><span class="line">        print(&apos;--&gt;用类自己的self，打开那个%s,%s的%s&apos; % (this.color, this.size, this.boxname))</span><br><span class="line"> </span><br><span class="line">    def close(this):</span><br><span class="line">        print(&apos;--&gt;关闭%s，谢谢&apos; % this.boxname)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 经过改造，运行结果和标准初始化没区别</span><br><span class="line">box=Box()</span><br><span class="line">box.myInit(&apos;魔盒&apos;, &apos;14m&apos;, &apos;红色&apos;)</span><br><span class="line"># b = Box(&apos;魔盒&apos;, &apos;14m&apos;, &apos;红色&apos;)#注释掉原来标准的初始化方法</span><br><span class="line">box.close()</span><br><span class="line">box.open()  # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。</span><br><span class="line">print(box.__dict__)  #对象会自动生成一个dict用来保存成员变量。</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&#123;&#125;</span><br><span class="line">--&gt;关闭魔盒，谢谢</span><br><span class="line">--&gt;用自己的myself，打开那个红色,14m的魔盒</span><br><span class="line">--&gt;用类自己的self，打开那个红色,14m的魔盒</span><br><span class="line">&#123;&apos;boxname&apos;: &apos;魔盒&apos;, &apos;aa&apos;: &apos;w&apos;, &apos;size&apos;: &apos;14m&apos;, &apos;color&apos;: &apos;红色&apos;&#125;</span><br></pre></td></tr></table></figure><h1 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h1><ol><li>单继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print &apos;Create Base&apos;</span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        super(A, self).__init__() #python2和python3</span><br><span class="line">        super().__init__() #python3</span><br><span class="line">        print &apos;Create A&apos;</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line"></span><br><span class="line"># 测试结果</span><br><span class="line">Create Base</span><br><span class="line">Create A</span><br></pre></td></tr></table></figure></li></ol><p>在单继承时，super().<strong>init</strong>()与Base.<strong>init</strong>()是一样的。super()避免了基类的显式调用。如果Base修改，A类也需要修改，使用super就好很多了。</p><ol><li>多继承<br>super与父类没有实质性的关联。在单继承时，super获取的类刚好是父类，但多继承时，super获取的是继承顺序中的下一个类。<br>Python中的super()方法设计目的是用来解决多重继承时父类的查找问题，所以在单重继承中用不用 super 都没关系；一般我们在子类中需要调用父类的方法时才会这么用。</li></ol><p><strong> 解决多继承带来的重复调用（菱形继承）、查找顺序（MRO）问题 </strong><br>用“父类名.属性”的方法调用出来代码维护时繁琐一点也并无不可，但Python是的继承机制是多继承，还是用这种方法来调用父类属性就会就回带来许多问题。假如有A、B、C、D这4个类，继承关系如下，我们要在各子类方法中显式调用父类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo&apos;)</span><br><span class="line">        </span><br><span class="line">class Foo1(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo1&apos;)</span><br><span class="line">        super(Foo1, self).x()</span><br><span class="line"> </span><br><span class="line">class Foo2(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print(&apos;Foo2&apos;)</span><br><span class="line">        super(Foo2, self).x()  #调用过程中self 是Foo3()</span><br><span class="line"> </span><br><span class="line">class Foo3(Foo2,Foo1):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo3&apos;)</span><br><span class="line">        super(Foo3,self).x()</span><br><span class="line">        </span><br><span class="line">f = Foo3()</span><br><span class="line">f.x()</span><br><span class="line">print(Foo3.mro())</span><br><span class="line"></span><br><span class="line"># 类按照mro顺序调用</span><br><span class="line">输出：</span><br><span class="line">Foo3</span><br><span class="line">Foo2</span><br><span class="line">Foo1</span><br><span class="line">Foo</span><br><span class="line">[&lt;class &apos;__main__.Foo3&apos;&gt;, &lt;class &apos;__main__.Foo2&apos;&gt;, &lt;class &apos;__main__.Foo1&apos;&gt;, &lt;class &apos;__main__.Foo&apos;&gt;, &lt;class &apos;object&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>如果不用super，Foo会被调用两次，这就是多继承带来的重复调用的问题。<br>事实上，在每个类声明之后，Python都会自动为创建一个名为“<strong>mro</strong>”的内置属性，这个属性就是Python的MRO机制生成的，该属性是一个tuple，定义的是该类的方法解析顺序（继承顺序），当用super调用父类的方法时，会按照<strong>mro</strong>属性中的元素顺序去挨个查找方法。我们可以通过“类名.mro”或“类名.mro()”来查看上面代码中Foo3类的<strong>mro</strong>属性值：</p><ol><li>怎么用super<br>super是一个类（不是方法），实例化之后得到的是一个代理的对象，而不是得到了父类，并且我们使用这个代理对象来调用父类或者兄弟类的方法。使用格式如下：<br><code>super([type[, object-or-type]])</code><br>将这个格式展开来就有一下几种传参方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super()</span><br><span class="line">super(type , obj)</span><br><span class="line">super(type_1 , type_2)</span><br></pre></td></tr></table></figure></li></ol><p>3.1 super(type , obj)<br>先说super(type , obj)，这个方式要传入两个常数，第一个参数type必须是一个类名，第二个参数是一个该类的实例化对象，不过可以不是直接的实例化对象，该类的子类的实例化对象也行。在上文中已经说到，super会按照<strong>mro</strong>属性中的顺序去查找方法，super(type , obj)两个参数中type作用是定义在<strong>mro</strong>数组中的那个位置开始找，obj定义的是用哪个类的<strong>mro</strong>元素。</p><p>3.2 super()<br>super()事实上是懒人版的super(type , obj)，这种方式只能用在类体内部，Python会自动把两个参数填充上，type指代当前类，obj指导当前类的实例对象，相当于super(class , self)。所以，以下三种代码是完全等效的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super().fun()</span><br><span class="line">super(B , self).fun()</span><br><span class="line">super(__class__ , self).fun()</span><br></pre></td></tr></table></figure></p><p>3.3 super(type_1 , type_2)<br>当super传入的两个参数都是类名是，type_2必须是type_1的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(super(F , F()).fun()) #输出结果为：D.fun</span><br><span class="line">print(super(F , F).fun()) # 报错：TypeError: fun() missing 1 required positional argument: &apos;self&apos;</span><br></pre></td></tr></table></figure></p><p>所以，super(type_1 , type_2)与super(type , obj)有区别，在看一下下列输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(super(F , F()).fun)# 输出结果：&lt;bound method D.fun of &lt;__main__.F object at 0x000001BD44A98B38&gt;&gt;</span><br><span class="line">print(super(F , F).fun) # 输出结果：&lt;function D.fun at 0x000001BD44A9EE18&gt;</span><br><span class="line">print(D.fun) # 输出结果：&lt;function D.fun at 0x000001BD44A9EE18&gt;</span><br></pre></td></tr></table></figure></p><p>所以，当super传入的两个传输都是类时，得到的就是一个指向继承顺序下的类的代理，并未绑定实例，要调用D类的fun方法，还需传入实例：<br><code>print(super(F , F).fun(F())) #输出结果：D.fun</code><br>所以，当super传入的两个参数都是类的时候，最好只用来调用类的静态方法或者类方法。</p><p><a href="https://blog.csdn.net/dxk_093812/article/details/87553937" target="_blank" rel="noopener">参考</a></p><p>3.4 避免使用 super(self.<strong>class</strong>, self)，一般情况下是没问题的，就是怕极端的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo&apos;</span><br><span class="line"> </span><br><span class="line">class Foo2(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo2&apos;</span><br><span class="line">        super(self.__class__, self).x() # wrong</span><br><span class="line"> </span><br><span class="line">class Foo3(Foo2):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo3&apos;</span><br><span class="line">        super(Foo3, self).x()</span><br><span class="line"> </span><br><span class="line">f = Foo3()</span><br><span class="line">f.x()</span><br></pre></td></tr></table></figure></p><p>在 Foo2 中的 super(self.<strong>class</strong>, self) 导致了死循环，super 永远去找 Foo3 的 MRO 中的下一个类，super 的第一个参数应该总是当前的类。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> self </tag>
            
            <tag> super </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-notices</title>
      <link href="/2021/02/05/pytorch-notices/"/>
      <url>/2021/02/05/pytorch-notices/</url>
      
        <content type="html"><![CDATA[<p>pytorch 踩过的坑<br><a id="more"></a></p><h1 id="cuda-数据和模型的差异"><a href="#cuda-数据和模型的差异" class="headerlink" title=".cuda()数据和模型的差异"></a>.cuda()数据和模型的差异</h1><p>nn.Module.cuda() 和 Tensor.cuda() 的作用效果差异，无论是对于模型还是数据，cuda()函数都能实现从CPU到GPU的内存迁移，但是他们的作用效果有所不同。<br>对于nn.Module:<br><code>model = model.cuda()</code>和<code>model.cuda()</code>能够达到一样的效果，即对model自身进行的内存迁移。<br>对于Tensor:<br>调用tensor.cuda()只是返回这个tensor对象在GPU内存上的拷贝，而不会对自身进行改变。因此必须对tensor进行重新赋值，即tensor=tensor.cuda().<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = create_a_model() </span><br><span class="line">tensor = torch.ones([3,3,3,3]) </span><br><span class="line">model.cuda() </span><br><span class="line">tensor.cuda() </span><br><span class="line">model(tensor)    # 会报错 </span><br><span class="line">tensor = tensor.cuda() </span><br><span class="line">model(tensor)    # 正常运行</span><br></pre></td></tr></table></figure></p><h1 id="torch-Tensor-detach-的使用"><a href="#torch-Tensor-detach-的使用" class="headerlink" title="torch.Tensor.detach()的使用"></a>torch.Tensor.detach()的使用</h1><p>detach()的官方说明如下：<br><code>Returns a new Tensor, detached from the current graph. The result will never require gradient.</code><br>假设有模型A和模型B，我们需要将A的输出作为B的输入，但训练时我们只训练模型B. 那么可以这样做：<br><code>input_B = output_A.detach()</code><br>它可以使两个计算图的梯度传递断开，从而实现我们所需的功能。</p><h1 id="使用nn-Dataparallel-数据不在同一个gpu上"><a href="#使用nn-Dataparallel-数据不在同一个gpu上" class="headerlink" title="使用nn.Dataparallel 数据不在同一个gpu上"></a>使用nn.Dataparallel 数据不在同一个gpu上</h1><p><code>model=nn.DataParallel(model)</code><br>问题：但是一次同事训练基于光流检测的实验时发现 data not in same cuda,做代码review时候，打印每个节点tensor，cuda里的数据竟然没有分布在同一个gpu上<br>解决：最终解决方案是在数据，吐出后统一进行执行.cuda()将数据归入到同一个cuda流中解决了该问题。</p><h1 id="pytorch-model-load可能会踩到的坑："><a href="#pytorch-model-load可能会踩到的坑：" class="headerlink" title="pytorch model load可能会踩到的坑："></a>pytorch model load可能会踩到的坑：</h1><p>如果使用了nn.Dataparallel 进行多卡训练在读入模型时候要注意加.module， 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def get_model(self):</span><br><span class="line">  if self.nGPU == 1:         </span><br><span class="line">      return self.model     </span><br><span class="line">  else:         </span><br><span class="line">      return self.model.module</span><br></pre></td></tr></table></figure></p><p><a href="https://zhuanlan.zhihu.com/p/59271905?utm_source=wechat_session" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper</title>
      <link href="/2021/01/18/paper/"/>
      <url>/2021/01/18/paper/</url>
      
        <content type="html"><![CDATA[<p>文章阅读<br><a id="more"></a></p><h1 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h1><h2 id="Sketch"><a href="#Sketch" class="headerlink" title="Sketch"></a>Sketch</h2><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="datasets"><a href="#datasets" class="headerlink" title="datasets"></a>datasets</h3><ol><li><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2></li></ol><h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><p>１. <a href>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a><br>BERT 的输入可以包含一个句子对 (句子 A 和句子 B)，也可以是单个句子。此外还增加了一些有特殊作用的标志位：<br>[CLS] 标志放在第一个句子的首位，经过 BERT 得到的的表征向量 C 可以用于后续的分类任务。<br>[SEP] 标志用于分开两个输入句子，例如输入句子 A 和 B，要在句子 A，B 后面增加 [SEP] 标志。<br>[UNK]标志指的是未知字符<br>[MASK] 标志用于遮盖句子中的一些单词，将单词用 [MASK] 遮盖之后，再利用 BERT 输出的 [MASK] 向量预测单词是什么。</p><h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2><ol><li><a href="https://mp.weixin.qq.com/s/PxEUU6VhB0iuCi2F_Xy-Kw" target="_blank" rel="noopener">LayoutLM2.0</a><br><a href="https://arxiv.org/abs/2012.14740" target="_blank" rel="noopener">LayoutLMv2: Multi-modal Pre-training for Visually-Rich Document Understanding</a><br>Public: arxiv 2020,Harbin Institute of Technology,Microsoft Research Asia<br><a href="https://github.com/microsoft/unilm/tree/master/layoutlm" target="_blank" rel="noopener">code</a><br>Abstract:主要针对扫描文件或数字商业文档进行理解并分析。特点在于在输入阶段直接引入了图像信息，利用多模态预训练框架对文本、图像和布局信息进行联合建模。</li></ol><h1 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h1><h1 id="MM"><a href="#MM" class="headerlink" title="MM"></a>MM</h1><h2 id="Vison-Language"><a href="#Vison-Language" class="headerlink" title="Vison Language"></a>Vison Language</h2><p>多模特任务主要集中在文本和图像，文本和语音</p><ol><li><p><a href="https://arxiv.org/pdf/2003.13198" target="_blank" rel="noopener">M6-v0: Vision-and-Language Interaction for Multi-modal Pretraining</a><br>Public: arxiv 2020，Alibaba Group,Peking University<br>Abstract: 提出了一个文本和图像多模特预训练方法InterBERT，核心还是transformer中的Attention，里边包含一个 single-stream interaction module和一个 two-stream module，使用三个预训练任务 masked segment modeling (MSM), masked region modeling(MRM) and image-text matching (ITM)来训练模型。single-stream可以有效处理多模特信息，two-stream 保证了每个模特的独立性，避免在单模态任务性能的下降。最后针对downstream stask来精调模型。感觉就是把transformer输入文本变成了同时输入文本和图像，输出也是文本和图像分别输出。<br>预训练模型经过finetune可以用于：text-based image retrieval，Zero-Shot Caption-Based Image Retrieval，Visual Commonsense Reasoning<br>data：提出了一个大规模（3.1Ｍ image-text pairs）基于手机淘宝收集的中文数据集，但是还没有公布。<br>code: 有，未运行。</p><h2 id="Spoke-Lanuage"><a href="#Spoke-Lanuage" class="headerlink" title="　Spoke Lanuage"></a>　Spoke Lanuage</h2></li><li><p><a href="https://arxiv.org/pdf/2012.08549" target="_blank" rel="noopener">Exploring Transfer Learning For End-to-End Spoken Language Understanding</a><br>Public: arxiv 2020<br>Abstract:</p></li><li><p><a href="https://arxiv.org/pdf/2011.06195" target="_blank" rel="noopener">Towards Semi-Supervised Semantics Understanding from Speech</a><br>Public: arxiv 2020<br>Abstract:</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remote-connect</title>
      <link href="/2020/11/12/remote-connect/"/>
      <url>/2020/11/12/remote-connect/</url>
      
        <content type="html"><![CDATA[<p>linux系统安装后远程连接，包括终端和远程桌面。<br>screen和tmux可以保持终端，客户端关闭后也不会退出，再次进入后可以直接进入原终端。<br><a id="more"></a></p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>安装<br><code>sudo apt-get install openssh-server</code><br>连接<br><code>ssh -p PORT user@IP</code></p><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>缺点：容易使用，没有tmux好用<br>安装<br><code>sudo apt-get install screen</code><br>screen -S  name #创建screen会话，自定义screen虚拟终端的名称<br>关闭ssh<br>screen -r name #查看之前的会话虚拟终端</p><p>错误：<br>There is no screen to be resumed matching <strong><em><br>screen -d *</em></strong><br>然后再使用恢复命令恢复就 ok 了</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>优点：功能较多，可以轻易将终端划分。<br>安装<br>sudo apt-get install tmux<br><a href="https://blog.zhengmingz.top/2019/09/09/ZshTmuxVim/">使用</a></p><h1 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h1><h2 id="不需要安装桌面直接进入当前显示器桌面"><a href="#不需要安装桌面直接进入当前显示器桌面" class="headerlink" title="不需要安装桌面直接进入当前显示器桌面"></a>不需要安装桌面直接进入当前显示器桌面</h2><p>缺点：桌面操作卡顿，只能一个用户进入<br><a href="https://www.jianshu.com/p/9dce33bb490c" target="_blank" rel="noopener">参考</a></p><h2 id="需要安装桌面"><a href="#需要安装桌面" class="headerlink" title="需要安装桌面"></a>需要安装桌面</h2><p>缺点：桌面不够清晰，有部分程序界面打不开（如vs）<br>安装vnc4server<br><code>sudo apt-get install vnc4server</code><br>终端输入<code>vncserver</code>设置密码<br>安装gnome相关组件<br><code>sudo apt-get install gnome-core gnome-panel gnome-session gnome-settings-daemon gnome-terminal metacity nautilus</code><br>关闭已经开启的vnc会话<br>vncserver -kill :1<br>修改vnc启动文件<br>sudo vim ~/.vnc/xstartup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup</span><br><span class="line">[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">#x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;</span><br><span class="line">#x-window-manager &amp;</span><br><span class="line"></span><br><span class="line">export XKL_XMODMAP_DISABLE=1</span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line"></span><br><span class="line">gnome-session&amp;</span><br><span class="line">gnome-panel&amp;</span><br><span class="line">gnome-settings-daemon&amp;</span><br><span class="line">gnome-terminal&amp;</span><br><span class="line">metacity&amp;</span><br><span class="line">nautilus&amp;</span><br></pre></td></tr></table></figure></p><p>打开会话<br>vncserver ：1（2）</p><p>客户端连接：<br>IP：5901（5902）</p><p>多用户登录<br>每个用户执行vncserver，输入密码，修改启动文件<br>在终端打开会话，客户端可以使用vncviewer连接<br><a href="https://blog.csdn.net/w113691/article/details/78396896" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tmux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> remote </tag>
            
            <tag> ssh </tag>
            
            <tag> vnc </tag>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dict-list-tuple-string</title>
      <link href="/2020/06/13/dict-set-tuple/"/>
      <url>/2020/06/13/dict-set-tuple/</url>
      
        <content type="html"><![CDATA[<p>python中dict、list、tuple、string几种数据类型的一些用法。<br><a id="more"></a></p><h1 id="字典按value排序"><a href="#字典按value排序" class="headerlink" title="字典按value排序"></a>字典按value排序</h1><p>保存为字典后，按字典value值大小排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line"># set集合去重</span><br><span class="line">s = set(a) </span><br><span class="line"></span><br><span class="line"># 保存为dict</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">for i in s:</span><br><span class="line">    d[i] = a.count(i)</span><br><span class="line"></span><br><span class="line"># 对字典排序</span><br><span class="line">a = sorted(d.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/DasyDong/interview/blob/master/notes/python_analyse.md" target="_blank" rel="noopener">reference</a></p><h1 id="lambda用法说明"><a href="#lambda用法说明" class="headerlink" title="lambda用法说明"></a>lambda用法说明</h1><p><a href="https://www.cnblogs.com/evening/archive/2012/03/29/2423554.html" target="_blank" rel="noopener">reference 1</a><br><a href="https://blog.csdn.net/zjuxsl/article/details/79437563" target="_blank" rel="noopener">reference 2</a></p><h1 id="list转字符串"><a href="#list转字符串" class="headerlink" title="list转字符串"></a>list转字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">&apos;&apos;.join(list) 为：12345</span><br><span class="line">&apos;,&apos;.join(list) 为：1,2,3,4,5</span><br></pre></td></tr></table></figure><h1 id="根据路径获取文件名"><a href="#根据路径获取文件名" class="headerlink" title="根据路径获取文件名"></a>根据路径获取文件名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.dirname(path)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dict </tag>
            
            <tag> set </tag>
            
            <tag> tuple </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowsocks</title>
      <link href="/2020/04/20/shadowsocks/"/>
      <url>/2020/04/20/shadowsocks/</url>
      
        <content type="html"><![CDATA[<p>shadowsocks-python,shadowsocks-libev,shadowxocksR等多个版本shadowsocks的服务器端的安装,以ubuntu安装为例<br><a id="more"></a></p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="shadowsocks-python-安装"><a href="#shadowsocks-python-安装" class="headerlink" title="shadowsocks-python 安装"></a>shadowsocks-python 安装</h2><p><a href="https://github.com/zzmshinnosuke/ss/blob/master/ubuntu.sh" target="_blank" rel="noopener">参考</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip  </span><br><span class="line">sudo apt-get install python3-setuptools  </span><br><span class="line">pip3 install shadowsocks</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;server&quot;:&quot;::&quot;,   #同时支持ipv4和ipv6</span><br><span class="line"> &quot;port_password&quot;: &#123;</span><br><span class="line">    &quot;port1&quot;:&quot;password1&quot;,</span><br><span class="line">    &quot;port2&quot;: &quot;password2&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动、结束"><a href="#启动、结束" class="headerlink" title="启动、结束"></a>启动、结束</h3><p>ssserver -c ~/shadowsocks.json -d start<br>ssserver -c ~/shadowsocks.json -d stop</p><h2 id="shadowsocks-libev安装"><a href="#shadowsocks-libev安装" class="headerlink" title="shadowsocks-libev安装"></a>shadowsocks-libev安装</h2><p>shadowsocks-libev可以支持更多的加密方式  </p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common -y   </span><br><span class="line">sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y   </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/shadowsocks-libev/config.json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;server&quot;:[&quot;[::]&quot;,&quot;0.0.0.0&quot;], #同时支持ipv4和ipv6</span><br><span class="line"> &quot;server_port&quot;:443,</span><br><span class="line"> &quot;password&quot;:&quot;123456&quot;,</span><br><span class="line"> &quot;timeout&quot;:600,</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>启动：systemctl restart shadowsocks-libev  </p><p>想要以后每次重启（Linux的CentOS）服务器时都可以自动启动此ss服务，则可以去：  </p><p>设置开机启动：systemctl enable shadowsocks-libev  </p><p>其他相关命令：  </p><pre><code>查看状态：systemctl status shadowsocks-libev  查看日志：journalctl -u shadowsocks-libev重启：systemctl restart shadowsocks-libev</code></pre><p>用shadowsocks-libev实现多账号/多用户  </p><p>上述创建的ss服务，只有一个（账号）密码，只能供一个人用，或者说，如果多个人使用，则使用的是同一个（账号）密码，显得很不方便和不安全。  </p><p>如果想要多个用户每人有不同的账号（密码），则可以：用shadowsocks-libev实现多账号/多用户  </p><p>新建另外一个配置文件，比如：   </p><p>/etc/shadowsocks-libev/config2.json  </p><p>内容和之前一致，只是端口号server_port和密码password改了一下即可：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;: 21501,</span><br><span class="line">    &quot;password&quot;: &quot;passowrd2&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;: 300,</span><br><span class="line">    &quot;mode&quot;: &quot;tcp_and_udp&quot;&#125;Copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>注意: 端口号不要和系统中其他服务的端口号冲突了。  </code></pre><p>另外再去用：<br><code>setsid ss-server -c /etc/shadowsocks-libev/config2.json -uCopy</code><br>启用新端口对应的ss服务。</p><h2 id="shadowsocksR"><a href="#shadowsocksR" class="headerlink" title="shadowsocksR"></a>shadowsocksR</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">git clone -b manyuser https://github.com/shadowsocksr-backup/shadowsocksr.git</span><br></pre></td></tr></table></figure><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup" target="_blank" rel="noopener">参考</a></p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>sudo ufw allow port<br>sudo ufw enable</p><h1 id="客户端（ubuntu）"><a href="#客户端（ubuntu）" class="headerlink" title="客户端（ubuntu）"></a>客户端（ubuntu）</h1><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><p>安装同server版</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>sslocal -c shadowsocks.json</p><h1 id="linux-shell代理"><a href="#linux-shell代理" class="headerlink" title="linux shell代理"></a>linux shell代理</h1><p>安装 proxychains<br><code>sudo apt-get install proxychains</code><br>配置代理信息<br><code>sudo vim /etc/proxychains.conf</code><br>最后一行改成自己的代理信息：<br><code>socks5 127.0.0.1 1080</code><br>使用在命令前加上proxychains：<br><code>proxychains git clone *****</code></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日事务安排应用</title>
      <link href="/2019/12/30/Develop-DailyManage/"/>
      <url>/2019/12/30/Develop-DailyManage/</url>
      
        <content type="html"><![CDATA[<p>自己开发一个可以进行事务管理的应用程序，目前只支持网页版，自己开发，自己部署。<br>可以对每天需要做事情按照重要性和紧急性进行排序。<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>重要性： </p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>不重要</td><td>有点重要</td><td>重要</td><td>很重要</td><td>非常重要</td></tr><tr><td>可做可不做</td><td>做了比不做好，不做影响不大</td><td>不做会有一定后果</td><td>必须做，不做后果有点严重</td><td>必须做（有关生命、前途、健康）</td></tr></tbody></table></div><p>紧急性： </p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>不紧急</td><td>有点紧急</td><td>紧急</td><td>很紧急</td><td>非常紧急</td></tr><tr><td>事情期限还早，工作量很小</td><td>事情临近期限，想做可以开始</td><td>现在不开始，后面会比较忙</td><td>今天必须做</td><td>现在必须做</td></tr></tbody></table></div><p>完成情况</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>还没开始</td><td>做了一些</td><td>完成一半</td><td>完成一多半</td><td>完成</td></tr></tbody></table></div><h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><p><strong>user表</strong></p><div class="table-container"><table><thead><tr><th>Userid</th><th>username</th><th>passwd</th><th>Remark</th></tr></thead><tbody><tr><td>char(10)</td><td>uchar(20)</td><td>uchar(20)</td><td>uchar(100)</td></tr></tbody></table></div><p><strong>transaction表</strong></p><div class="table-container"><table><thead><tr><th>Userid</th><th>addtime</th><th>needtime</th><th>deadline</th><th>importance</th><th>urgency</th><th>progress</th></tr></thead><tbody><tr><td>char(10)</td><td>char(10)</td><td>long</td><td>char(10)</td><td>int</td><td>int</td><td>int</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> 开发，事务安排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理</title>
      <link href="/2019/12/22/ImageProcess/"/>
      <url>/2019/12/22/ImageProcess/</url>
      
        <content type="html"><![CDATA[<p>处理图像：截取图像<br><a id="more"></a></p><h1 id="python-的图像库-Opencv、PIL、matplotlib、skimage-使用"><a href="#python-的图像库-Opencv、PIL、matplotlib、skimage-使用" class="headerlink" title="python 的图像库(Opencv、PIL、matplotlib、skimage)使用"></a>python 的图像库(Opencv、PIL、matplotlib、skimage)使用</h1><p><a href="https://www.cnblogs.com/skyfsm/p/8276501.html" target="_blank" rel="noopener">参考-更好</a><br><a href="https://blog.csdn.net/qq_36941368/article/details/82998296" target="_blank" rel="noopener">参考</a><br><strong>cv2的记录</strong><br>ret=cv2.bitwise_and(src1,src2,dst,mask) ret和dst都可以，mask相当于在src1和src2与运算结果上又进行了一次mask与运算,但是mask是单通道的。mask区域会被保存下来，其他部分编变成黑色。</p><p><strong>matplotlib的记录</strong><br>plt.imshow()显示只有0,1的图像，但是输出是紫色和黄色的。如果要展示黑白，plt.set_cmat(‘binary’)，但是会把黑白反过来，masked区域为白色，其余为黑色。</p><h1 id="一、截取图像的一部分"><a href="#一、截取图像的一部分" class="headerlink" title="一、截取图像的一部分"></a>一、截取图像的一部分</h1><h2 id="1-使用Pillow"><a href="#1-使用Pillow" class="headerlink" title="1.使用Pillow"></a>1.使用Pillow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(path)</span><br><span class="line">img=img.crop((left, up, right, below))</span><br><span class="line"># left：与左边界的距离</span><br><span class="line"># up：与上边界的距离</span><br><span class="line"># right：还是与左边界的距离</span><br><span class="line"># below：还是与上边界的距离</span><br><span class="line">img.save(target_path+name)</span><br></pre></td></tr></table></figure><h2 id="2-多边形裁剪-多边形外的其他地方透明-python-opencv"><a href="#2-多边形裁剪-多边形外的其他地方透明-python-opencv" class="headerlink" title="2.多边形裁剪(多边形外的其他地方透明)(python-opencv)"></a>2.多边形裁剪(多边形外的其他地方透明)(python-opencv)</h2><p>方法一和二的不同在于：把mask的多边形区域设置为0还是255（黑白）。 如果mask多边形区域设为0，可以直接与原图相加，该区域不变，原图其他位置变成白色；如果mask多边形区域设为255，可以与原图进行与运算，该区域不变，其他区域变成黑色<br>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-7</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&quot;0.jpg&quot;)</span><br><span class="line">print(image.shape)</span><br><span class="line">b  = np.array([[100,100],  [250,100], [300,220],[100,230]], dtype = np.int32)</span><br><span class="line"></span><br><span class="line">roi_t = []</span><br><span class="line">for i in range(4):</span><br><span class="line">    roi_t.append(b[i])</span><br><span class="line"></span><br><span class="line"># 生成mask，多边形区域设为255白色</span><br><span class="line">roi_t = np.asarray(roi_t)</span><br><span class="line">roi_t = np.expand_dims(roi_t, axis=0)</span><br><span class="line">im = np.zeros(image.shape[:2], dtype = &quot;uint8&quot;)</span><br><span class="line">cv2.polylines(im, roi_t, 1, 255)</span><br><span class="line">cv2.fillPoly(im, roi_t, 255)</span><br><span class="line">mask = im</span><br><span class="line">masked = cv2.bitwise_and(image, image, mask=mask)</span><br><span class="line"></span><br><span class="line">#非多边形区域做透明处理</span><br><span class="line">array = np.zeros((masked.shape[0], masked.shape[1], 4), np.uint8)</span><br><span class="line">print(array.shape)</span><br><span class="line">array[:, :, 0:3] = masked</span><br><span class="line">array[:, :, 3] = 0</span><br><span class="line">array[:,:,3][np.where(array[:,:,0]&gt;2)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,1]&gt;2)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,2]&gt;2)]=255</span><br><span class="line">cv2.imwrite(&apos;0_opencv.png&apos;,array,[cv2.IMWRITE_PNG_COMPRESSION,1]) #可以设置图像的压缩程度，9压缩程度最高。</span><br><span class="line"></span><br><span class="line"># 使用PIL.Image 保存图片颜色发生了变化，重新读出来，与原图不一样.</span><br><span class="line">#opencv的接口使用BGR，而matplotlib.pyplot 则是RGB模式</span><br><span class="line">#下面代码cv2读入的是BGR模式，在opencv里面存储的是BGR，所以img用opencv输出就是正常颜色；</span><br><span class="line">#而matplotlib.pyplot是RGB模式，当用cv读入，直接用matplotlib.pyplot输出，颜色就变了，所以需要调整颜色的顺序；</span><br><span class="line"></span><br><span class="line">b,g,r,a = cv2.split(array)</span><br><span class="line">img2 = cv2.merge([r,g,b,a])</span><br><span class="line">print(img2.max())</span><br><span class="line">image_1 = Image.fromarray(img2)</span><br><span class="line">image_1.save(&quot;0_PIL.png&quot;,&quot;PNG&quot;)</span><br><span class="line"></span><br><span class="line">new_image = cv2.imread(&apos;0_opencv.png&apos;,cv2.IMREAD_UNCHANGED) # 不加cv2.IMREAD_UNCHANGED 只能读出三个通道，透明通道不能读取</span><br><span class="line">print((array==new_image).all(),new_image.shape,array.shape) # .all()全部为True，结果为True；.any()有一个为True，结果为True</span><br><span class="line"></span><br><span class="line">cv2.imshow(&quot;cutout Image&quot;, array)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&quot;0.jpg&quot;)</span><br><span class="line"></span><br><span class="line">b  = np.array([[100,100],  [250,100], [300,220],[100,230]], dtype = np.int32)</span><br><span class="line"></span><br><span class="line">roi_t = []</span><br><span class="line">for i in range(4):</span><br><span class="line">    roi_t.append(b[i])</span><br><span class="line"></span><br><span class="line"># 生成mask，，多边形区域设为0黑色</span><br><span class="line">roi_t = np.asarray(roi_t)</span><br><span class="line">roi_t = np.expand_dims(roi_t, axis=0)</span><br><span class="line">im = np.zeros(image.shape[:3], dtype = &quot;uint8&quot;)</span><br><span class="line">im.fill(255)</span><br><span class="line">cv2.polylines(im, roi_t, 1, 0)</span><br><span class="line">cv2.fillPoly(im, roi_t, 0)</span><br><span class="line">mask = im</span><br><span class="line">masked = cv2.add(image, mask)</span><br><span class="line">imp = Image.fromarray(image)</span><br><span class="line"></span><br><span class="line">#非多边形区域做透明处理</span><br><span class="line">array = np.zeros((masked.shape[0], masked.shape[1], 4), np.uint8)</span><br><span class="line">array[:, :, 0:3] = masked</span><br><span class="line">array[:, :, 3] = 0</span><br><span class="line">array[:,:,3][np.where(array[:,:,0]&lt;255)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,1]&lt;255)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,2]&lt;255)]=255</span><br><span class="line">cv2.imwrite(&apos;0_opencv.png&apos;,array,[cv2.IMWRITE_PNG_COMPRESSION,1]) #可以设置图像的压缩程度，9压缩程度最高。</span><br><span class="line">cv2.imshow(&quot;cutout Image&quot;, array)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h1 id="二、修改图像大小"><a href="#二、修改图像大小" class="headerlink" title="二、修改图像大小"></a>二、修改图像大小</h1><h2 id="1-使用Pillow-1"><a href="#1-使用Pillow-1" class="headerlink" title="1.使用Pillow"></a>1.使用Pillow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(path)</span><br><span class="line">reim=img.resize((128,128))</span><br><span class="line">reim=img.thumnail((128,128))</span><br><span class="line">#resize()方法可以缩小也可以放大，而thumbnail()方法只能缩小；</span><br><span class="line">#resize()方法不会改变对象的大小，只会返回一个新的Image对象，而thumbnail()方法会直接改变对象的大小，返回值为none；</span><br><span class="line">#resize()方法中的size参数直接规定了修改后的大小，而thumbnail()方法按比例缩小，size参数只规定修改后size的最大值。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Image </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Image </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2019/10/24/mysql/"/>
      <url>/2019/10/24/mysql/</url>
      
        <content type="html"><![CDATA[<p>在ubuntu18中安装mysql，并进行相关配置<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install mysql-server</p><h1 id="首次安装后root用户密码不正确的问题"><a href="#首次安装后root用户密码不正确的问题" class="headerlink" title="首次安装后root用户密码不正确的问题"></a>首次安装后root用户密码不正确的问题</h1><p>通过apt-get 命令安装的MySQL，默认的登录名和登录密码是保存在 /etc/mysql/debian.cnf 下的。<br>在命令行输入  sudo vi /etc/mysql/debian.cnf 。通过默认登录名和密码进行修改。<br><a href="https://blog.csdn.net/verylonglongago/article/details/85479704" target="_blank" rel="noopener">参考</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>（首次安装后直接运行这个会显示密码错误，需要先修改root密码）<br>sudo mysql_secure_installation<br>安装完mysql-server 会提示可以运行mysql_secure_installation。运行mysql_secure_installation会执行几个设置：<br>—为root用户设置密码<br>—删除匿名账号<br>—取消root用户远程登录<br>—删除test库和对test库的访问权限<br>—刷新授权表使修改生效<br>通过这几项的设置能够提高mysql库的安全。</p><p>建议生产环境中mysql安装这完成后一定要运行一次mysql_secure_installation，相关操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mysql_secure_installation</span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL</span><br><span class="line">SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line">In order to log into MySQL to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user. If you&apos;ve just installed MySQL, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line">Enter current password for root (enter for none):&lt;–初次运行直接回车</span><br><span class="line">OK, successfully used password, moving on…</span><br><span class="line">Setting the root password ensures that nobody can log into the MySQL</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line">Set root password? [Y/n]    #是否设置root用户密码，输入y并回车或直接回车</span><br><span class="line">New password:               #设置root用户的密码</span><br><span class="line">Re-enter new password:      #再输入一次你设置的密码</span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line">… Success!</span><br><span class="line">By default, a MySQL installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MySQL without having to have a user account created for</span><br><span class="line">them. This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother. You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line">Remove anonymous users? [Y/n]   #是否删除匿名用户,生产环境建议删除，所以直接回车</span><br><span class="line">… Success!</span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;. This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line">Disallow root login remotely? [Y/n] #是否禁止root远程登录,根据自己的需求选择Y/n并回车,建议禁止</span><br><span class="line">… Success!</span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access. This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line">Remove test database and access to it? [Y/n] #是否删除test数据库,直接回车</span><br><span class="line">- Dropping test database…</span><br><span class="line">… Success!</span><br><span class="line">- Removing privileges on test database…</span><br><span class="line">… Success!</span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line">Reload privilege tables now? [Y/n] #是否重新加载权限表，直接回车</span><br><span class="line">… Success!</span><br><span class="line">Cleaning up…</span><br><span class="line">All done! If you&apos;ve completed all of the above steps, your MySQL</span><br><span class="line">installation should now be secure.</span><br><span class="line">Thanks for using MySQL!</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h1><p><a href="https://www.cnblogs.com/xbxxf/p/9174028.html" target="_blank" rel="noopener">参考</a><br>1.使用root用户登录mysql<br>mysql -u root -p<br>2.新增一个用户<br>use mysql;<br>CREATE USER ‘username’@’localhost’ IDENTIFIED BY ‘password’;<br>3.给新用户添加权限<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘username’@’%’ IDENTIFIED BY ‘password’ WITH GRANT OPTION;<br>flush privileges;<br>quit<br>4.修改mysql配置文件<br>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf<br>找到bind-address = 127.0.0.1<br>修改为 bind-address = 0.0.0.0<br>:wq<br>5.重启mysql<br>service mysql restart<br>6.开放3306端口<br>服务器需要配置安全组规则<br>有防火墙需要开放3306<br>sudo ufw allow 3306</p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c中指针地址加1</title>
      <link href="/2019/10/22/c-point-addr/"/>
      <url>/2019/10/22/c-point-addr/</url>
      
        <content type="html"><![CDATA[<p>c、c++中一些指针、数组地址加减的问题<br><a id="more"></a></p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a[5]=&#123;0,1,2,3,4&#125;;</span><br><span class="line">int *p=(int *)(&amp;a+1);</span><br><span class="line">printf(&quot;%p\n&quot;,&amp;a);</span><br><span class="line">printf(&quot;%p\n&quot;,&amp;a+1);</span><br><span class="line">printf(&quot;%d\n&quot;,*(p));</span><br><span class="line">printf(&quot;%d\n&quot;,*(p-1));</span><br><span class="line">printf(&quot;%d\n&quot;,*(p-2));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcfb1f5830</span><br><span class="line">0x7ffcfb1f5844</span><br><span class="line">32764</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>指针P+n = 指针P + sizeof（指针的类型）<em> n<br>sizeof(a)=20 a的类型是int(</em>)[5]</p><p>如果改为<code>int *p=(int *)(&amp;a[0]+1);</code>结果就完全不同了</p><p><a href="https://blog.csdn.net/qq_23996069/article/details/89309016" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/m0_37605407/article/details/79198118" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 地址 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2019/10/08/docker/"/>
      <url>/2019/10/08/docker/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎， 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br><a id="more"></a><br><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">参考</a><br><a href="https://blog.csdn.net/talkxin/article/details/83061973" target="_blank" rel="noopener">参考</a><br><a href="https://www.cnblogs.com/me115/p/5539047.html" target="_blank" rel="noopener">参考</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h1><p><strong>运行容器</strong><br>docker run -d -P training/webapp python app.py<br>-d 后台运行<br>-P 自动映射端口<br>-p 指定端口 #-p 5000:5000<br><strong>查看容器</strong><br>docker ps<br><strong>停止容器</strong><br>docker stop id/name<br><strong>重启容器</strong><br>docker start id/name</p><p><strong>附着容器</strong><br>附着到正在运行的容器<br>docker attach <id、container_name><br>进入正在运行的容器内部，同时运行bash(比attach更好用)<br>docker exec -t -i <id container_name>  /bin/bash</id></id、container_name></p><h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><p>$ docker images  #列出本地镜像<br>$ docker pull ubuntu:13.10 #获取新镜像</p><h1 id="docker-gpu环境"><a href="#docker-gpu环境" class="headerlink" title="docker gpu环境"></a>docker gpu环境</h1><p><a href="https://www.jianshu.com/p/401a37387ecb" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 在 pycharm（社区版）上安装运行</title>
      <link href="/2019/09/26/django1/"/>
      <url>/2019/09/26/django1/</url>
      
        <content type="html"><![CDATA[<p>django可以基于python后端开发web<br><a id="more"></a></p><h1 id="环境及版本"><a href="#环境及版本" class="headerlink" title="环境及版本"></a>环境及版本</h1><p>ubuntu 16<br>python<br>pycharm（community）<br>pip 安装，需要先安装python，下载tar.gz文件，解压，python setup.py install</p><h1 id="Django安装"><a href="#Django安装" class="headerlink" title="Django安装"></a>Django安装</h1><p>pip install django<br>输入 django-admin 验证是否安装成功</p><p>在pycharm中创建django工程<br>1.创建项目<br>django-admin startproject Demo  （Demo为项目名称）<br>使用pycharm open生成的项目工程目录如下：<br><img src="//blog.zhengmingz.top/2019/09/26/django1/1.png" alt="1"><br>2.创建应用<br>点击pycharm左下角，选择terminal<br><img src="//blog.zhengmingz.top/2019/09/26/django1/3.png" alt="3"><br>在Terminal中输入：<br>python manage.py startapp web （web为应用名称）<br>项目目录如下：<br><img src="//blog.zhengmingz.top/2019/09/26/django1/2.png" alt="2"><br>3.启动服务<br>在terminal中输入<br>python manage.py runserver<br>在服务启动后，在浏览其中输入127.0.0.1:8000<br><img src="//blog.zhengmingz.top/2019/09/26/django1/4.png" alt="4"><br>可以看到服务启动成功。<br>4.允许其他电脑访问该服务<br>在settings.py中将<br>ALLOWED_HOSTS = []  改为 ALLOWED_HOSTS = [‘*’,]，注意不要漏掉“,”<br>在Terminal中输入：<br>python manage.py runserver 0.0.0.0:9000<br>支持ipv6：  python manage.py runserver [::]:9000<br>在其他机器可以使用本机器的ip和port访问<br>如:<code>192.168.2.5:9000</code><br> <code>[ipv6]:9000</code></p><p>5.问题<br>（1）Django app接口url报错Forbidden (CSRF cookie not set.)<br>这是因为Django对表单post请求做的安全性验证，在app开发中，可以干掉这一项，具体操作如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改settings.py文件，注释掉</span><br><span class="line">django.middleware.csrf.CsrfViewMiddleware&apos;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = [ </span><br><span class="line">&apos;django.middleware.security.SecurityMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, </span><br><span class="line">&apos;django.middleware.common.CommonMiddleware&apos;, </span><br><span class="line"># &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.auth.middleware.SessionAuthenticationMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.messages.middleware.MessageMiddleware&apos;, </span><br><span class="line">&apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>(2) 跨域问题<br>pip install django-cors-headers</p><p>配置settings.py文件<br>添加<br>设置可跨域范围<br>CORS_ALLOW_CREDENTIALS = True<br>CORS_ORIGIN_ALLOW_ALL = True<br><img src="//blog.zhengmingz.top/2019/09/26/django1/5.png" alt="5"><br>定义跨域中间件<br>‘corsheaders.middleware.CorsMiddleware’,<br><img src="//blog.zhengmingz.top/2019/09/26/django1/6.png" alt="6"></p><h1 id="django-性能优化，提高并发数量"><a href="#django-性能优化，提高并发数量" class="headerlink" title="django 性能优化，提高并发数量"></a>django 性能优化，提高并发数量</h1><p>nginx+uwsgi+django<br><a href="https://www.jianshu.com/p/4db9581353a1" target="_blank" rel="noopener">参考1</a> (未验证可行性)<br><a href="https://blog.csdn.net/u013378306/article/details/76215982" target="_blank" rel="noopener">参考2</a> (未验证可行性)<br><a href="https://www.cnblogs.com/1204guo/p/8056641.html" target="_blank" rel="noopener">参考3</a> (未验证可行性)</p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取某目录下的全部文件和目录</title>
      <link href="/2019/09/26/Read-FileAndDirectory/"/>
      <url>/2019/09/26/Read-FileAndDirectory/</url>
      
        <content type="html"><![CDATA[<p>Python和linux shell中读取某目录下的文件和目录<br><a id="more"></a></p><h1 id="一、python"><a href="#一、python" class="headerlink" title="一、python"></a>一、python</h1><h2 id="1-获取某目录下的全部文件"><a href="#1-获取某目录下的全部文件" class="headerlink" title="1.获取某目录下的全部文件"></a>1.获取某目录下的全部文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isfile(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h2 id="2-获取某目录下的全部目录"><a href="#2-获取某目录下的全部目录" class="headerlink" title="2.获取某目录下的全部目录"></a>2.获取某目录下的全部目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if not os.path.isfile(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isdir(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure></p><h2 id="3-walk一次拿到全部分开的文件和目录"><a href="#3-walk一次拿到全部分开的文件和目录" class="headerlink" title="3.walk一次拿到全部分开的文件和目录"></a>3.walk一次拿到全部分开的文件和目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def file_name(file_dir):</span><br><span class="line">    root= os.walk(file_dir,topdown=True)</span><br><span class="line">    print(root.__next__())</span><br><span class="line">file_name(&apos;/home/user/program&apos;)</span><br></pre></td></tr></table></figure><p> 输出：<br> <code>(&#39;/home/zzm/program&#39;, [&#39;sketch_rnn&#39;, &#39;semantic_image_inpainting-master&#39;, &#39;timage&#39;, &#39;.ipynb_checkpoints&#39;, &#39;Gan_Mnist&#39;, &#39;GlobalLocalImageCompletion_TF-master&#39;, &#39;11Class_1_new_64&#39;, &#39;.git&#39;, &#39;11Class_3_new_64&#39;], [&#39;aa.c&#39;, &#39;test.py&#39;, &#39;aa&#39;, &#39;Untitled.ipynb&#39;, &#39;linerRegression.py&#39;, &#39;DealImage.py&#39;])</code></p><h2 id="4-递归获取所有子目录下的文件和目录"><a href="#4-递归获取所有子目录下的文件和目录" class="headerlink" title="4.递归获取所有子目录下的文件和目录"></a>4.递归获取所有子目录下的文件和目录</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def file_name(file_dir):</span><br><span class="line">    for root,dirs,files in os.walk(file_dir,topdown=True):</span><br><span class="line">        print(&apos;root_dir:&apos;,root)</span><br><span class="line">        print(&apos;sub_dirs:&apos;,dirs)</span><br><span class="line">        print(&apos;files&apos;,files)</span><br><span class="line"></span><br><span class="line">file_name(&apos;/home/user/program&apos;)</span><br></pre></td></tr></table></figure><h2 id="5-获取某一类型的文件，并获取没有后缀的文件名"><a href="#5-获取某一类型的文件，并获取没有后缀的文件名" class="headerlink" title="5.获取某一类型的文件，并获取没有后缀的文件名"></a>5.获取某一类型的文件，并获取没有后缀的文件名</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">roots=os.listdir(&apos;/home/zzm/program&apos;)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isfile(&apos;/home/zzm/program/&apos;+file) and os.path.splitext(file)[1]==&apos;.py&apos; :</span><br><span class="line">        print(os.path.splitext(file)[0])</span><br></pre></td></tr></table></figure><h1 id="二、linux-bash"><a href="#二、linux-bash" class="headerlink" title="二、linux bash"></a>二、linux bash</h1><h2 id="1-获取某目录下全部子目录"><a href="#1-获取某目录下全部子目录" class="headerlink" title="1.获取某目录下全部子目录"></a>1.获取某目录下全部子目录</h2><p>ls -F | grep ‘/$’<br>注：ls -F 显示的目录以/结尾,再用grep筛选出来,-F参数使得ls命令可以在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符。而文件后面的星号(“*”)字符表示这是一个可执行程序</p><p>ls -l | grep ‘^d’<br>注：ls -l 显示的目录以d开头</p><p>ls -ld */</p><p>ls -ap | grep ‘/‘<br>注：ls -p可以给目录加上一个’/’，过滤一下就能只显示目录了,-a显示隐藏文件。</p><h2 id="2-获取某目录下全部文件"><a href="#2-获取某目录下全部文件" class="headerlink" title="2.获取某目录下全部文件"></a>2.获取某目录下全部文件</h2><p>ls -F | grep -v ‘/$’<br>注：grep -v 找相反的，也就是不以/结尾的文件</p><p>ls  -F | grep -v ‘/$’ | grep ‘.py$’<br>注：找出文件，且以.py结尾的。</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> file </tag>
            
            <tag> directory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法</title>
      <link href="/2019/09/26/Algorithm-PartOptim/"/>
      <url>/2019/09/26/Algorithm-PartOptim/</url>
      
        <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><ol><li>粒子群优化算法是一种基于种群寻优的启发式搜索算法。在1995年由Kennedy 和Eberhart 首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我们经常可以观察到鸟群表现出来的同步性，虽然每只鸟的运动行为都是互相独立的，但是在整个鸟群的飞行过程中却表现出了高度一致性的复杂行为，并且可以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每只鸟在飞行过程中都遵循了一定的行为规则，并能够掌握邻域内其它鸟的飞行信息。<a id="more"></a><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1></li><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所经过的位置进行评价，并根据这些信息和位置速度更新规则，改变自身的两个状态量，在“飞行”过程中传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题的近似最优解。<h1 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h1>连续解空间的优化问题求解<br>数值优化问题<br>问题描述<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1>粒子群优化算法求解函数f(x)=x^3-5x^2-2x+3在[-2,5]的最大值</li></ol><p>java源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class Pos &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Pos pos=new Pos();</span><br><span class="line">        pos.Initialize();</span><br><span class="line">        pos.Search();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;PosNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&lt;PosNum*2/7)</span><br><span class="line">                p_pos[i]=(random.nextDouble()-1)*2;</span><br><span class="line">            else</span><br><span class="line">                p_pos[i]=random.nextDouble()*5;</span><br><span class="line">                p_v[i]=p_best[i]=p_pos[i];</span><br><span class="line">            if(function(g_best)&lt;function(p_best[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                g_best=p_best[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Search()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;step;j++)  //迭代</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;PosNum;i++)  //更新</span><br><span class="line">            &#123;</span><br><span class="line">                p_v[i]=w*p_v[i]+c1*random.nextDouble()*(p_best[i]-p_pos[i])+c2*random.nextDouble()*(g_best-p_pos[i]);</span><br><span class="line">                if(-2&lt;(p_pos[i]+p_v[i])&amp;&amp;(p_pos[i]+p_v[i])&lt;5)</span><br><span class="line">                    p_pos[i]+=p_v[i];</span><br><span class="line">                if(function(p_best[i])&lt;function(p_pos[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    p_best[i]=p_pos[i];</span><br><span class="line">                &#125;</span><br><span class="line">                if(function(g_best)&lt;function(p_best[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_best=p_best[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(p_pos[i]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(g_best+&quot; &quot;+function(g_best));</span><br><span class="line">    &#125;</span><br><span class="line">    public double function(double x)</span><br><span class="line">    &#123;</span><br><span class="line">        double y=x*x*x-5*x*x-2*x+3;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final int step=10000; //迭代次数</span><br><span class="line">    private final int PosNum=70; //粒子数</span><br><span class="line">    private final double w=0.9;//惯性权重</span><br><span class="line">    private final double c1=2;//局部权重参数</span><br><span class="line">    private final double c2=2;//全局权重参数</span><br><span class="line">    </span><br><span class="line">    private double g_best; //全局最优解</span><br><span class="line">    private double p_best[]=new double[PosNum];;//粒子本身历史最优解</span><br><span class="line">    private double[] p_v=new double[PosNum];;//粒子速度</span><br><span class="line">    private double[] p_pos=new double[PosNum];//粒子位置</span><br><span class="line">    </span><br><span class="line">    private Random random=new Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 粒子群 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg转png格式</title>
      <link href="/2019/09/26/svg2png/"/>
      <url>/2019/09/26/svg2png/</url>
      
        <content type="html"><![CDATA[<p>矢量图svg转化为png格式<br><a id="more"></a></p><h1 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h1><h2 id="1-安装cairosvg"><a href="#1-安装cairosvg" class="headerlink" title="1.安装cairosvg"></a>1.安装cairosvg</h2><p>直接安装会出错，需要安装依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-lxml</span><br><span class="line">sudo apt install python3-dev</span><br><span class="line">sudo apt install libffi-dev</span><br><span class="line">sudo apt install libcairo2</span><br></pre></td></tr></table></figure></p><p><code>pip3 install cairosvg</code></p><h2 id="2-运行"><a href="#2-运行" class="headerlink" title="2.运行"></a>2.运行</h2><p>在command-line：<br><code>$ cairosvg image.svg -o image.png</code><br>导入 python3 运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import cairosvg</span><br><span class="line">&gt;&gt;&gt; cairosvg.svg2pdf(url=&apos;image.svg&apos;, write_to=&apos;image.pdf&apos;)</span><br></pre></td></tr></table></figure></p><p>批量转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3.5</span><br><span class="line"></span><br><span class="line">import cairosvg</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">filetype=&apos;test&apos;</span><br><span class="line">filepath=&apos;/data/sketch_rnn/svg/arron_sheep/&apos;+filetype+&apos;/&apos;</span><br><span class="line">targepath=&apos;/data/sketch_rnn/png/arron_sheep/&apos;+filetype+&apos;/&apos;</span><br><span class="line">if os.path.exists(targepath):</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    os.makedirs(targepath)</span><br><span class="line">for i in range(1,7400):</span><br><span class="line">    print (i) </span><br><span class="line">    aa=cairosvg.svg2png(WIDTH=64,url=filepath+str(i)+&apos;.svg&apos;,write_to=targepath+str(i)+&apos;.png&apos;,dpi=250)</span><br><span class="line">    print (aa)</span><br></pre></td></tr></table></figure></p><h2 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h2><p>svg转化后的png跟原图一样大，不能改变大小，设置width和height等参数不管用。</p><h1 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h1><h2 id="1-使用ubuntu系统的ImageMagick进行转化。"><a href="#1-使用ubuntu系统的ImageMagick进行转化。" class="headerlink" title="1.使用ubuntu系统的ImageMagick进行转化。"></a>1.使用ubuntu系统的ImageMagick进行转化。</h2><p><code>convert test.svg test.png</code></p><h2 id="2-批量转换图片"><a href="#2-批量转换图片" class="headerlink" title="2.批量转换图片"></a>2.批量转换图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">#源svg所在目录</span><br><span class="line">sourcepath=&quot;tuberling_svg/&quot;  </span><br><span class="line">#保存png目录</span><br><span class="line">targetpath=&quot;tuberling_stroke_png/&quot;</span><br><span class="line">mkdir $targetpath</span><br><span class="line">for dir in $(ls $sourcepath)</span><br><span class="line">do</span><br><span class="line">    echo $dir</span><br><span class="line">    mkdir $targetpath$dir</span><br><span class="line">    for file in $(ls $sourcepath$dir)</span><br><span class="line">    do</span><br><span class="line">        #删除文件名后面的svg，用来获取文件名保存png。</span><br><span class="line">        temp=$&#123;file%.svg&#125;</span><br><span class="line">        convert $sourcepath$dir&quot;/&quot;$temp&quot;.svg&quot; $targetpath$dir&quot;/&quot;$temp&quot;.png&quot; </span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> image </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> svg </tag>
            
            <tag> png </tag>
            
            <tag> image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长子数组</title>
      <link href="/2019/09/17/Algorithm-longestSubarray/"/>
      <url>/2019/09/17/Algorithm-longestSubarray/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，修改其中一个数字，找到最长子数组<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个无序的整型数组，允许将其中一个元素修改为任意整型值（包括原值），使修改后的数组存在尽可能长的连续递增序列。<br>输出修改后数组最长递增序列的长度</p><p><strong>输入描述</strong><br>第一行输入为数组长度；第二行输入为数组元素，以空格隔开。数组中无重复元素，输入元素的取值范围为[-100000,100000]。<br><strong>输出描述</strong><br>修改之后数组内最长连续递增序列的长度<br><strong>示例1</strong><br>输入<br><code>5</code><br><code>3 1 2 5 4</code><br>输出<br><code>4</code><br>说明：将5改为3，或将3改为0<br><strong>示例2</strong><br>输入<br><code>4</code><br><code>3 7 4 8</code><br>输出<br><code>3</code><br>说明：将7改为小于4的值</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>先找到所有递增子数组，<br>将所有的子数组与相邻子数组进行修改一位合并，如果不能合并则+1，可以合并则+另一个数组长度。<br>找到合并后的最长子数组。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#判断两个子数组能否合并</span><br><span class="line">def check(nums,seq1,seq2):</span><br><span class="line">    if (seq1[1]-seq1[0]+1)==1:</span><br><span class="line">        return seq2[1]-seq2[0]+1+1</span><br><span class="line">    if (seq2[1]-seq2[0]+1)==1:</span><br><span class="line">        return seq1[1]-seq1[0]+1+1</span><br><span class="line">    if (nums[seq2[0]+1]&gt;nums[seq1[1]]+2) or (nums[seq2[0]]&gt;nums[seq1[1]-1]+2):</span><br><span class="line">        return seq2[1]-seq2[0]+1+seq1[1]-seq1[0]+1</span><br><span class="line">    len1=seq1[1]-seq1[0]+1</span><br><span class="line">    len2=seq2[1]-seq2[0]+1</span><br><span class="line">    if len1&gt;len2:</span><br><span class="line">        return len1+1</span><br><span class="line">    else:</span><br><span class="line">        return len2+1</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    count=int(input())</span><br><span class="line">    nums=[int(a) for a in input().split(&apos; &apos;)]</span><br><span class="line">    seqs=[]</span><br><span class="line">    index=0</span><br><span class="line">    #先将原数组划分为递增的多个子数组</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        i=i+1</span><br><span class="line">        if i==len(nums):</span><br><span class="line">            seqs.append([index,i-1])</span><br><span class="line">            break</span><br><span class="line">        if nums[i-1]&gt;=nums[i]:</span><br><span class="line">            seqs.append([index,i-1])</span><br><span class="line">            index=i</span><br><span class="line">    #将相邻的子数组合并，找到最长的子数组</span><br><span class="line">    max=seqs[0][1]+seqs[0][0]+1</span><br><span class="line">    for i in range(len(seqs)):</span><br><span class="line">        if i==len(seqs)-1:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            result=check(nums,seqs[i],seqs[i+1])</span><br><span class="line">            if result&gt;max:</span><br><span class="line">                max=result</span><br><span class="line">    print(max)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改bug</title>
      <link href="/2019/09/17/Algorithm-bugNum/"/>
      <url>/2019/09/17/Algorithm-bugNum/</url>
      
        <content type="html"><![CDATA[<p>p某看见Q头上的bug太多了<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//blog.zhengmingz.top/2019/09/17/Algorithm-bugNum/title.png" alt="title"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以看做，n个数的数组，中每次消除连续个相同的数，使每次消除个数的平方和最大。首先找到个数最多的数字，然后按照数字最多的位置将原数组划分成多个子数组，可以递归求每个子数组的最大bug数。数组中可能会出现个数相同的多个数字，需要对每个数字分别计算，找到不同划分的最大值。</p><h1 id="python源码"><a href="#python源码" class="headerlink" title="python源码"></a>python源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#递归最大bug数</span><br><span class="line">def maxbug(balls):</span><br><span class="line">    if len(balls)==1:</span><br><span class="line">        return  1</span><br><span class="line">    max_index=select(balls);</span><br><span class="line">    max_sum=0</span><br><span class="line">    for mi in max_index:</span><br><span class="line">        sum= mi[1]*mi[1]</span><br><span class="line">        index=0</span><br><span class="line">        for i,m in enumerate(balls):</span><br><span class="line">            if m==int(mi[0]):</span><br><span class="line">                if i-index&gt;=1:</span><br><span class="line">                    #print(&apos;index&apos;, index, i - 1,mi,balls[index:i])</span><br><span class="line">                    sum+=maxbug(balls[index:i])</span><br><span class="line">                index=i+1</span><br><span class="line">            if i==len(balls)-1:</span><br><span class="line">                if i-index&gt;=0:</span><br><span class="line">                   # print(&apos;index&apos;, index, i ,mi,balls[index:i])</span><br><span class="line">                    sum+=maxbug(balls[index:i+1])</span><br><span class="line">        if sum&gt;max_sum:</span><br><span class="line">            max_sum=sum</span><br><span class="line">        #print(&apos;sum&apos;,sum)</span><br><span class="line">    return max_sum</span><br><span class="line">#每次选出数组中个数最大的一个或者多个数</span><br><span class="line">def select(balls):</span><br><span class="line">    temp=&#123;&#125;</span><br><span class="line">    for ball in balls:</span><br><span class="line">        if str(ball) in temp.keys():</span><br><span class="line">            temp[str(ball)]+=1</span><br><span class="line">        else:</span><br><span class="line">            temp[str(ball)]=1</span><br><span class="line">    temp = sorted(temp.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line">    #print(temp)</span><br><span class="line">    result=[]</span><br><span class="line">    max=temp[0][1]</span><br><span class="line">    #print(&apos;max:&apos;,max)</span><br><span class="line">    for i in temp:</span><br><span class="line">        if i[1]==max:</span><br><span class="line">            result.append(i)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">balls=[2,1,6,10,8,8,6,3,2,1]</span><br><span class="line">balls=[8,6,2,6,6,3,2,3,2,2]</span><br><span class="line">print(maxbug(balls))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu双系统</title>
      <link href="/2019/09/16/install-ubuntu/"/>
      <url>/2019/09/16/install-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>在已经安装windows的基础上，安装ubuntu16，使用硬盘安装的方式，不用u盘。<br><a id="more"></a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>下载安装easybcd，创建启动条目<br>title Install Ubuntu<br>root (hd0,0)<br>kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8<br>initrd (hd0,0)/initrd.lz</li><li>将vmlinuz.efi   initrd.lz   系统iso复制到 对应的分区目录下</li></ul><h1 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h1><ul><li>进入临时系统，执行下面命令，可以防止安装过程卡死（ubuntu硬盘安装一直正在探测文件系统）<br>sudo umount -l /isodevice/    </li><li>分区<br>/ 根分区 主分区 ext4<br>/home 用户分区 ext4  尽可能大<br>/swap 交换分区，和内存一样大<br>注：boot选择在对应的根分区，不用新建分区</li><li>在easybcd中添加ubuntu启动项，选择grub2</li></ul><h1 id="卸载一些没用的软件"><a href="#卸载一些没用的软件" class="headerlink" title="卸载一些没用的软件"></a>卸载一些没用的软件</h1><ul><li>卸载libreoffices<br>sudo apt-get remove libreoffice-common</li><li>删除Amazon广告图标<br>sudo rm -f /usr/share/applications/com.canonical.launcher.amazon.desktop<br>sudo rm -f /usr/share/applications/ubuntu-amazon-default.desktop</li><li>删除多余的软件<br>sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install transmission-common</li></ul><h1 id="安装过程遇到的问题"><a href="#安装过程遇到的问题" class="headerlink" title="安装过程遇到的问题"></a>安装过程遇到的问题</h1><h2 id="在联想p318上安装的时候，卡死。failed-to-create-kernel-channel-22"><a href="#在联想p318上安装的时候，卡死。failed-to-create-kernel-channel-22" class="headerlink" title="在联想p318上安装的时候，卡死。failed to create kernel channel, -22"></a>在联想p318上安装的时候，卡死。failed to create kernel channel, -22</h2><p>在安装界面，按‘e’，进入编辑，在<code>quiet splash</code>后添加<br><code>quiet splash nouveau.modeset=0</code><br>装完后系统特别卡，键盘鼠标都不能用。也可以用使用上面方法临时解决。<br>终极解决，需要安装NVIDIA显卡驱动。</p><h2 id="ubuntu安装NVIDIA显卡驱动"><a href="#ubuntu安装NVIDIA显卡驱动" class="headerlink" title="ubuntu安装NVIDIA显卡驱动"></a>ubuntu安装NVIDIA显卡驱动</h2><p>查看GPU型号<br><code>lspci | grep -i nvidia</code></p><h3 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h3><ol><li>去英伟达<a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">官网</a>下载驱动程序</li><li>禁用nouveau第三方驱动<br>打开编辑配置文件： <code>sudo gedit /etc/modprobe.d/blacklist.conf</code><br>在最后一行添加：<code>blacklist nouveau</code><br>改好后执行命令：<code>sudo update-initramfs -u</code><br>重启使之生效：<code>reboot</code></li><li>安装驱动<br>重启后按Ctrl+Alt+F1 进入命令行界面<br>执行命令：<code>lsmod | grep nouveau</code><br>禁用X服务：<code>sudo /etc/init.d/lightdm stop</code> (或者：sudo service lightdm stop)<br>给驱动run文件赋予可执行权限：<code>sudo chmod a+x NVIDIA-Linux-x86_64-390.25.run</code>    (下载的驱动文件名）<br>安装：<code>sudo ./NVIDIA-Linux-x86_64-390.25.run -no-opengl-files</code><pre><code> –no-opengl-files 只安装驱动文件，不安装OpenGL文件。这个参数最重要 –no-x-check 安装驱动时不检查X服务 –no-nouveau-check 安装驱动时不检查nouveau  后面两个参数可不加。</code></pre>开启X服务：<code>sudo /etc/init.d/lightdm start</code> (或者：sudo service lightdm start)<br>重启，没有问题，输入命令：<code>nvidia-smi</code><br>如果出现了驱动版本就表示安装成功了。</li></ol><p><a href="https://blog.csdn.net/u014797226/article/details/79626693" target="_blank" rel="noopener">参考</a></p><h3 id="禁用Nouveau-开源驱动"><a href="#禁用Nouveau-开源驱动" class="headerlink" title="禁用Nouveau 开源驱动"></a>禁用Nouveau 开源驱动</h3><p>首先添加一个blacklist:<br><code># vi /etc/modprobe.d/blacklist-nouveau.conf</code><br>写入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></p><p>为了保证完全禁用掉，还要在内核中直接禁用Nouveau:<br><code># echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</code><br>这之后，更新配置试生效：<br><code># update-initramfs -u</code><br>重启</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><h2 id="解决linux终端路径过长的问题"><a href="#解决linux终端路径过长的问题" class="headerlink" title="解决linux终端路径过长的问题"></a>解决linux终端路径过长的问题</h2><p>vim ~/.bashrc<br>找到61行左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &apos;</span><br></pre></td></tr></table></figure></p><p>\u 表示当前用户名<br>\h 表示当前主机名（hostname）<br>\w 表示当前路径<br>把\w改为\W（小写的w改为大写），不显示全路径，只显示basename（当前文件夹名）<br>用户名和主机名也没有什么用</p><h2 id="ubuntu-开机自动挂载硬盘"><a href="#ubuntu-开机自动挂载硬盘" class="headerlink" title="ubuntu 开机自动挂载硬盘"></a>ubuntu 开机自动挂载硬盘</h2><p><a href="https://www.cnblogs.com/tanrong/p/10225229.html" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/fieldtianye/p/9295986.html" target="_blank" rel="noopener">参考二</a></p><h3 id="挂载-home到新硬盘"><a href="#挂载-home到新硬盘" class="headerlink" title="挂载/home到新硬盘"></a>挂载/home到新硬盘</h3><p>识别硬盘<br><code>sudo fdisk -l</code><br>格式化硬盘<br><code>sudo mkfs.ext4 /dev/sdb1</code><br>挂载新硬盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/tmp</span><br><span class="line">sudo mount /dev/sdb1 /mnt/tmp</span><br></pre></td></tr></table></figure></p><p>同步home所有的文件到/mnt/tmp<br><code>sudo rsync -avx /home /mnt/tmp</code><br>备份旧home，创建新home<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /home /home_bak</span><br><span class="line">sudo mkdir /home</span><br></pre></td></tr></table></figure></p><p>查看新硬盘的UUID<br><code>sudo blkid</code><br>编辑/etc/fstab文件，末尾添加<br><code>UUID=175ab25f-5190-4df7-8795-8a00a0f78fd6 /home           ext4    defaults      0       2</code><br>保存<br><code>sudo mount -a</code><br>不保存就可以了（但是/home中的东西并没有复制成功，还的从/home_bak复制）<br><a href="https://blog.csdn.net/weixin_43167547/article/details/106457983" target="_blank" rel="noopener">参考</a></p><h2 id="创建sudo新用户"><a href="#创建sudo新用户" class="headerlink" title="创建sudo新用户"></a>创建sudo新用户</h2><p>加入用户<br><code>sudo adduser zzm</code><br>查看用户组<br><code>groups</code><br>加入sudo组<br><code>sudo usermod -aG sudo zzm</code><br>删除用户<br>sudo deluser, sudo deluser —remove-home<br><a href="https://blog.csdn.net/wowocpp/article/details/100115112" target="_blank" rel="noopener">参考</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-安装ssh"><a href="#1-安装ssh" class="headerlink" title="1.安装ssh"></a>1.安装ssh</h2><p>安装ssh<br>打开”终端窗口”，输入”sudo apt-get install openssh-server”—&gt;回车—&gt;输入”y”—&gt;回车—&gt;安装完成。</p><p>查看ssh服务是否启动<br>打开”终端窗口”，输入”sudo ps -e | grep ssh”—&gt;回车—&gt;有sshd,说明ssh服务已经启动，如果没有启动，输入”sudo service ssh start”—&gt;回车—&gt;ssh服务就会启动。</p><p>使用gedit修改配置文件”/etc/ssh/sshd_config”<br>打 开”终端窗口”，输入”sudo gedit /etc/ssh/sshd_config”—&gt;回车—&gt;把配置文件中的”PermitRootLogin without-password”加一个”#”号,把它注释掉—&gt;再增加一句”PermitRootLogin yes”—&gt;保存，修改成功。（否则远程密码不管用）</p><h2 id="2-安装java环境"><a href="#2-安装java环境" class="headerlink" title="2.安装java环境"></a>2.安装java环境</h2><p>卸载openJDK<br>卸载：sudo apt-get remove openjdk*<br>环境设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bashrc 或  /etc/profile</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_05 </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>执行： source ~/.bashrc</p><h2 id="3-安装FileZilla"><a href="#3-安装FileZilla" class="headerlink" title="3.安装FileZilla"></a>3.安装FileZilla</h2><p>可以远程连接其他的linux，方便传送文件<br>可以直接在 Ubuntu Software 中下载安装。</p><h2 id="4-MySQL-Workbenck"><a href="#4-MySQL-Workbenck" class="headerlink" title="4.MySQL Workbenck"></a>4.MySQL Workbenck</h2><p>mysql远程连接，可视化<br>sudo apt-get install mysql-workbench<br><a href="https://blog.csdn.net/Jgirl_333/article/details/48575281" target="_blank" rel="noopener">参考</a></p><h2 id="5-安装LaTex"><a href="#5-安装LaTex" class="headerlink" title="5.安装LaTex"></a>5.安装LaTex</h2><p>用于生成pdf文档<br><a href="https://blog.csdn.net/qq_41814939/article/details/82288145" target="_blank" rel="noopener">参考</a></p><h2 id="6-安装搜狗输入法"><a href="#6-安装搜狗输入法" class="headerlink" title="6.安装搜狗输入法"></a>6.安装搜狗输入法</h2><p><a href="https://blog.csdn.net/areigninhell/article/details/79696751" target="_blank" rel="noopener">参考</a></p><h2 id="7-安装chrome"><a href="#7-安装chrome" class="headerlink" title="7.安装chrome"></a>7.安装chrome</h2><p><a href="https://jingyan.baidu.com/article/335530da98061b19cb41c31d.html" target="_blank" rel="noopener">参考</a></p><h2 id="8-安装Foxit-pdf阅读器"><a href="#8-安装Foxit-pdf阅读器" class="headerlink" title="8.安装Foxit pdf阅读器"></a>8.安装Foxit pdf阅读器</h2><p><a href="https://blog.csdn.net/u011722133/article/details/79242695/" target="_blank" rel="noopener">参考</a></p><h2 id="9-安装QQ"><a href="#9-安装QQ" class="headerlink" title="9.安装QQ"></a>9.安装QQ</h2><p><a href="https://im.qq.com/linuxqq/download.html" target="_blank" rel="noopener">下载地址</a></p><h2 id="10-ubuntu-浏览器不支持html5-视频播放"><a href="#10-ubuntu-浏览器不支持html5-视频播放" class="headerlink" title="10.ubuntu 浏览器不支持html5 视频播放"></a>10.ubuntu 浏览器不支持html5 视频播放</h2><p>sudo apt-get install ubuntu-restricted-extras</p><h2 id="11-ubuntu-打开usb摄像头（uvc）"><a href="#11-ubuntu-打开usb摄像头（uvc）" class="headerlink" title="11.ubuntu 打开usb摄像头（uvc）"></a>11.ubuntu 打开usb摄像头（uvc）</h2><p>sudo apt install cheese<br><code>$ cheese</code> 即可使用</p><h2 id="12-安装Trash-CLI-防止rm误删"><a href="#12-安装Trash-CLI-防止rm误删" class="headerlink" title="12.安装Trash CLI 防止rm误删"></a>12.安装Trash CLI 防止rm误删</h2><p>sudo apt-get install trash-cli<br><a href="https://www.linuxidc.com/Linux/2018-11/155406.htm" target="_blank" rel="noopener">参考</a> </p><h2 id="13-安装图片工具gimp-和-pinta"><a href="#13-安装图片工具gimp-和-pinta" class="headerlink" title="13.安装图片工具gimp 和 pinta"></a>13.安装图片工具gimp 和 pinta</h2><p>sudo apt-get install gimp<br>sudo apt-get install pinta</p><h2 id="14-安装视频剪辑工具kdenlive"><a href="#14-安装视频剪辑工具kdenlive" class="headerlink" title="14.安装视频剪辑工具kdenlive"></a>14.安装视频剪辑工具kdenlive</h2><p>通过ubuntu 自带的软件下载</p><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><h2 id="1-ubuntu查看内存情况"><a href="#1-ubuntu查看内存情况" class="headerlink" title="1.ubuntu查看内存情况"></a>1.ubuntu查看内存情况</h2><p>1.查看内存的插槽数，已经使用多少插槽。每条内存多大，已使用内存多大<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -P -A5 &quot;Memory\s+Device&quot;|grep Size|grep -v Range</span><br></pre></td></tr></table></figure></p><p>2.查看内存支持的最大内存容量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -P &apos;Maximum\s+Capacity&apos;</span><br></pre></td></tr></table></figure></p><p>3.查看内存的频率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -A16 &quot;Memory Device&quot;</span><br><span class="line">sudo dmidecode|grep -A16 &quot;Memory Device&quot;|grep &apos;Speed&apos;</span><br></pre></td></tr></table></figure></p><h2 id="2-查看cpu情况"><a href="#2-查看cpu情况" class="headerlink" title="2.查看cpu情况"></a>2.查看cpu情况</h2><p><a href="https://blog.csdn.net/u013066730/article/details/82783083" target="_blank" rel="noopener">参考</a></p><h2 id="3-查看显卡情况"><a href="#3-查看显卡情况" class="headerlink" title="3.查看显卡情况"></a>3.查看显卡情况</h2><p>nvidia-smi<br>如果特别慢，<a href="https://blog.csdn.net/minione_2016/article/details/81088414" target="_blank" rel="noopener">执行</a><br><code>sudo nvidia-persistenced --persistence-mode</code><br><code>lspci -vnn | grep VGA -A 12</code></p><h2 id="4-查看内存条信息"><a href="#4-查看内存条信息" class="headerlink" title="4.查看内存条信息"></a>4.查看内存条信息</h2><p><code>sudo dmidecode --type memory</code></p><h2 id="5-查看硬盘信息"><a href="#5-查看硬盘信息" class="headerlink" title="5.查看硬盘信息"></a>5.查看硬盘信息</h2><p>硬盘数量、大小：<code>sudo fdisk -l |grep &quot;Disk /dev/sd&quot;</code><br>硬盘型号：<code>sudo hdparm -i /dev/sda |grep &quot;Model&quot;</code><br><a href="https://www.cnblogs.com/ranxf/p/6903200.html" target="_blank" rel="noopener">参考</a></p><h2 id="6-查看主板"><a href="#6-查看主板" class="headerlink" title="6.查看主板"></a>6.查看主板</h2><p>主板型号,主板支持最大内存,单条内存的参数<br>sudo dmidecode -t 2 //查看主板信息<br>sudo dmidecode -t 16 |grep Maximum //查看主板支持最大内存<br>sudo dmidecode -t memory //查看单条内存的参数<br><a href="https://blog.csdn.net/djd1234567/article/details/48372911" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 双系统 </tag>
            
            <tag> NVIDIA显卡驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分割数组的最大值</title>
      <link href="/2019/09/12/splitArray/"/>
      <url>/2019/09/12/splitArray/</url>
      
        <content type="html"><![CDATA[<p>分割数组的最大值，将一个数组分割成n个连续的子数组，使每个子数组的最大值最小。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在m个节点的分布式计算系统中，有一批任务需要执行，每个任务需要的时间式array[i]，每个节点同一时间只能执行一个任务，每个节点只能执行连续的任务，例如i，i+1，i+2，但是不能执行i，i+2。请问任务完成的最短时间<br><strong>输入</strong><br><code>输入数据包含两行</code><br><code>第一行，空格分割的两个整数m和n，分布表示节点个数和任务个数(m&gt;0,n&gt;=0)</code><br><code>第二行，空格分割的正整数序列，表示每个任务需要的时间</code><br><strong>输出</strong><br><code>一个整数，表示最短完成时间</code><br><strong>样例输入</strong><br><code>3 5</code><br><code>1 5 3 4 2</code><br><strong>样例输入</strong><br><code>6</code><br><strong>提示</strong><br><code>第一个节点执行：任务1和任务2，耗时=1+5=6</code><br><code>第二个节点执行：任务3，耗时=3</code><br><code>第三个节点执行：任务4和任务5，耗时=2+4=6</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将一个数组分割成n个连续的子数组，使每个子数组的最大值最小。（同leecode 410）</p><h2 id="解法一、-二分法"><a href="#解法一、-二分法" class="headerlink" title="解法一、  二分法"></a>解法一、  二分法</h2><p>1.给出一个完成任务的时间x，然后将任务分成每个子节点任务时间&lt;=x，如果完成任务需要的节点数&lt;=给出的节点数，那么满足条件。用来判断是否满足条件的过程可以用暴力方法求解。<br>2.给出时间x可以从完成任务的平均时间开始不断+1，找到第一个满足条件的x，就是完成任务最短时间。或者使用二分法 sum/m&lt;=x&lt;=sum，不断二分计算中间值，可以减少时间复杂度。<br><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class test3 &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int nodeNum=sc.nextInt();</span><br><span class="line">        int taskNum=sc.nextInt();</span><br><span class="line">        int time[] = new int[taskNum];</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;taskNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        time[i]=sc.nextInt();</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(splitArray(time,nodeNum));</span><br><span class="line">    &#125;</span><br><span class="line">//二分法划分，每次给出一个时长x，判断是否满足条件</span><br><span class="line">public static int splitArray(int[] nums, int m) &#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">int low=sum/m;</span><br><span class="line">int high=sum;</span><br><span class="line">int result=low;</span><br><span class="line">while(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(low+high)/2;</span><br><span class="line">if(isFit(nums,mid,m))</span><br><span class="line">&#123;</span><br><span class="line">if(isFit(nums,low,m)) &#123;</span><br><span class="line">result=low;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">low+=1;</span><br><span class="line">high=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        if(result&lt;nums[i])</span><br><span class="line">        result=nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//暴力求解当前时长是否满足条件</span><br><span class="line">private static Boolean isFit(int time[],int maxsumtime,int nodeNum)</span><br><span class="line">&#123;</span><br><span class="line">int count=0,sum=0;</span><br><span class="line">for(int i=0;i&lt;time.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=time[i];</span><br><span class="line">if(i+1&lt;time.length-1)</span><br><span class="line">&#123;</span><br><span class="line">if(sum&lt;=maxsumtime&amp;&amp;(sum+time[i+1])&gt;maxsumtime)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">sum=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if(sum&lt;=maxsumtime&amp;&amp;(sum+time[i+1])&gt;maxsumtime)</span><br><span class="line">&#123;</span><br><span class="line">count=count+2;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">count+=1;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;count:&quot;+count);</span><br><span class="line">System.out.println(&quot; maxsumtime:&quot;+maxsumtime);</span><br><span class="line">if(count&gt;nodeNum)</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br>第一行是使用二分的结果，第二行是顺序查找的结果<br><img src="//blog.zhengmingz.top/2019/09/12/splitArray/result1.png" alt="result1"></p><h2 id="解法二、-动态规划"><a href="#解法二、-动态规划" class="headerlink" title="解法二、  动态规划"></a>解法二、  动态规划</h2><p>这是一类最大最小问题。<br>简单说就是将数组划分为多组，每组会求一个和，多组的和最大值的可能性很多，求多组和的最小值的可能性。<br>状态定义：f[i][j]表示nums[0] ~ nums[j]共j+1个元素划分为i组的和的最大最小值。<br>可初始化的状态：f[1][j]表示nums[0]~nums[j]划分为1组的分组和的最大最小值，显然f[1][j] = sum(0, j)，包含边界。<br>状态迁移方程：f[i][j] = min(max(f[i-1][k], sum(k+1, j))), 0&lt;= k &lt; j<br>这种问题的状态迁移方程很具有代表性，即在右边划一段出来，先把问题规模-1，然后剩下的只需要再切分为i-1组即可。<br>其中k是这缩小问题规模的切分点。</p><p><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class dp &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int nodeNum=sc.nextInt();</span><br><span class="line">        int taskNum=sc.nextInt();</span><br><span class="line">        int time[] = new int[taskNum];</span><br><span class="line">        for(int i=0;i&lt;taskNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        time[i]=sc.nextInt();</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(dp(time,nodeNum));</span><br><span class="line">    &#125;</span><br><span class="line">public static int dp(int time[],int nodeNum)</span><br><span class="line">&#123;</span><br><span class="line">int f[][]=new int[nodeNum+1][time.length] ;</span><br><span class="line">int presum[]=new int[time.length];</span><br><span class="line">for(int i=2;i&lt;nodeNum+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;time.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=2147483647;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[1][0]=time[0];</span><br><span class="line">presum[0]=time[0];</span><br><span class="line">for(int i=1;i&lt;time.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">presum[i]=presum[i-1]+time[i];</span><br><span class="line">f[1][i]=presum[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=2;i&lt;nodeNum+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i-1;j&lt;time.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;j;k++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=Math.min(f[i][j], Math.max(f[i-1][k], presum[j]-presum[k]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[nodeNum][time.length-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><img src="//blog.zhengmingz.top/2019/09/12/splitArray/result2.png" alt="result2"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wpf加载gif</title>
      <link href="/2019/09/09/wpfgif/"/>
      <url>/2019/09/09/wpfgif/</url>
      
        <content type="html"><![CDATA[<p>wpf加载gif显示问题<br><a id="more"></a><br>wpf 程序需要动态显示gif图片，试过MediaElement、Image  以及winform 的 pictureBox，要不图片显示不出来，要不显示出来不动，亲测以下方法可用。</p><ol><li>打开vs 工具-&gt;库程序包管理工具-&gt;程序包管理器控制台</li><li>PM&gt;Install-Package WpfAnimatedGif </li><li>要使用这个包需要加入新的命名空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;Meeting.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:gif=&quot;http://wpfanimatedgif.codeplex.com&quot; </span><br><span class="line">        Icon=&quot;/images/icon.ico&quot;</span><br><span class="line">        Title=&quot; MainWindows&quot;  Height=&quot;610&quot; Width=&quot;900&quot;  &gt;</span><br><span class="line">      &lt;Grid&gt;</span><br><span class="line">          &lt;Image gif:ImageBehavior.AnimatedSource=&quot;Images/animated.gif&quot; /&gt;</span><br><span class="line">      &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wpf </tag>
            
            <tag> gif </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux+vim+zsh 配置</title>
      <link href="/2019/09/09/ZshTmuxVim/"/>
      <url>/2019/09/09/ZshTmuxVim/</url>
      
        <content type="html"><![CDATA[<p>tmux、vim、zsh等shell工具的配置与使用<br><a id="more"></a></p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p><a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1" target="_blank" rel="noopener">官方手册</a><br><a href="https://pragprog.com/book/bhtmux2/tmux-2" target="_blank" rel="noopener">电子数</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install tmux</code><br><strong>Session 命令</strong><br>启动新会话： tmux new -s 会话名  -n  窗口名<br>恢复会话： tmux a  -t  会话名<br>列出所有会话：tmux  ls<br>关闭会话：tmux  kill-session  -t  会话名<br>关闭所有会话：<br>tmux ls | grep : | cut -d. -f1 | awk ‘{print substr($1, 0, length($1)-1)}’ | xargs kill<br>脱离会话： Ctrl+b，d<br>重新附加会话：  tmux  attach-session<br>列出会话：tmux list-sessions<br>重命名会话：tmux  rename -t  oldname  newname<br>Ctrl+b，：  可以不用退出，直接在下方输入命令（如： new -s  会话名）<br>Ctrl+b，s    可以显示所有的session，并切换<br><strong>Window 命令</strong><br>Ctrl+b，c  新建窗口<br>Ctrl+b，p 移动到上一个窗口<br>Ctrl+b，n  移动到下一个窗口<br>Ctrl+b, w  通过窗口列表切换窗口<br>退出所有panel，window也关闭<br><strong>Panel 命令</strong><br>Ctrl+b，箭头    选择操作不同的窗格<br>Ctrl+b，”     水平分割窗格，形成上下两个panel<br>Ctrl+b，%    垂直分割窗格，形成左右两个panel<br>Ctrl+b+箭头   Ctrl+b不放，可以一直按箭头调整窗格的大小，1<br>Ctrl+b，Alt+箭头   调整窗格大小，5<br>Ctrl+b，Page Up和Page Down  可以上下翻看历史记录<br>Ctrl+b，q  显示窗格对应的数字<br>Ctrl+d     exit     logout  退出当前窗格<br><strong>tmux打开shell自启动</strong><br>打开<code>.bashrc</code>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $TERM != &quot;screen-256color&quot; ] &amp;&amp; [  $TERM != &quot;screen&quot; ]; then</span><br><span class="line">    tmux attach || tmux new; exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>新建session错误</strong><br>报错sessions should be nested with care, unset $TMUX to force<br>按错误提示执行命令：<br>需要使用命令 unset TMUX<br>再次执行 ：问题解决</p><p>vim报错：_arguments:450: _vim_files: function definition file not found<br>直接删除~/.zcompdump文件，但是不知道会不会影响其他插件的功能。</p><p><strong>远程安装tmux，scp传输出错</strong><br><strong>xshell 使用rzsz出差</strong><br>open terminal failed: not a terminal<br>需要关闭tmux才可以</p><p><a href="https://www.cnblogs.com/lizhang4/p/7325086.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/williamyuyuyu/article/details/79283374" target="_blank" rel="noopener">参考2</a></p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim鼠标右键不能复制、粘贴"><a href="#vim鼠标右键不能复制、粘贴" class="headerlink" title="vim鼠标右键不能复制、粘贴"></a>vim鼠标右键不能复制、粘贴</h3><ol><li>在普通模式下键入:set mouse-=a</li><li>在.vimrc 中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if has(&apos;mouse&apos;)</span><br><span class="line">   set mouse-=a </span><br><span class="line">endif</span><br></pre></td></tr></table></figure></li></ol><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p><strong>安装</strong><br><code>sudo apt-get install zsh</code><br><strong>安装 oh My Zsh</strong><br><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code><br><strong>修改zsh为默认的shell：</strong><br><code>chsh -s /bin/zsh  #该命令会修改 /etc/passwd 文件中对应的用户名</code><br><strong>修改主题</strong><br>打开~/.zshrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 找到如下这一行，将引号中的部分修改为`ys`即可</span><br><span class="line">ZSH_THEME=&quot;ys&quot;</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/qixizhuang/article/details/82958198" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/smallrivers/article/details/78701804" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> zsh </tag>
            
            <tag> tmux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sketch paper</title>
      <link href="/2019/09/08/sketchpaper/"/>
      <url>/2019/09/08/sketchpaper/</url>
      
        <content type="html"><![CDATA[<p>skech相关的paper<br><a id="more"></a></p><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><h2 id="CVPR"><a href="#CVPR" class="headerlink" title="CVPR"></a>CVPR</h2><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><h2 id="sigraph："><a href="#sigraph：" class="headerlink" title="sigraph："></a>sigraph：</h2><ul><li><a href="https://arxiv.org/abs/1804.08972" target="_blank" rel="noopener">FaceShop: Deep Sketch-based Face Image Editing</a>，Tiziano Portenier Qiyang Hu, Attila Szabo, Siavash Bigdeli, Paolo Favaro, Matthias Zwicker(University of Bern)</li><li><a href="https://esslab.jp/~ess/en/research/inking/" target="_blank" rel="noopener">Real-Time Data-Driven Interactive Rough Sketch Inking</a>，Edgar Simo-Serra, Satoshi Iizuka, Hiroshi Ishikawa (Waseda University)</li><li><a href="https://esslab.jp/~ess/en/research/sketch_master/" target="_blank" rel="noopener">Mastering Sketching: Adversarial Augmentation for Structured Prediction</a>， Edgar Simo-Serra<em>, Satoshi Iizuka</em>, Hiroshi Ishikawa (Waseda University) (*equal contribution)</li><li><a href="https://www.cs.ubc.ca/labs/imager/tr/2018/StrokeAggregator/" target="_blank" rel="noopener">StrokeAggregator: Consolidating Raw Sketches into Artist-Intended Curve Drawings</a>， Chenxi Liu, Enrique Rosales, Alla Sheffer (The University of British Columbia)</li></ul><h2 id="CVPR："><a href="#CVPR：" class="headerlink" title="CVPR："></a>CVPR：</h2><ul><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Hu_Sketch-a-Classifier_Sketch-Based_Photo_CVPR_2018_paper.pdf" target="_blank" rel="noopener">Sketch-a-Classifier: Sketch-Based Photo Classifier Generation</a>，Conghui Hu, Da Li, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales</li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Chen_SketchyGAN_Towards_Diverse_CVPR_2018_paper.pdf" target="_blank" rel="noopener">SketchyGAN: Towards Diverse and Realistic Sketch to Image Synthesis</a>，Wengling Chen, James Hays</li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Song_Learning_to_Sketch_CVPR_2018_paper.pdf" target="_blank" rel="noopener">Learning to Sketch With Shortcut Cycle Consistency</a>，Jifei Song, Kaiyue Pang, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales</li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Shen_Zero-Shot_Sketch-Image_Hashing_CVPR_2018_paper.pdf" target="_blank" rel="noopener">Zero-Shot Sketch-Image Hashing，Yuming Shen</a>, Li Liu, Fumin Shen, Ling Shao</li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Muhammad_Learning_Deep_Sketch_CVPR_2018_paper.pdf" target="_blank" rel="noopener">Learning Deep Sketch Abstraction</a>，Umar Riaz Muhammad, Yongxin Yang, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales</li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Xu_SketchMate_Deep_Hashing_CVPR_2018_paper.pdf" target="_blank" rel="noopener">SketchMate: Deep Hashing for Million-Scale Human Sketch Retrieval</a>，Peng Xu, Yongye Huang, Tongtong Yuan, Kaiyue Pang, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales, Zhanyu Ma, Jun Guo</li></ul><h2 id="ECCV"><a href="#ECCV" class="headerlink" title="ECCV:"></a>ECCV:</h2><ul><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Jiaxin_Chen_Deep_Cross-modality_Adaptation_ECCV_2018_paper.pdf" target="_blank" rel="noopener">Deep Cross-modality Adaptation via Semantics Preserving Adversarial Learning for Sketch-based 3D Shape Retrieval</a>, Jiaxin Chen, Yi Fang</li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Yongyi_Lu_Image_Generation_from_ECCV_2018_paper.pdf" target="_blank" rel="noopener">Image Generation from Sketch Constraint Using Contextual GAN</a>，Yongyi Lu, Shangzhe Wu, Yu-Wing Tai, Chi-Keung Tang</li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Jingyi_Zhang_Generative_Domain-Migration_Hashing_ECCV_2018_paper.pdf" target="_blank" rel="noopener">Generative Domain-Migration Hashing for Sketch-to-Image Retrieval</a>，Jingyi Zhang, Fumin Shen, Li Liu, Fan Zhu, Mengyang Yu, Ling Shao, Heng Tao Shen, Luc Van Gool</li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Ke_LI_Universal_Sketch_Perceptual_ECCV_2018_paper.pdf" target="_blank" rel="noopener">Universal Sketch Perceptual Grouping</a>，Ke Li, Kaiyue Pang, Jifei Song, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales, Honggang Zhang</li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Kaiyue_Pang_Deep_Factorised_Inverse-Sketching_ECCV_2018_paper.pdf" target="_blank" rel="noopener">Deep Factorised Inverse-Sketching，Kaiyue Pang</a>, Da Li, Jifei Song, Yi-Zhe Song, Tao Xiang, Timothy M. Hospedales</li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Changqing_Zou_SketchyScene_Richly-Annotated_Scene_ECCV_2018_paper.pdf" target="_blank" rel="noopener">SketchyScene: Richly-Annotated Scene Sketches</a>，Changqing Zou, Qian Yu, Ruofei Du, Haoran Mo, Yi-Zhe Song, Tao Xiang, Chengying Gao, Baoquan Chen, Hao Zhang  </li><li><a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Sasikiran_Yelamarthi_A_Zero-Shot_Framework_ECCV_2018_paper.pdf" target="_blank" rel="noopener">A_ Zero-Shot Framework for Sketch based Image Retrieval</a>，Sasi Kiran Yelamarthi, Shiva Krishna Reddy, Ashish Mishra, Anurag Mittal</li></ul>]]></content>
      
      
      <categories>
          
          <category> research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sketch </tag>
            
            <tag> paper </tag>
            
            <tag> cvpr </tag>
            
            <tag> sigraph </tag>
            
            <tag> eccv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda</title>
      <link href="/2019/09/08/conda/"/>
      <url>/2019/09/08/conda/</url>
      
        <content type="html"><![CDATA[<p>conda的安装与配置<br><a id="more"></a></p><h1 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h1><p> <strong>下载</strong><br> <code>wget https://repo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh</code><br> <strong>安装</strong><br> <code>bash Miniconda2-latest-Linux-x86_64.sh -b -p /home/user/miniconda2</code><br> <code>mv Miniconda2-latest-Linux-x86_64.sh download</code><br><strong>配置环境</strong><br>在<code>.bashrc</code>中添加<br><code>export PATH=/home/user/miniconda2/bin:$PATH</code><br><code>source .bashrc</code></p><h1 id="conda-环境"><a href="#conda-环境" class="headerlink" title="conda 环境"></a>conda 环境</h1><p><strong>创建环境</strong><br><code>conda create -n py36 python=3.7</code><br><strong>删除环境</strong><br><code>conda remove -n py36 --all</code><br><strong>激活环境</strong><br><code>source activate py36</code><br><strong>退出环境</strong><br><code>source deactivate</code></p><h1 id="conda安装python包"><a href="#conda安装python包" class="headerlink" title="conda安装python包"></a>conda安装python包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda install  tensorflow=1.8.0 #安装包</span><br><span class="line">conda list         #查看已经安装的包</span><br><span class="line">conda update xxx   #更新xxx包</span><br><span class="line">conda uninstall xxx   #卸载xxx包</span><br></pre></td></tr></table></figure><p><strong>清理</strong><br><code>conda clean -p      //删除没有用的包</code><br><code>conda clean -t      //tar打包</code></p><h1 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h1><p>进入conda环境中启动jupyter<br><strong>通过直接启动无法显示</strong><br>可以添加conda kernel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3 # 创建一个python3的环境，名为py3</span><br><span class="line">source activate py3 # 激活py3环境</span><br><span class="line">conda install ipykernel # 安装ipykernel模块</span><br><span class="line">python -m ipykernel install --user --name py3 --display-name &quot;py3&quot; # 进行配置</span><br></pre></td></tr></table></figure></p><p><strong>问题</strong> jupyter UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe5 in position 4<br>解决：<br>修改系统语言变量为英文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/locale   #用 vim 来修改环境的语言配置，</span><br><span class="line"></span><br><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;en_US:en&quot;</span><br></pre></td></tr></table></figure></p><p>修改完成，查看系统语言<br>locale</p><h1 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h1><p><strong>解决CUDA driver version is insufficient for CUDA runtime version</strong><br><code>tensorflow.python.framework.errors_impl.InternalError: cudaGetDevice() failed. Status: CUDA driver version is insufficient for CUDA runtime version</code><br><strong>原因</strong><br>CUDA版本对显卡驱动版本有要求，见如下链接。<br><code>https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</code><br><strong>解决</strong><br>卸载旧版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall cudnn</span><br><span class="line">conda uninstall cudatoolkit</span><br></pre></td></tr></table></figure></p><p>安装新版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install cudatoolkit=9.0</span><br><span class="line">conda install cudnn</span><br></pre></td></tr></table></figure></p><p><a href="http://www.pianshen.com/article/6406282694/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
            <tag> cuda </tag>
            
            <tag> tensorflow </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp服务器搭建</title>
      <link href="/2019/09/03/ftp/"/>
      <url>/2019/09/03/ftp/</url>
      
        <content type="html"><![CDATA[<p>在ubuntu服务器上搭建ftp服务，用于个人使用<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装VSFTPD</strong><br>使用 apt-get 安装 vsftpd：<br><code>sudo apt-get install vsftpd -y</code><br><strong>启动 VSFTPD</strong><br>安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经[监听了 21 端口]：<br><code>sudo netstat -nltp | grep 21</code><br>如果没有启动，可以手动开启 VSFTPD 服务：<br><code>sudo systemctl start vsftpd.service</code><br>FTP 协议默认使用 21 端口作为服务端口<br><strong>配置用户访问目录</strong><br>新建用户主目录<br><code>sudo mkdir /home/ftp</code><br><strong>新建用户uftp并设置密码</strong><br>创建一个用户 uftp ：<br><code>sudo useradd -d /home/uftp -s /bin/bash uftp</code><br>为用户 uftp 设置密码：<br><code>sudo passwd uftp</code><br>删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：<br><code>sudo rm /etc/pam.d/vsftpd</code><br><strong>限制该用户只能通过ftp访问，不可以直接登录服务器</strong><br>sudo usermod -s /sbin/nologin uftp<br><strong>修改vsftpd配置</strong><br>修改 <code>/etc/vsftpd.conf</code> 文件中的配置（直接将如下配置添加到配置文件最下方）：<br>限制用户对主目录以外目录访问<br><code>chroot_local_user=YES</code><br>指定一个 userlist 存放允许访问 ftp 的用户列表<br><code>userlist_deny=NO</code><br><code>userlist_enable=YES</code><br>记录允许访问 ftp 用户列表<br><code>userlist_file=/etc/vsftpd.user_list</code><br>不配置可能导致莫名的530问题<br><code>seccomp_sandbox=NO</code><br>允许文件上传<br><code>write_enable=YES</code><br>使用utf8编码<br><code>utf8_filesystem=YES</code><br>新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：<br><code>sudo touch /etc/vsftpd.user_list</code><br><code>sudo chmod a+w /etc/vsftpd.user_list</code><br>修改 <code>/etc/vsftpd.user_list</code> ，加入刚刚创建的用户：<br><code>uftp</code><br><strong>设置访问权限</strong><br>设置主目录访问权限（只读）：<br><code>sudo chmod a-w /home/ftp</code><br>新建公共目录，并设置权限（读写）：<br><code>sudo mkdir /home/ftp/public &amp;&amp; sudo chmod 777 -R/home/ftp/public</code><br>重启vsftpd 服务：<br><code>sudo systemctl restart vsftpd.service</code></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>1.购买域名<br>2.设置域名解析，直接将域名绑定到ftp服务器的ip上。</p><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p><strong>1.ftp连接错误</strong><code>500 OOPS: vsftpd</code><br><strong>解决</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br><span class="line"># 添加一行配置 allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure></p><p><a href="https://www.php.cn/linux-363729.html" target="_blank" rel="noopener">参考</a></p><h2 id="ftp命令"><a href="#ftp命令" class="headerlink" title="ftp命令"></a>ftp命令</h2><p><strong>命令行连接ftp</strong><br><code>ftp ip</code><br>输入用户名，密码<br>或者 <code>ftp&gt;open ip</code><br><strong>下载文件</strong><br><code>ftp&gt;get filename</code><br><strong>上传文件</strong><br><code>ftp&gt;put filename</code><br><strong>查看目录</strong><br><code>ftp&gt;ls</code><br><strong>查看本地目录</strong><br><code>ftp&gt;!ls</code></p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
            <tag> ubuntu </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo创建个人博客</title>
      <link href="/2019/08/27/Hexo/"/>
      <url>/2019/08/27/Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo安装、配置，在github上部署，yelee主题配置<br><a id="more"></a></p><h1 id="安装nodejs和npm"><a href="#安装nodejs和npm" class="headerlink" title="安装nodejs和npm"></a>安装nodejs和npm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>创建文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Hexo  </span><br><span class="line">cd Hexo</span><br></pre></td></tr></table></figure></p><p>安装Hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p><p>初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>此步骤会在hexo文件夹下生成默认的网站模板文件。</p><p>清除之前生成的静态模板文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>生成新的静态模板文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate（hexo g）</span><br></pre></td></tr></table></figure></p><p>启动hexo的本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server（hexo s）</span><br></pre></td></tr></table></figure></p><h1 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h1><p>1.新建一个仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github名.github.io</span><br></pre></td></tr></table></figure></p><p>(名称必须与github名一致)<br>在该仓库Settings下GitHub Pageszhong设置Custom domain为自己的域名（和hexo中CNAME设置一样）<br>在source目录下创建文件CNAME<br>写入自己的域名</p><p>2.修改_config.yml文件<br>deploy:<br>type: git<br>repository: <a href="https://github.com/githubID/仓库名.github.io.git" target="_blank" rel="noopener">https://github.com/githubID/仓库名.github.io.git</a><br>branch: master</p><p>3.部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy（hexo d）</span><br></pre></td></tr></table></figure></p><h1 id="安装-Hexo-Admin插件"><a href="#安装-Hexo-Admin插件" class="headerlink" title="安装 Hexo Admin插件"></a>安装 Hexo Admin插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure><p>打开本地管理界面<br><a href="http://localhost:4000/admin" target="_blank" rel="noopener">http://localhost:4000/admin</a></p><h1 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h1><p>1.创建文章<br>hexo根目录命令行输入<code>hexo new &lt;模板&gt; &lt;文章名&gt;</code>新建文章  </p><p><table>  <tr><td>参数</td><td>功能</td><td>路径</td></tr>  <tr><td>post</td><td>新建文章</td><td>/source/_posts/</td></tr>  <tr><td>draft</td><td>新建草稿</td><td>/source/_drafts/</td></tr>  <tr><td>page</td><td>新建页面（标签、分类等）</td><td>/source/</td></tr></table><br>通常情况下使用<code>hexo new post name</code><br>会在<code>source/_posts</code>下生成一个<code>name.md</code>的文件。  </p><h1 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h1><p>配置<code>_config_yml</code>里面的post_asset_folder:false这个选项设置为true。<br>安装<code>hexo-asset-image</code>，运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。<br>问题直接运行<code>npm install hexo-asset-image save</code>安装的插件有问题，图片不能正确显示，生成的html中图片路径不对（显示 /.top//name.png），使用如下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><p>插入图片，在md中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![xxx](blogName/imageName.png)</span><br></pre></td></tr></table></figure></p><p>需要配置_config.yml中的url，本地配置为localhost，远程配置为对应的域名<br><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">参考</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="安装hexo错误：（nodejs版本太低，不能用apt直接升级）"><a href="#安装hexo错误：（nodejs版本太低，不能用apt直接升级）" class="headerlink" title="安装hexo错误：（nodejs版本太低，不能用apt直接升级）"></a>安装hexo错误：（nodejs版本太低，不能用apt直接升级）</h2><p><strong>解决</strong><br>1.产看node版本，没安装的请先安装；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  node -v</span><br></pre></td></tr></table></figure></p><p>2.清楚node缓存；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm cache clean -f</span><br></pre></td></tr></table></figure></p><p>3.安装node版本管理工具’n’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm install n -g</span><br></pre></td></tr></table></figure></p><p>4.使用版本管理工具安装指定node或者升级到最新node版本；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo n stable  （安装node最新版本）</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/legendjslc/articles/10131412.html" target="_blank" rel="noopener">参考</a></p><h2 id="hexo-d-ERROR-Deployer-not-found-git"><a href="#hexo-d-ERROR-Deployer-not-found-git" class="headerlink" title="hexo d(ERROR Deployer not found: git)"></a>hexo d(ERROR Deployer not found: git)</h2><p><strong>解决</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></p><h2 id="hexo输入数学公式不显示"><a href="#hexo输入数学公式不显示" class="headerlink" title="hexo输入数学公式不显示"></a>hexo输入数学公式不显示</h2><ol><li><p>在开始部分插入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; async</span><br><span class="line">  src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在网页中插入所需数学公式的特定格式(或者见yelee):<br>（插入1后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\\(&apos;,&apos;\\)&apos;]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">参考</a></p><h2 id="有序列表显示问题“-A空格”"><a href="#有序列表显示问题“-A空格”" class="headerlink" title="有序列表显示问题“- A空格”"></a>有序列表显示问题<code>“- A空格”</code></h2><ul><li>A boy</li><li>A- boy<br>如上显示正常显示，前面应该有一个圆点，第一行A空格前面没有圆点。暂时解决只能在A后直接加字符</li></ul><h1 id="yelee"><a href="#yelee" class="headerlink" title="yelee"></a>yelee</h1><p>1.在 themes下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></p><p>2.修改_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: yelee</span><br></pre></td></tr></table></figure></p><p>3.支持数学公式<br>修改 <code>themes/yelee/_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p>4.不喜欢yelee的标题风格<br>修改 themes/yelee/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heading_stytle:2  //改为github风格</span><br></pre></td></tr></table></figure></p><p>5.社交图标设置<br>themes/yelee/source/css/_partial/customise/social-icon.styl</p><p><strong>参考</strong><br><a href="http://moxfive.coding.me/yelee/2.Basic-Usage/post-excerpt.html" target="_blank" rel="noopener">yelee配置中文说明</a><br><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee github</a><br><a href="https://www.imooc.com/article/44667" target="_blank" rel="noopener">博客搭建</a></p>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2019/08/26/knapsack-problem/"/>
      <url>/2019/08/26/knapsack-problem/</url>
      
        <content type="html"><![CDATA[<p>背包问题(Knapsack problem)是一种组合优化的NP完全问题<br><a id="more"></a></p><h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p><strong>问题描述</strong><br>假设有N个物品，其中第i个物品的重量为W<sub>i</sub>。 现在需要将这些物品分成两堆，使得在“第一堆物品的总重量与第二堆物品的总重量之差尽可能小”的前提下，第一堆物品的数量与第二堆物品的数量之差尽可能大。那么，两堆物品总重量之差最小是多少？在总重量之差最小的前提下，两堆物品的数量之差最大是多少？</p><p><strong>输入</strong><br>第一行包含一个整数N，2<script type="math/tex">\leq</script>N<script type="math/tex">\leq</script>100。<br>第二行包含N个空格隔开的整数W<sub>1</sub>到W<sub>N</sub>，1<script type="math/tex">\leq</script>W<sub>i</sub><script type="math/tex">\leq</script>100。</p><p><strong>输出</strong><br>输出两个空格隔开的整数，第一个整数表示两堆物品的总重量之差的最小值，第二个整数表示在总重量之差最小的提前下，两堆物品的数量之差的最大值。</p><p><strong>样例输入</strong>  </p><table><tr><td>6</td></tr><tr><td>1 2 3 4 5 6</td></tr></table><p><strong>样例输出</strong></p><table><tr><td>1 2</td></tr></table><p><strong>解析</strong><br>思路：<br>重量之差最小：可以理解为可以放N个物品重量一半的背包问题，在背包中放入的物体总量最大。<br>数量之差最大：若总重量为偶数，两个背包一样大。若总总量为奇数，一个背包比另外一个背包大1。在总重量小（或相等）的一个背包中放入数量尽可能少的物品，在另一个背包中放入数据尽可能多的物品。<br>以样例为例，背包重量空间为10，如果当前背包的重量小于放入前一个物品的（当前背包重量-当前物品重量）所对应的重量+当前物品重量则放入，表格中写入放入后背包的重量。（第一行表示背包重量剩余空间，表格中表示当前背包的重量和放入的数量）。记录放入背包的物品数，如果放入则+1。如果放入与不放重量一样，则判断放入数量+1与不放数量更小的表示新的记录。<br>按行更新，使不同背包空间放入尽可能重量多数量少的物品</p><table>  <tr><td>物品\背包空间</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  <tr><td>1</td><td>1  1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td bgcolor="“#8A2BE2”">1 1</td><td>0 0</td></tr>  <tr><td>2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td bgcolor="“#8A2BE2”">3 2</td><td>2 1</td><td>1 1</td><td bgcolor="#FF7F50">0 0 </td></tr>  <tr><td>3</td><td>6 3</td><td>6 3</td><td>6 3</td><td>6 3</td><td bgcolor="“#8A2BE2”">6 3</td><td>5 2</td><td>4 2</td><td>3 1</td><td>2 1</td><td bgcolor="#FF7F50">1 1</td><td> 0 0</td></tr>  <tr><td>4</td><td bgcolor="“#8A2BE2”">10 4</td><td>9 3</td><td>8 3</td><td>7 2</td><td>6 2</td><td bgcolor="#FF7F50">5 2</td><td>4 1</td><td>3 1</td><td>2 1</td><td>1 1</td><td bgcolor="#00FF00">0 0 </td></tr>  <tr><td>5</td><td bgcolor="#FF7F50">10 3</td><td>9 2</td><td>8 2</td><td>7 2</td><td>6 2</td><td>5 1</td><td bgcolor="#00FF00">4 1</td><td>3 1</td><td>2 1</td><td>1 1 </td><td>0 0</td></tr>  <tr><td>6</td><td bgcolor="#00FF00">10 2</td><td>9 2</td><td>8 2</td><td>7 2</td><td>6 1</td><td>5 1</td><td>4 1</td><td>3 1</td><td>2 1</td><td>1 1</td><td>0 0</td></tr></table><p><strong>源码</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class bag2 &#123;</span><br><span class="line">//动态规划 背包问题</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int num=sc.nextInt();</span><br><span class="line">        int weight[] = new int[num];</span><br><span class="line">        int sum=0,m=0;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        weight[i]=sc.nextInt();</span><br><span class="line">        sum+=weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m=sum;</span><br><span class="line">        sum/=2;</span><br><span class="line">        int dp[]=new int[sum+1];</span><br><span class="line">        int count[]=new int[sum+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=sum;j&gt;=weight[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j]&lt;(dp[j-weight[i]]+weight[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        dp[j]=dp[j-weight[i]]+weight[i];</span><br><span class="line">        count[j]=count[j-weight[i]]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[j]==(dp[j-weight[i]]+weight[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(count[j]&gt;count[j-weight[i]]+1)</span><br><span class="line">        &#123;</span><br><span class="line">        count[j]=count[j-weight[i]]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(dp[j]+<span class="string">" "</span>+count[j]+<span class="string">"   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((m-2*dp[sum])+<span class="string">" "</span>);//输出重量最小差</span><br><span class="line"></span><br><span class="line">        System.out.print(num-2*count[sum]);//输出数量最大差</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>另一种思路</strong><br>先考虑重量最小，然后可以得知，两个背包分别放入总量。可以转化为N个整数，选出M个整数的和为固定值，找出所有可能的组合。（速度太慢了，不能通过测试）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class bag1 &#123;</span><br><span class="line">//动态规划 背包问题</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int num=sc.nextInt();</span><br><span class="line">        int weight[] = new int[num];</span><br><span class="line">        int sum=0,m=0;</span><br><span class="line">        int dp[]=new int[10000];</span><br><span class="line">        for(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        weight[i]=sc.nextInt();</span><br><span class="line">        sum+=weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m=sum;</span><br><span class="line">        sum/=2;</span><br><span class="line">        for(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        for(int j=sum;j&gt;=weight[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">        dp[j]=(dp[j]&gt;(dp[j-weight[i]]+weight[i]))?dp[j]:(dp[j-weight[i]]+weight[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((m-2*dp[sum])+&quot; &quot;);//输出重量最小差</span><br><span class="line">        int A=m-2*dp[sum];</span><br><span class="line">        int B=m;</span><br><span class="line">        int C=(A+B)/2; //重量更多的物体的和</span><br><span class="line">        int large=binaryCal(weight,C);</span><br><span class="line">        System.out.print(large-(num-large));//输出数量最大差</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public static int binaryCal(int[] a,int m) &#123;</span><br><span class="line">int n = a.length;</span><br><span class="line">        //最大的数为2的n次方</span><br><span class="line">int max = 1 &lt;&lt; n;</span><br><span class="line">int result=0;</span><br><span class="line">for(int i = 1;i &lt; max;i++) &#123;</span><br><span class="line">            //转成二进制数</span><br><span class="line">String binaryNum = Integer.toBinaryString(i);</span><br><span class="line">//转成相同的位数，不足n位的在前补0</span><br><span class="line">            binaryNum = toSameLen(binaryNum,n);</span><br><span class="line">char[] bitNum = binaryNum.toCharArray();</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int j = 0;j &lt; bitNum.length;j++) &#123;</span><br><span class="line">                //二进制数当前位置为1，则加起来</span><br><span class="line">if (bitNum[j] == &apos;1&apos;) &#123;</span><br><span class="line">sum += a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            //和为m了，输出</span><br><span class="line">if (sum == m) &#123;</span><br><span class="line">int tmp=output(bitNum,a);</span><br><span class="line">if(result&lt;tmp)</span><br><span class="line">result=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String toSameLen(String binaryNum, int len) &#123;</span><br><span class="line">//数的长度</span><br><span class="line">        int numLen = binaryNum.length();</span><br><span class="line">if (numLen == len) &#123;</span><br><span class="line">return binaryNum;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">        //差几位补几个0</span><br><span class="line">for(int i = 0;i &lt; len - numLen;i++) &#123;</span><br><span class="line">sb.append(0);</span><br><span class="line">&#125;</span><br><span class="line">return sb.append(binaryNum).toString();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static int output(char[] bitNum, int[] a) &#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i = 0;i &lt; bitNum.length;i++) &#123;</span><br><span class="line">if (bitNum[i] == &apos;1&apos;) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
