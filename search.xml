<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows系统和软件的配置</title>
      <link href="/2023/08/31/System-win/"/>
      <url>/2023/08/31/System-win/</url>
      
        <content type="html"><![CDATA[<p>windows的一些配置，快捷方式<br><a id="more"></a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="删除windows的u盘插拔记录"><a href="#删除windows的u盘插拔记录" class="headerlink" title="删除windows的u盘插拔记录"></a>删除windows的u盘插拔记录</h3><p>为了应对检查，需要将windows系统中的u盘插拔记录删除掉（实际操作中usb记录都删除了，但是移动硬盘的信息还在）</p><ul><li>百度搜索下载PsTools工具包</li><li>将工具包中的PsExec.exe,复制到C:\Windows\System32中  </li><li>打开CMD（用管理员），输入<br><code>PsExec.exe -i -d -s regedit.exe</code></li><li>自动弹出注册表编辑器</li><li><p>将以下目录中的内容删除（只删除内容，不要删除目录）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Enum/USBSTOR</span><br><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Enum/USBSTOR</span><br><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Enum/USBSTOR</span><br></pre></td></tr></table></figure></li><li><p>如果还是不行，继续删除USB子项下如ROOT_HUB / ROOT_HUB20外的所有记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Enum/USB</span><br><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Enum/USB</span><br></pre></td></tr></table></figure></li><li><p>如何还是不满足，继续删除DeviceClasses下的a5d… 和 53f…等usb字眼的部分子项，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Control/DeviceClasses/&#123;a5d...&#125;</span><br><span class="line">HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/DeviceClasses/&#123;53f...&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何仍然不满足，在注册表里用Ctrl+F搜索，根据检查软件里的提示信息，查出一条删除一条。不要删错。  </p></li></ul><p><a href="https://blog.csdn.net/smallseal0/article/details/114878506" target="_blank" rel="noopener">参考</a><br><strong>注意</strong> 修改完注册表后，插入u盘没有反应，需要在设备管理中将所用u盘卸载后再插入。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="word空白页删除"><a href="#word空白页删除" class="headerlink" title="word空白页删除"></a>word空白页删除</h3><ul><li>在Word中，如果一篇文档的最后一页是表格，并且这个表格占满了一整页，就会在其后产生一张空白页。虽然该空白页只含有一个段落标记，但却是没有办法删除的。在打印时，该页照样会使打印机走一页纸，因而会造成不必要的浪费。<br><strong>解决办法</strong>：把光标置于空白页行首位置，格式-段落-行距-固定值“1”磅-确定</li></ul>]]></content>
      
      
      <categories>
          
          <category> System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-interview</title>
      <link href="/2022/08/17/Algorithm-interview/"/>
      <url>/2022/08/17/Algorithm-interview/</url>
      
        <content type="html"><![CDATA[<p>算法面经<br><a id="more"></a></p><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="不变性与等变性"><a href="#不变性与等变性" class="headerlink" title="不变性与等变性"></a>不变性与等变性</h2><ul><li>不变性: invariant f(F(x)) = f(x)　　</li><li>等变性: eq f(g(x)) = g’f(x)　　</li><li>pooling是具有不变性　　</li><li>cnn 是具有等变性　　</li></ul><h2 id="特征工程的常用方法"><a href="#特征工程的常用方法" class="headerlink" title="特征工程的常用方法"></a>特征工程的常用方法</h2><ul><li>对时间戳处理</li><li>对离散型变量进行独热编码</li><li>对连续型变量进行分箱/分区</li><li>特征缩放</li><li>特征选择</li><li>特征衍生（特征交叉）<h2 id="LSTM的结构"><a href="#LSTM的结构" class="headerlink" title="LSTM的结构"></a>LSTM的结构</h2>包括遗忘门，输入门和输出门三种。<br>　　<br>GRU与LSTM区别</li><li>LSTM和GRU的性能在很多任务上不分伯仲；</li><li>GRU参数更少，因此更容易收敛，但是在大数据集的情况下，LSTM性能表现更好；</li><li>GRU 只有两个门（update和reset），LSTM 有三个门（forget，input，output），GRU 直接将hidden state 传给下一个单元，而 LSTM 用memory cell 把hidden state 包装起来。</li></ul><h2 id="RNN为什么会出现梯度消失或者梯度爆炸"><a href="#RNN为什么会出现梯度消失或者梯度爆炸" class="headerlink" title="RNN为什么会出现梯度消失或者梯度爆炸"></a>RNN为什么会出现梯度消失或者梯度爆炸</h2><p>在RNN中经常遇到梯度消失和爆炸现象的原因：很难捕捉到长期的依赖关系，因为乘法梯度可以随着层的数量呈指数递减/递增。</p><h2 id="sigmoid和softmax的区别"><a href="#sigmoid和softmax的区别" class="headerlink" title="sigmoid和softmax的区别"></a>sigmoid和softmax的区别</h2><p> Softmax函数是二分类函数Sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。最大的区别在于softmax的计算的是一个比重，而sigmoid只是对每一个输出值进行非线性化。</p><h2 id="训练集、测试集和验证集的作用，训练的时候为什么要进行shuffle"><a href="#训练集、测试集和验证集的作用，训练的时候为什么要进行shuffle" class="headerlink" title="训练集、测试集和验证集的作用，训练的时候为什么要进行shuffle"></a>训练集、测试集和验证集的作用，训练的时候为什么要进行shuffle</h2><p>首先用训练集训练出模型，然后用验证集验证模型（注意：这是一个中间过程，此时最好的模型还未选定），根据情况不断调整模型，选出其中最好的模型（验证误差用于指导我们选择哪个模型），记录最好的模型的各项设置，然后据此再用（训练集+验证集）数据训练出一个新模型，作为最终的模型，最后用测试集评估最终的模型。<br>进行shuffle：打乱数据之间的顺序，让数据随机化，避免过拟合。</p><h2 id="数据不平衡的解决方法"><a href="#数据不平衡的解决方法" class="headerlink" title="数据不平衡的解决方法"></a>数据不平衡的解决方法</h2><p>以二分类举例，数据不平衡是指数据集中正类和负类的比例严重失调，比如正：负为9：1。数据不平衡会导致模型学习偏差，模型会倾向于学习比例高的数据特征，对比例低的数据只学习到很少的特征。</p><ul><li>数据方面:<ul><li>(1)上采样：增加少类样本; </li><li>(2)下采样：抛弃部分大类样本</li></ul></li><li>模型方面：<ul><li>设置惩罚机制：增加少类样本预测错误的惩罚</li></ul></li><li>评价指标<ul><li>使用：精确率和召回率</li></ul></li><li>更换损失函数<ul><li>使用focal_loss<h2 id="各类激活函数"><a href="#各类激活函数" class="headerlink" title="各类激活函数"></a>各类激活函数</h2></li></ul></li></ul><h2 id="BP-算法流程"><a href="#BP-算法流程" class="headerlink" title="BP 算法流程"></a>BP 算法流程</h2><h2 id="CNN-的参数的优化方法"><a href="#CNN-的参数的优化方法" class="headerlink" title="CNN 的参数的优化方法"></a>CNN 的参数的优化方法</h2><h2 id="随机梯度下降、mini-batch、整个训练样本一起进去的区别"><a href="#随机梯度下降、mini-batch、整个训练样本一起进去的区别" class="headerlink" title="随机梯度下降、mini-batch、整个训练样本一起进去的区别"></a>随机梯度下降、mini-batch、整个训练样本一起进去的区别</h2><h2 id="BatchNormalization的核心思想和实现"><a href="#BatchNormalization的核心思想和实现" class="headerlink" title="BatchNormalization的核心思想和实现"></a>BatchNormalization的核心思想和实现</h2><h2 id="Transformer的原理"><a href="#Transformer的原理" class="headerlink" title="Transformer的原理"></a>Transformer的原理</h2><h2 id="传统机器学习算法"><a href="#传统机器学习算法" class="headerlink" title="传统机器学习算法"></a>传统机器学习算法</h2><h2 id="为什么要把Transformer-应用的计算机视觉中"><a href="#为什么要把Transformer-应用的计算机视觉中" class="headerlink" title="为什么要把Transformer 应用的计算机视觉中"></a>为什么要把Transformer 应用的计算机视觉中</h2><ul><li>通用的建模能力</li><li>和卷积形成互补</li><li>更强的建模能力</li><li>对大模型和大数据的可扩展行</li><li>更好的连接视觉和语音　　　　</li></ul><p><a href="https://blog.csdn.net/soaring_casia/article/details/122447674" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deeplearning </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install-cuda</title>
      <link href="/2022/07/06/Install-cuda/"/>
      <url>/2022/07/06/Install-cuda/</url>
      
        <content type="html"><![CDATA[<p>分为两种方式：<br>（1）直接安装显卡驱动<br>（2）安装cuda toolkit顺便安装显卡驱动，或者可以只安装cuda。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="ubuntu安装NVIDIA显卡驱动"><a href="#ubuntu安装NVIDIA显卡驱动" class="headerlink" title="ubuntu安装NVIDIA显卡驱动"></a>ubuntu安装NVIDIA显卡驱动</h3><p>查看GPU型号<br><code>lspci | grep -i nvidia</code><br><strong>注：</strong> Cuda Toolkit（<a href="https://developer.nvidia.cn/downloads" target="_blank" rel="noopener">下载</a>）包含nvidia显卡驱动, 可以直接一起安装。在Ubuntu18上安装Cuda11.1一直没有成功，也没报错，让看<code>/var/log/nvidia-installer.log</code>,里边也没提示什么，就重新下载Nvidia驱动，提示没有make。所以应该先安装<code>gcc</code>和<code>make</code>才能继续的安装，之后就一路顺利的完成了。</p><p><strong>安装驱动</strong></p><ul><li>去英伟达<a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">官网</a>下载驱动程序</li><li>禁用nouveau第三方驱动<br>打开编辑配置文件： <code>sudo gedit /etc/modprobe.d/blacklist.conf</code><br>在最后一行添加：<code>blacklist nouveau</code><br>改好后执行命令：<code>sudo update-initramfs -u</code><br>重启使之生效：<code>reboot</code>  </li><li>安装驱动<br>重启后按Ctrl+Alt+F1 进入命令行界面<br>执行命令：<code>lsmod | grep nouveau</code><br>禁用X服务：<code>sudo /etc/init.d/lightdm stop</code> (或者：sudo service lightdm stop)<br>给驱动run文件赋予可执行权限：<code>sudo chmod a+x NVIDIA-Linux-x86_64-390.25.run</code>    (下载的驱动文件名）<br>安装：<code>sudo ./NVIDIA-Linux-x86_64-390.25.run -no-opengl-files</code>  <pre><code>  –no-opengl-files 只安装驱动文件，不安装OpenGL文件。这个参数最重要    –no-x-check 安装驱动时不检查X服务    –no-nouveau-check 安装驱动时不检查nouveau     后面两个参数可不加。  </code></pre></li><li>开启X服务：<code>sudo /etc/init.d/lightdm start</code> (或者：sudo service lightdm start)  </li><li>重启，没有问题，输入命令：<code>nvidia-smi</code><br>如果出现了驱动版本就表示安装成功了。</li></ul><p><a href="https://blog.csdn.net/u014797226/article/details/79626693" target="_blank" rel="noopener">参考</a></p><p><strong>禁用Nouveau 开源驱动</strong><br>首先添加一个blacklist:<br><code># vi /etc/modprobe.d/blacklist-nouveau.conf</code><br>写入以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></p><p>为了保证完全禁用掉，还要在内核中直接禁用Nouveau:<br><code># echo options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</code><br>这之后，更新配置试生效：<br><code># update-initramfs -u</code><br>重启  </p><p><strong>问题</strong><br>没有关闭系统自动升级，重庆后ubuntu的内核自动升级了，用GPU跑模型的时候，提示cuda不存在，用<code>nvidia-smi</code>查看，提示：<br><code>NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver.  Make sure that the latest NVIDIA driver is installed and running.</code><br>通过如下方法解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dkms</span><br><span class="line">sudo dkms install -m nvidia -v 418.87.00</span><br></pre></td></tr></table></figure></p><p>其中，418.87.00是之前安装nvidia驱动的版本号，可以通过以下命令查到：<br><code>ls /usr/src | grep nvidia</code></p><p>还可以通过降低系统的内核的方法来解决，由于ubuntu18启动时不能进入一个ubuntu高级的地方可以选择内核版本，所以没用这个方法。 </p><h3 id="ubuntu-安装不同版本cuda（可以顺带安装显卡驱动，一次安装更省事）"><a href="#ubuntu-安装不同版本cuda（可以顺带安装显卡驱动，一次安装更省事）" class="headerlink" title="ubuntu 安装不同版本cuda（可以顺带安装显卡驱动，一次安装更省事）"></a>ubuntu 安装不同版本cuda（可以顺带安装显卡驱动，一次安装更省事）</h3><ul><li>在<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">官网</a>选择cuda版本</li><li>选择目标系统平台linux/x86_64/ubuntu/16.04/runfile(local)</li><li>按给出的命令下载cuda .run安装包<br>  <code>wget https://developer.download.nvidia.com/compute/cuda/10.1/Prod/local_installers/cuda_10.1.243_418.87.00_linux.run</code></li><li>赋予执行权限<br>  <code>chmod +x cuda_10.1.243_418.87.00_linux.run</code> </li><li>安装<br>  <code>sudo sh cuda_10.1.243_418.87.00_linux.run</code></li><li>如果系统已安装Nvidia驱动，只需要安装其他版本的cuda，可以只选择toolkit一项；如果没有安装显卡驱动，可以按默认全部选择选项安装。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="多版本cuda切换"><a href="#多版本cuda切换" class="headerlink" title="多版本cuda切换"></a>多版本cuda切换</h3><ul><li>按照安装２中方法，安装需要版本的cuda。  </li><li><p>添加cuda 软链接   </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/local/cuda-10.1</span><br><span class="line">sudo ln -s /usr/local/cuda-11.1 /usr/local/cuda</span><br></pre></td></tr></table></figure></li><li><p>切换，在<code>.bashrc</code>中添加以下配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/cuda/bin</span><br><span class="line">export LD_LIBRARY=$LD_LIBRARY:/usr/local/cuda/lib64</span><br><span class="line">export LIRRARY_PATH=$LIRRARY_PATH:/usr/local/cuda/lib64</span><br><span class="line">export CUDA_HOME=&apos;/usr/local/cuda-11.1&apos;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>source .bashrc</code>，输入<code>nvcc -V</code>，查看cuda版本。  </p></li></ul><h3 id="设置cuda计算模式"><a href="#设置cuda计算模式" class="headerlink" title="设置cuda计算模式"></a>设置cuda计算模式</h3><ul><li>有三种模式：0-default、1-Exclusive、2-Prohibited。设置成２后，其他程序不能占用。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># python中配置cuda计算模式</span><br><span class="line">os.system(&apos;sudo nvidia-smi -i %s -c 0&apos; % os.environ[&apos;CUDA_VISIBLE_DEVICES&apos;])</span><br><span class="line">os.system(&apos;sudo nvidia-smi -i %s -c 2&apos; % os.environ[&apos;CUDA_VISIBLE_DEVICES&apos;])</span><br><span class="line"># shell</span><br><span class="line">sudo nvidia-smi -i &apos;0&apos; -c 0</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> ubuntu </tag>
            
            <tag> NVIDIA显卡驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写文件</title>
      <link href="/2022/03/08/Program-RWFile/"/>
      <url>/2022/03/08/Program-RWFile/</url>
      
        <content type="html"><![CDATA[<p>Python读写文本文件，json文件，pkl文件等<br><a id="more"></a></p><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><ul><li>按行读取<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(path, &apos;r&apos;) as f:</span><br><span class="line">    line = f.readline()            </span><br><span class="line">    while line:               </span><br><span class="line">        line=line.strip()</span><br><span class="line">        print(line)</span><br><span class="line">        line = f.readline()</span><br></pre></td></tr></table></figure></li></ul><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=0</span><br><span class="line">with open(path, &apos;w&apos;) as fp:  #追加模式，ｗ换成ａ</span><br><span class="line">    while i &lt;= 10:</span><br><span class="line">        f.write(&quot;&#123;&#125;\n&quot;.formate(i))</span><br><span class="line">        i+=1</span><br></pre></td></tr></table></figure><h2 id="json文件"><a href="#json文件" class="headerlink" title="json文件"></a>json文件</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。  </p><h3 id="READ"><a href="#READ" class="headerlink" title="READ"></a>READ</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">with open(path, &apos;r&apos;) as fp:</span><br><span class="line">    info=json.load(fp)</span><br></pre></td></tr></table></figure><h3 id="Write-1"><a href="#Write-1" class="headerlink" title="Write"></a>Write</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">with open(path, &apos;w&apos;) as fp:</span><br><span class="line">    json.dump(info, fp)</span><br></pre></td></tr></table></figure><h2 id="pkl文件"><a href="#pkl文件" class="headerlink" title="pkl文件"></a>pkl文件</h2><p>pickle提供了一个简单的持久化功能，可以将对象以文件的形式存放在磁盘上。<br>pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化。<br>pkl文件保存为二进制格式，读写方式与json类似。  </p><h3 id="Read-1"><a href="#Read-1" class="headerlink" title="Read"></a>Read</h3><p>反序列化对象。将文件中的数据解析为一个Python对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">with open(path, &apos;rb&apos;) as fp:</span><br><span class="line">    info=pickle.load(fp)</span><br></pre></td></tr></table></figure></p><h3 id="Write-2"><a href="#Write-2" class="headerlink" title="Write"></a>Write</h3><p>序列化对象，并将结果数据流写入到文件对象中。‘pickle.dump(obj, file[, protocol])’，参数protocol是序列化模式，默认值为0，表示以文本的形式序列化。protocol的值还可以是1或2，表示以二进制的形式序列化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">with open(path, &apos;wb&apos;) as fp:</span><br><span class="line">    pickle.dump(infos, fp)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> json </tag>
            
            <tag> file </tag>
            
            <tag> pickle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除挖矿病毒</title>
      <link href="/2021/12/26/Security-Mine-Virus/"/>
      <url>/2021/12/26/Security-Mine-Virus/</url>
      
        <content type="html"><![CDATA[<p>记录一次挖矿病毒的处理，组里有一个4卡RTX3090的服务器被攻击了，在内网使用，可能的原因是搞了一个frp内网穿透。<br><a id="more"></a></p><h2 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h2><p>服务器有一段时间没用了，<code>nvidia-smi</code>发现有程序在运行，kill之后过一分钟又启动了。分析是被病毒攻击了。为了方便没有开启防火墙，就先把防火墙开了，结果连不上网了，ssh也用不了，由于服务器在机房统一管理，没办法继续弄了，过了几天约了机房管理才去弄的。启动防火墙的时候开启了22端口，而且也ping不通，感觉是病毒弄的，自动关机了？</p><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><ul><li>由于之前dell服务器的idrac没有配置好，不能远程连接。这次弄好了远程管理，连上之后发现并没有关机。  </li><li>这次<code>nvidia-smi</code>命令，显卡中尽然没有程序在运行，应该是上次打开ufw防火墙之后，病毒连不上矿场服务器把挖矿关了，隐藏起来了。</li><li>继续找病毒，<code>top</code>命令，观察了一下发现了一个命名不正常的进程<code>188a39a055</code>。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/1.png" alt="title"></li><li>看一下这个进程的具体情况，<code>ps -ef | grep 32771</code>命令,真的是一个挖矿进程，正在挖ETH，钱包是<code>0xe1c3167bbd1dd3affbc4807808b2cf54f695b2af</code>，而且用的是鱼池。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/2.png" alt="title"></li><li>打开鱼池f2pool看了一下，还挺肥。还有三台在运行。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/8.png" alt="title"></li><li>然后<code>kill -9</code>清理了一下进程，过一分钟又打开了，进程名称还变了。是有一个守护父进程吗？但是父进程是1，应该不是。然后通过<code>crontab -l</code>看了一下没有定时启动的条目。</li><li>通过<code>pwdx pid</code>查看了一下进程的启动位置，是根目录<code>/</code>。</li><li>打开<code>/proc/pid</code>,看一下这个进程的信息，启动目录在<code>/</code>根目录，程序位置是在<code>/usr/bin</code>下，但是被删除了，隐藏的挺深呀。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/3.png" alt="title"></li><li>看一下进程的启动信息<code>systemctl status pid</code>,可以得到两个信息：（1）启动程序是一个定时服务，所以关闭后还是会启动，定时服务在<code>/lib/systemd/system/incircers.service</code>中；（2）启动的病毒程序在<code>/usr/sbin/lorin-sopt</code>。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/4.png" alt="title"></li><li>打开看一下，是一个60秒的定时服务<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/5.png" alt="title"></li><li>看一下启动的程序，11月04日就植入了，隐藏的时间还挺长的，之前登录都没有看到呀。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/6.png" alt="title"></li><li>然后把服务和程序都删除了，等了几分钟果然没有进程再启动了。进入<code>/root</code>目录下，发现<code>.ssh/authotrized_keys</code>建了一个秘钥，应该是便于以后登录留的后门，<code>rm</code>直接删还删不掉，发现还有文件属性的问题，通过<code>chattr</code>命令更改i属性后可以删除。</li></ul><p><a href="https://www.cnblogs.com/hld123/p/13226033.html" target="_blank" rel="noopener">参考</a><br><a href="https://www.jianshu.com/p/71d2f842f341" target="_blank" rel="noopener">参考</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>病毒终于删除掉了，试试重启后有没有问题，然而。。。</li><li>重新开机后一直卡在ubuntu的开机界面几分钟没反应，就强制关机重启了一次，结果再也启动不了了，开机直接进入了grub rescue模式，查看目录发现，根目录下的东西<code>/bin</code>、<code>/boot</code>等都被删除了，完了这下只能重装系统了。折腾了一天还是输了。<br><img src="//blog.zhengmingz.top/2021/12/26/Security-Mine-Virus/7.png" alt="title"></li></ul><p><a href="https://www.cnblogs.com/zx-y/p/10848353.html" target="_blank" rel="noopener">grub rescue参考</a><br><a href="https://blog.csdn.net/ooyyaa6561/article/details/111560636" target="_blank" rel="noopener">idrac远程重装系统参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> security </tag>
            
            <tag> mine virus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2021/12/12/Tool-vim/"/>
      <url>/2021/12/12/Tool-vim/</url>
      
        <content type="html"><![CDATA[<p>vim 配置<br><a id="more"></a></p><p><a href="https://blog.csdn.net/u010871058/article/details/54253774" target="_blank" rel="noopener">参考</a></p><h1 id="my-vimrc"><a href="#my-vimrc" class="headerlink" title="my .vimrc"></a>my .vimrc</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 一般设定</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 设定默认解码</span><br><span class="line">set fenc=utf-8</span><br><span class="line">set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; history文件中需要记录的行数</span><br><span class="line">set history=100</span><br><span class="line"></span><br><span class="line">&quot; 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line">set confirm</span><br><span class="line"></span><br><span class="line">&quot; 与windows共享剪贴板</span><br><span class="line">set clipboard+=unnamed</span><br><span class="line"></span><br><span class="line">&quot; 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line"></span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line">&quot; 保存全局变量</span><br><span class="line">set viminfo+=!</span><br><span class="line"></span><br><span class="line">&quot; 带有如下符号的单词不要被换行分割</span><br><span class="line">set iskeyword+=_,$,@,%,#,-</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 高亮字符，让其不受100列限制</span><br><span class="line">:highlight OverLength ctermbg=red ctermfg=white guibg=red guifg=white</span><br><span class="line">:match OverLength &apos;\%101v.*&apos;</span><br><span class="line"></span><br><span class="line">&quot; 状态行颜色</span><br><span class="line">highlight StatusLine guifg=SlateBlue guibg=Yellow</span><br><span class="line">highlight StatusLineNC guifg=Gray guibg=White</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 文件设置</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 不要备份文件（根据自己需要取舍）</span><br><span class="line">set nobackup</span><br><span class="line"></span><br><span class="line">&quot; 不要生成swap文件，当buffer被丢弃的时候隐藏它</span><br><span class="line">setlocal noswapfile</span><br><span class="line">set bufhidden=hide</span><br><span class="line"></span><br><span class="line">&quot; 字符间插入的像素行数目</span><br><span class="line">set linespace=0</span><br><span class="line"></span><br><span class="line">&quot; 增强模式中的命令行自动完成操作</span><br><span class="line">set wildmenu</span><br><span class="line"></span><br><span class="line">&quot; 在状态行上显示光标所在位置的行号和列号</span><br><span class="line">set ruler</span><br><span class="line">set rulerformat=%20(%2*%&lt;%f%=\ %m%r\ %3l\ %c\ %p%%%)</span><br><span class="line"></span><br><span class="line">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span><br><span class="line">set cmdheight=2</span><br><span class="line"></span><br><span class="line">&quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set backspace=2</span><br><span class="line"></span><br><span class="line">&quot; 允许backspace和光标键跨越行边界</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"></span><br><span class="line">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span><br><span class="line">set mouse=a</span><br><span class="line">set selection=exclusive</span><br><span class="line">set selectmode=mouse,key</span><br><span class="line"></span><br><span class="line">&quot; 启动的时候不显示那个援助索马里儿童的提示</span><br><span class="line">set shortmess=atI</span><br><span class="line"></span><br><span class="line">&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line">set report=0</span><br><span class="line"></span><br><span class="line">&quot; 不让vim发出讨厌的滴滴声</span><br><span class="line">set noerrorbells</span><br><span class="line"></span><br><span class="line">&quot; 在被分割的窗口间显示空白，便于阅读</span><br><span class="line">set fillchars=vert:\ ,stl:\ ,stlnc:\</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 搜索和匹配</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=5</span><br><span class="line"></span><br><span class="line">&quot; 在搜索的时候忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 不要高亮被搜索的句子（phrases）</span><br><span class="line">set nohlsearch</span><br><span class="line"></span><br><span class="line">&quot; 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 输入:set list命令是应该显示些啥？</span><br><span class="line">set listchars=tab:\|\ ,trail:.,extends:&gt;,precedes:&lt;,eol:$</span><br><span class="line"></span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line"></span><br><span class="line">&quot; 不要闪烁</span><br><span class="line">set novisualbell</span><br><span class="line"></span><br><span class="line">&quot; 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span><br><span class="line"></span><br><span class="line">&quot; 总是显示状态行</span><br><span class="line">set laststatus=2</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 文本格式和排版</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 自动格式化</span><br><span class="line">set formatoptions=tcrqn</span><br><span class="line"></span><br><span class="line">&quot; 继承前一行的缩进方式，特别适用于多行注释</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 为C程序提供自动缩进</span><br><span class="line">set smartindent</span><br><span class="line"></span><br><span class="line">&quot; 使用C样式的缩进</span><br><span class="line">&quot; set cindent</span><br><span class="line"></span><br><span class="line">&quot; 制表符为4</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">&quot; set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot; 不要用空格代替制表符</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 如果改成set noexpandtab就是不用四个空格代替一个table</span><br><span class="line"></span><br><span class="line">&quot; 不要换行</span><br><span class="line">set nowrap</span><br><span class="line"></span><br><span class="line">&quot; 在行和段开始处使用制表符</span><br><span class="line">set smarttab</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; CTags的设定</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 按照名称排序</span><br><span class="line">let Tlist_Sort_Type = &quot;name&quot;</span><br><span class="line"></span><br><span class="line">&quot; 在右侧显示窗口</span><br><span class="line">let Tlist_Use_Right_Window = 1</span><br><span class="line"></span><br><span class="line">&quot; 压缩方式</span><br><span class="line">let Tlist_Compart_Format = 1</span><br><span class="line"></span><br><span class="line">&quot; 如果只有一个buffer，kill窗口也kill掉buffer</span><br><span class="line">let Tlist_Exist_OnlyWindow = 1</span><br><span class="line"></span><br><span class="line">&quot; 不要关闭其他文件的tags</span><br><span class="line">let Tlist_File_Fold_Auto_Close = 0</span><br><span class="line"></span><br><span class="line">&quot; 不要显示折叠树</span><br><span class="line">let Tlist_Enable_Fold_Column = 0</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; Autocommands</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; 只在下列文件类型被侦测到的时候显示行号，普通文本文件不显示</span><br><span class="line"></span><br><span class="line">if has(&quot;autocmd&quot;)</span><br><span class="line">   autocmd FileType xml,html,c,cs,java,perl,shell,bash,cpp,python,vim,php,ruby set number</span><br><span class="line">   autocmd FileType xml,html vmap &lt;C-o&gt; &lt;ESC&gt;&apos;&lt;i&lt;!--&lt;ESC&gt;o&lt;ESC&gt;&apos;&gt;o--&gt;</span><br><span class="line">   autocmd FileType java,c,cpp,cs vmap &lt;C-o&gt; &lt;ESC&gt;&apos;&lt;o/*&lt;ESC&gt;&apos;&gt;o*/</span><br><span class="line">   autocmd FileType html,text,php,vim,c,java,xml,bash,shell,perl,python setlocal textwidth=100</span><br><span class="line">   autocmd Filetype html,xml,xsl source $VIMRUNTIME/plugin/closetag.vim</span><br><span class="line">   autocmd BufReadPost *</span><br><span class="line">      \ if line(&quot;&apos;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&apos;\&quot;&quot;) &lt;= line(&quot;$&quot;) |</span><br><span class="line">      \   exe &quot;normal g`\&quot;&quot; |</span><br><span class="line">      \ endif</span><br><span class="line">endif &quot; has(&quot;autocmd&quot;)</span><br><span class="line"></span><br><span class="line">&quot; F6编译和运行程序</span><br><span class="line"></span><br><span class="line">&quot; C的编译和运行</span><br><span class="line"></span><br><span class="line">func! CompileRunGcc()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">silent exec &quot;!gcc % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; C++的编译和运行</span><br><span class="line"></span><br><span class="line">func! CompileRunGpp()</span><br><span class="line">exec &quot;w&quot;</span><br><span class="line">silent exec &quot;!g++ % -o %&lt;&quot;</span><br><span class="line">exec &quot;! ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; python的编译和运行</span><br><span class="line">func! CompileRunPy()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!python %&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! CompileCode()</span><br><span class="line">    if &amp;filetype == &quot;c&quot;</span><br><span class="line">        exec &quot;call CompileRunGcc()&quot;</span><br><span class="line">    elseif &amp;filetype == &quot;cpp&quot;</span><br><span class="line">        exec &quot;call CompileRunGpp()&quot;</span><br><span class="line">    elseif &amp;filetype == &quot;python&quot;</span><br><span class="line">        exec &quot;call CompileRunPy()&quot;</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">map&lt;F6&gt; :call CompileCode()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;c,c++调试</span><br><span class="line">map&lt;F8&gt; :call Rungdb()&lt;CR&gt;</span><br><span class="line">func!  Rungdb()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -std=c++11 -g -o %&lt;&quot;</span><br><span class="line">    exec &quot;!gdb ./%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map &lt;F4&gt; :call TitleDet2() &lt;cr&gt;</span><br><span class="line">function AddTitle2()</span><br><span class="line">    call append(0,&quot;/************************************************************&quot;)</span><br><span class="line">    call append(1,&quot; * Author        : zhangzhengming&quot;)</span><br><span class="line">    call append(2,&quot; * Email         : 1608295563@qq.com &quot;)</span><br><span class="line">    call append(3,&quot; * Last modified : &quot;.strftime(&quot;%Y-%m-%d %H:%M&quot;))</span><br><span class="line">    call append(4,&quot; * Filename      : &quot;.expand(&quot;%:t&quot;))</span><br><span class="line">    call append(5,&quot; * Description   :&quot; )</span><br><span class="line">    call append(6,&quot; * *********************************************************/&quot;)</span><br><span class="line">    echohl WarningMsg |echo &quot;Successful in adding the copyright.&quot; | echohl None</span><br><span class="line">endf</span><br><span class="line"></span><br><span class="line">function UpdateTitle2()</span><br><span class="line">    normal m&apos;</span><br><span class="line">    execute &apos;/# *Last modified:/s@:.*$@\=strftime(&quot;:\t%Y-%m-%d %H:%M&quot;)@&apos;</span><br><span class="line">    normal &apos;&apos;</span><br><span class="line">    normal mk</span><br><span class="line">    execute &apos;/# *Filename:/s@:.*$@\=&quot;:\t\t&quot;.expand(&quot;%:t&quot;)@&apos;</span><br><span class="line">    execute &quot;noh&quot;</span><br><span class="line">    normal &apos;k</span><br><span class="line">    echohl WarningMsg | echo &quot;Successful in updating the copy right.&quot; | echohl None</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function TitleDet2()</span><br><span class="line">    let n=1</span><br><span class="line">    while n &lt; 7</span><br><span class="line">        let line = getline(n)</span><br><span class="line">        if line =~ &apos;^\#\s*\S*Last\smodified:\S*.*$&apos;</span><br><span class="line">            call UpdateTitle2()</span><br><span class="line">            return </span><br><span class="line">        endif</span><br><span class="line">        let n = n+1</span><br><span class="line">    endwhile</span><br><span class="line">    call AddTitle2()</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile *.c,*.py,*.cpp,*.sh,*.java exec &quot;:call SetTitle()&quot;</span><br><span class="line">func SetTitle() </span><br><span class="line"></span><br><span class="line">    if &amp;filetype == &apos;sh&apos;</span><br><span class="line">        call setline(1,&quot;\#!/bin/bash&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;# Author: zhangzhengming&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;# Created Time: &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;&quot;)</span><br><span class="line">    elseif &amp;filetype == &apos;cpp&apos;</span><br><span class="line">        call setline(1,&quot;// File Name: &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;// Author: zhangzhengming&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;// Created Time: &quot;.strftime(&quot;%c&quot;))  </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;#include&lt;iostream&gt;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+4, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+5, &quot;using namespace std;&quot;)            </span><br><span class="line">        call append(line(&quot;.&quot;)+6, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7, &quot;int main()&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8,&quot;&#123;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+9,&quot;    &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+10, &quot;    return 0;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+11, &quot;&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">    elseif &amp;filetype == &apos;python&apos;</span><br><span class="line">        call setline(1,&quot;\#!/usr/bin/env python&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;# Author: zhangzhengming&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;# Created Time: &quot;.strftime(&quot;%c&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;&quot;) </span><br><span class="line">    elseif &amp;filetype == &apos;c&apos;</span><br><span class="line">          call setline(1,&quot;// File Name: &quot;.expand(&quot;%&quot;)) </span><br><span class="line">        call append(line(&quot;.&quot;), &quot;// Author: zhangzhengming&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;// Created Time: &quot;.strftime(&quot;%c&quot;))  </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;#include&lt;stdio.h&gt;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+4,&quot;int main()&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+5,&quot;&#123;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+6,&quot;    &quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+7,&quot;    return 0 ;&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;)+8,&quot;&#125;&quot;)</span><br><span class="line">    else</span><br><span class="line">        call setline(1,&quot;/*&quot;)</span><br><span class="line">        call append(line(&quot;.&quot;), &quot;* Author: rechen&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+1, &quot;* Created Time: &quot;.strftime(&quot;%c&quot;))  </span><br><span class="line">        call append(line(&quot;.&quot;)+2, &quot;*/&quot;) </span><br><span class="line">        call append(line(&quot;.&quot;)+3, &quot;&quot;) </span><br><span class="line">    endif</span><br><span class="line"></span><br><span class="line">    autocmd BufNewFile * normal G</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; 能够漂亮地显示.NFO文件</span><br><span class="line">set encoding=utf-8</span><br><span class="line">function! SetFileEncodings(encodings)</span><br><span class="line">    let b:myfileencodingsbak=&amp;fileencodings</span><br><span class="line">    let &amp;fileencodings=a:encodings</span><br><span class="line">endfunction</span><br><span class="line">function! RestoreFileEncodings()</span><br><span class="line">    let &amp;fileencodings=b:myfileencodingsbak</span><br><span class="line">    unlet b:myfileencodingsbak</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">au BufReadPre *.nfo call SetFileEncodings(&apos;cp437&apos;)|set ambiwidth=single</span><br><span class="line">au BufReadPost *.nfo call RestoreFileEncodings()</span><br><span class="line"></span><br><span class="line">&quot; 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line">au BufRead,BufNewFile * setfiletype txt</span><br><span class="line"></span><br><span class="line">&quot; 用空格键来开关折叠</span><br><span class="line">set foldenable</span><br><span class="line">set foldmethod=manual</span><br><span class="line">nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; minibufexpl插件的一般设置</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1</span><br><span class="line">let g:miniBufExplModSelTarget = 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> vim </tag>
            
            <tag> linux </tag>
            
            <tag> vimrc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nat-ddns</title>
      <link href="/2021/09/27/Install-nat-ddns/"/>
      <url>/2021/09/27/Install-nat-ddns/</url>
      
        <content type="html"><![CDATA[<p>利用ubuntu服务器搭建内网穿透服务器<br><a id="more"></a></p><h2 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h2><p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">官方地址</a></p><h3 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h3><p><code>wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz</code></p><h3 id="解压："><a href="#解压：" class="headerlink" title="解压："></a>解压：</h3><p><code>tar -zxvf frp_0.37.1_linux_amd64.tar.gz</code></p><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p><code>vim frps.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7777</span><br><span class="line">token = 12345678</span><br><span class="line"></span><br><span class="line"># 配置frp后台管理账号</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line">dashboard_port = 8888</span><br><span class="line">enable_prometheus = true</span><br><span class="line"></span><br><span class="line"># 配置日志配置文件夹  </span><br><span class="line">log_file = /var/log/frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure></p><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 配置服务</span><br><span class="line">sudo cp frpc /usr/bin/</span><br><span class="line">sudo cp frps /usr/bin/</span><br><span class="line"># 复制配置文件 - 如果不是新安装则跳过这一步，不然会把旧配置覆盖掉</span><br><span class="line">sudo mkdir /etc/frp/</span><br><span class="line">sudo cp frp*.ini /etc/frp/</span><br><span class="line"># 启动frp服务</span><br><span class="line">sudo cp systemd/* /lib/systemd/system/</span><br><span class="line">sudo systemctl enable frps # 云服务器启动这个</span><br><span class="line">sudo systemctl start frps # 本地启动这个</span><br></pre></td></tr></table></figure><ul><li>访问Frp后台管理<br>在浏览器打开： ip：8888</li></ul><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><p>在windows端，需要先下载win版本的frp<a href="https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_windows_amd64.zip" target="_blank" rel="noopener">源码</a></p><h3 id="修改客户端配置文件frpc-ini"><a href="#修改客户端配置文件frpc-ini" class="headerlink" title="修改客户端配置文件frpc.ini"></a>修改客户端配置文件<strong>frpc.ini</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = public ip</span><br><span class="line">server_port = 7777</span><br><span class="line">token = 12345678</span><br><span class="line">tls_enable = true　#启动加密</span><br><span class="line"></span><br><span class="line"># 普通的连接方式，通过直接访问服务端口进行访问。</span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line"># stcp和sudp同时启动，远程桌面更快。需要在访问端同时配置frpc，端口不对服务器开放，不需要指定remote_port。</span><br><span class="line">[mstsc-tcp]</span><br><span class="line">type = stcp</span><br><span class="line">sk = abcdefg</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line"></span><br><span class="line">[mstsc-udp]</span><br><span class="line">type = sudp</span><br><span class="line">sk = abcdefg</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br></pre></td></tr></table></figure><h3 id="启动客户端，在cmd中执行命令"><a href="#启动客户端，在cmd中执行命令" class="headerlink" title="启动客户端，在cmd中执行命令"></a>启动客户端，在cmd中执行命令</h3><p><code>frpc.exe -c frpc.ini</code></p><h3 id="win开机自启-winsw"><a href="#win开机自启-winsw" class="headerlink" title="win开机自启-winsw"></a>win开机自启-winsw</h3><p><a href="https://github.com/winsw/winsw/releases" target="_blank" rel="noopener">下载地址</a></p><ul><li>根据系统版本下载对应源码，解压后放置到 Frp 同一级目录下</li><li>修改可执行文件名称为 winsw.exe</li><li><p>新建一个配置文件 winsw.xml，添加运行 Frp 客户端的命令<br>  winsw.xml配置信息：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;service&gt;</span><br><span class="line">    &lt;id&gt;frp&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;frp&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;frp远程控制客户端服务&lt;/description&gt;</span><br><span class="line">    &lt;executable&gt;frpc.exe&lt;/executable&gt;</span><br><span class="line">    &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt;</span><br><span class="line">    &lt;logmode&gt;reset&lt;/logmode&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure></li><li><p>最后，使用管理员身份打开 CMD 终端，运行下面命令，使得 Frp 客户端能变成系统服务在后台运行了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 管理员身份运行</span><br><span class="line">winsw install</span><br><span class="line">winsw start</span><br></pre></td></tr></table></figure></li></ul><h3 id="启动远程桌面"><a href="#启动远程桌面" class="headerlink" title="启动远程桌面"></a>启动远程桌面</h3><p>mstsc<br>ip:6000</p><h2 id="访问端"><a href="#访问端" class="headerlink" title="访问端"></a>访问端</h2><h3 id="修改访问端配置文件frpc-ini"><a href="#修改访问端配置文件frpc-ini" class="headerlink" title="修改访问端配置文件frpc.ini"></a>修改访问端配置文件<strong>frpc.ini</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = public ip</span><br><span class="line">server_port = 7777</span><br><span class="line">token = 12345678</span><br><span class="line">tls_enable = true　#启动加密</span><br><span class="line"></span><br><span class="line">[mstsc-tcp]</span><br><span class="line">type = stcp</span><br><span class="line">role = visitor</span><br><span class="line">server_name = mstsc-tcp</span><br><span class="line">sk = abcdefg</span><br><span class="line">bind_addr = 127.0.0.1</span><br><span class="line">bind_port = 6000</span><br><span class="line"></span><br><span class="line">[mstsc-udp]</span><br><span class="line">type = sudp</span><br><span class="line">role = visitor</span><br><span class="line">server_name = mstsc-udp</span><br><span class="line">sk = abcdefg</span><br><span class="line">bind_addr = 127.0.0.1</span><br><span class="line">bind_port = 6000</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/DNLhhIsFRjCWwE29k84aAQ" target="_blank" rel="noopener">参考1</a><br><a href="https://zhuanlan.zhihu.com/p/262533456" target="_blank" rel="noopener">参考2</a><br><a href="https://blog.csdn.net/Bobdragery/article/details/104473712" target="_blank" rel="noopener">多端口参考</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> NAT-DDNS </tag>
            
            <tag> Frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter</title>
      <link href="/2021/07/23/Install-jupyter/"/>
      <url>/2021/07/23/Install-jupyter/</url>
      
        <content type="html"><![CDATA[<p>jupyter lab 的安装与配置<br><a id="more"></a><br><a href="https://blog.csdn.net/code_game/article/details/60977255" target="_blank" rel="noopener">参考</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>pip install jupyterlab</code></p><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p><code>jupyter lab --generate-config</code></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><code>jupyter lab password</code></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab --ip 0.0.0.0 --port 11111 --no-browser --notebook-dir=&apos;/home/zzm&apos;</span><br><span class="line">--ip=0.0.0.0 监听所有ip，允许其他电脑访问</span><br><span class="line">--no-brower 不启动本地浏览器</span><br><span class="line">--notebook-dir 指定根目录</span><br><span class="line"></span><br><span class="line">jupyter lab --ip :: --port 11111  --no-browser --notebook-dir=&apos;/home/zzm&apos; 设置ipv6访问</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>jupyter UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe5 in position 4<br>解决：<br>修改系统语言变量为英文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/locale   #用 vim 来修改环境的语言配置</span><br><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;en_US:en&quot;</span><br></pre></td></tr></table></figure></p><p>修改完成，查看系统语言<br>locale</p><h3 id="jupyter中添加conda环境"><a href="#jupyter中添加conda环境" class="headerlink" title="jupyter中添加conda环境"></a>jupyter中添加conda环境</h3><p>安装完Anaconda利用conda创建了虚拟环境，但是启动jupyter notebook之后却找不到虚拟环境。<br>实际上是由于在虚拟环境下缺少kernel.json文件，解决方法如下：  </p><ul><li>首先安装ipykernel：<code>conda install ipykernel</code></li><li>在虚拟环境下创建kernel文件：<code>conda install -n 环境名称 ipykernel</code></li><li>激活conda环境： <code>source activate 环境名称</code></li><li>将环境写入notebook的kernel中<br><code>python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;</code></li><li>打开notebook服务器：jupyter notebook<br>浏览器打开对应地址，新建python，就会有对应的环境提示了</li><li>如果经常需要用jupyter notebook，那么最好在创建虚拟环境的时候便安装好ipykernel，<br>命令：<code>conda create -n 环境名称 python=3.7 ipykernel</code></li><li>删除kernel环境：<br><code>jupyter kernelspec remove 环境名称</code></li><li>查看kernel: <code>jupyter kernelspec list</code></li></ul><p>进入conda环境中启动jupyter<br><strong>通过直接启动无法显示</strong><br>可以添加conda kernel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py3 python=3 # 创建一个python3的环境，名为py3</span><br><span class="line">source activate py3 # 激活py3环境</span><br><span class="line">conda install ipykernel # 安装ipykernel模块</span><br><span class="line">python -m ipykernel install --user --name py3 --display-name &quot;py3&quot; # 进行配置</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter </tag>
            
            <tag> lab </tag>
            
            <tag> notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-shell</title>
      <link href="/2021/05/28/Program-linux-shell/"/>
      <url>/2021/05/28/Program-linux-shell/</url>
      
        <content type="html"><![CDATA[<p>linux系统中各种命令的学习<br>shell编程<br>使用过程中的各种问题处理<br><a id="more"></a></p><h1 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>查找文件里符合条件的字符串<br><code>grep &quot;word&quot; file</code></p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>利用wc指令我们可以计算文件的Byte数、字数、或是行数<br><code>wc -l file</code></p><h2 id="查看目录中的文件数量"><a href="#查看目录中的文件数量" class="headerlink" title="查看目录中的文件数量"></a>查看目录中的文件数量</h2><p>通过ls、grep、wc三个命令的组合可以实现查看目录下文件的数量，ls获取目录所有的文件，grep筛选调.和..，wc用于行记数<br><code>ls -l | grep &quot;-&quot; | wc -l</code></p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>按住 Ctrl+z键，即可将一个正在前台执行的命令放到后台，并且暂停<br>ctrl+z<br>查看：<br>jobs<br>继续执行：<br>bg 1</p><h2 id="查看分区以及文件所占大小"><a href="#查看分区以及文件所占大小" class="headerlink" title="查看分区以及文件所占大小"></a>查看分区以及文件所占大小</h2><h3 id="1-du命令"><a href="#1-du命令" class="headerlink" title="1.du命令"></a>1.du命令</h3><p>du会显示指定的目录或文件所占用的磁盘空间。<br>语法<br>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][—block-size][—exclude=&lt;目录或文件&gt;][—max-depth=&lt;目录层数&gt;][—help][—version][目录或文件]<br>参数说明：<br>    -a或-all 显示目录中个别文件的大小。<br>    -b或-bytes 显示目录或文件大小时，以byte为单位。<br>    -c或—total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>    -D或—dereference-args 显示指定符号连接的源文件大小。<br>    -h或—human-readable 以K，M，G为单位，提高信息的可读性。<br>    -H或—si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>    -k或—kilobytes 以1024 bytes为单位。<br>    -l或—count-links 重复计算硬件连接的文件。<br>    -L&lt;符号连接&gt;或—dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>    -m或—megabytes 以1MB为单位。<br>    -s或—summarize 仅显示总计。<br>    -S或—separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>    -x或—one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>    -X&lt;文件&gt;或—exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>    —exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>    —max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>    —help 显示帮助。<br>    —version 显示版本信息。</p><p>   sudo du —max-depth=1 -h /<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0/proc</span><br><span class="line">4.0K/cdrom</span><br><span class="line">1002M/var</span><br><span class="line">505M/lib</span><br><span class="line">16K/lost+found</span><br><span class="line">59M/boot</span><br><span class="line">8.0K/snap</span><br><span class="line">359G/media</span><br><span class="line">13M/sbin</span><br><span class="line">4.0K/srv</span><br></pre></td></tr></table></figure></p><p>du -sh * (同上)</p><h3 id="2-df命令"><a href="#2-df命令" class="headerlink" title="2. df命令"></a>2. df命令</h3><p>看到当前系统分区（包括交换分区swap）的”文件系统、容量、已用 、可用、已用% 、挂载点“等实时装况<br>df -l /home<br>df -h /home #-h,显示Ｍ、Ｇ更直观</p><h3 id="3-fdisk命令"><a href="#3-fdisk命令" class="headerlink" title="3.fdisk命令"></a>3.fdisk命令</h3><p>fdisk -l　＃查看所有挂着的磁盘</p><h1 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h1><h2 id="一、获取用户输入内容，并进行判断"><a href="#一、获取用户输入内容，并进行判断" class="headerlink" title="一、获取用户输入内容，并进行判断"></a>一、获取用户输入内容，并进行判断</h2><p> read -p “please input(Y/N):”  yn</p><h2 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.定义数组</span><br><span class="line">$ a=(1 2 3 4 5)</span><br><span class="line"></span><br><span class="line">2.数组长度</span><br><span class="line">$ echo $&#123;#a[@]&#125;</span><br><span class="line">用$&#123;#数组名[@或*]&#125; 可以得到数组长度</span><br><span class="line"></span><br><span class="line">3.读取数组</span><br><span class="line">$ echo $&#123;a[2]&#125;</span><br><span class="line">$ echo $&#123;a[*]&#125;</span><br><span class="line">用$&#123;数组名[下标]&#125; 下标是从0开始  下标是：*或者@ 得到整个数组内容</span><br><span class="line"></span><br><span class="line">4.赋值</span><br><span class="line">$ a[1]=100</span><br><span class="line">直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素</span><br><span class="line"></span><br><span class="line">5.删除</span><br><span class="line">$ unset a</span><br><span class="line">$ unset a[1]   </span><br><span class="line">直接通过：unset 数组[下标] 可以清除相应的元素，不带下标，清除整个数据。</span><br></pre></td></tr></table></figure><p>6.循环数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for value in $&#123;a[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $value</span><br><span class="line">done</span><br><span class="line">for ((i=0;i&lt;$&#123;#a[@]&#125;;i++)) #不加双括号会报错</span><br><span class="line">do</span><br><span class="line">    echo $&#123;a[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>7.特殊使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1）分片:</span><br><span class="line"># a=(1 2 3 4 5 6)</span><br><span class="line"># echo $&#123;a[@]:0:3&#125;</span><br><span class="line">1 2 3</span><br><span class="line"># echo $&#123;a[@]:1:4&#125;</span><br><span class="line">2 3 4 5</span><br><span class="line"># c=($&#123;a[@]:1:4&#125;)</span><br><span class="line"># echo $&#123;#c[@]&#125;</span><br><span class="line">4</span><br><span class="line"># echo $&#123;c[*]&#125;</span><br><span class="line">2 3 4 5</span><br></pre></td></tr></table></figure></p><p>直接通过 ${数组名[@或*]:起始位置:长度} 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</p><p>2）替换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># a=(1 2 3 4 5 3)</span><br><span class="line"># echo $&#123;a[@]/3/8&#125;</span><br><span class="line">1 2 8 4 5 8</span><br><span class="line"># echo $&#123;a[@]&#125;</span><br><span class="line">1 2 3 4 5 3</span><br></pre></td></tr></table></figure></p><p>调用方法是：${数组名[@或*]/查找字符/替换字符} 该操作不会改变原先数组内容。</p><h2 id="三、脚本批量压缩"><a href="#三、脚本批量压缩" class="headerlink" title="三、脚本批量压缩"></a>三、脚本批量压缩</h2><h3 id="1-将当前目录下的所有文件夹压缩"><a href="#1-将当前目录下的所有文件夹压缩" class="headerlink" title="1.将当前目录下的所有文件夹压缩"></a>1.将当前目录下的所有文件夹压缩</h3><p>找到所有的文件夹进行压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">dirnames=$(ls -d */)</span><br><span class="line">for dir in $dirnames</span><br><span class="line">do</span><br><span class="line">    temp=$&#123;dir%/&#125;</span><br><span class="line">    echo $temp </span><br><span class="line">    echo $(tar -cvf $temp&quot;.tar.gz&quot; $temp)</span><br><span class="line">    testing=$(test -e $temp&quot;.tar.gz&quot; &amp;&amp; echo yes)</span><br><span class="line">    if [ &quot;$testing&quot;==&quot;yes&quot; ]; then</span><br><span class="line">         echo $(scp $temp&quot;.tar.gz&quot; user@IP:/home/user )</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p> 找到当前目录下所有的文件和文件夹，选出文件夹进行压缩<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">for dir in $(ls)</span><br><span class="line">do</span><br><span class="line">    if [ -d $dir ]; then</span><br><span class="line">       echo $dir </span><br><span class="line">       echo $(tar -cvf $dir&quot;.tar.gz&quot; $dir)</span><br><span class="line">       testing=$(test -e $dir&quot;.tar.gz&quot; &amp;&amp; echo yes)</span><br><span class="line">       if [ &quot;$testing&quot;==&quot;yes&quot; ]; then</span><br><span class="line">          echo $(scp $dir&quot;.tar.gz&quot; user@IP:/home/user )</span><br><span class="line">       fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h1><h2 id="ubuntu文件夹打不开，点击文件夹没反应"><a href="#ubuntu文件夹打不开，点击文件夹没反应" class="headerlink" title="ubuntu文件夹打不开，点击文件夹没反应"></a>ubuntu文件夹打不开，点击文件夹没反应</h2><p>直接在命令行输入：<br><code>killall nautilus</code></p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2021/05/13/Tool-git/"/>
      <url>/2021/05/13/Tool-git/</url>
      
        <content type="html"><![CDATA[<p>github的各指令的使用<br><a id="more"></a></p><h2 id="git整体结构说明"><a href="#git整体结构说明" class="headerlink" title="git整体结构说明"></a>git整体结构说明</h2><p><a href="https://mp.weixin.qq.com/s/rqYbIEYUWgKWxOkA7Eyz9A" target="_blank" rel="noopener">参考</a></p><h2 id="配置ssh公钥"><a href="#配置ssh公钥" class="headerlink" title="配置ssh公钥"></a>配置ssh公钥</h2><p>ssh-keygen -t rsa -C “youremail@example.com” 一路下一步<br>/home/grq/.ssh  里面也会生成文件id_rsa与id_rsa.pub<br>登录GitHub，点击右上角头像，Settings -&gt; Personal settings -&gt; SSH and GPG keys。在SSH Keys标签右方点击New SSH Key。<br>弹出两个文本框。其中的Title，可以随意命名。笔者此处随便命名为grq-Ubuntu。<br>另一个Key文本框，需要输入刚刚生成的id_rsa.pub文件中的内容。粘贴后点击Add SSH Key，即可生成SSH Key。</p><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p>1.工作目录和本地仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add file    或  git add ./  （添加全部文件）</span><br><span class="line">git status     #查看属于此次更新的情况</span><br><span class="line">git commit -m &quot;Update Readme Files(Version of Chinese &amp; English)&quot;  #将缓存区的修改保存到本地仓库</span><br><span class="line">git commit --amend #不创建新节点</span><br></pre></td></tr></table></figure></p><p>2.添加远程仓库<br>首先我们应该添加一个远程仓库，命名为origin，这样随后才可以添加文件到远程库中。指令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:upcAutoLang/Framework-for-NACIT2017.git</span><br><span class="line">git remote set-url origin git@github.com:upcAutoLang/Framework-for-NACIT2017.git</span><br></pre></td></tr></table></figure></p><p>查看所有远程仓库<br><code>git remote -v</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">origin https://github.com/user2/repository.git (fetch)</span><br><span class="line">origin https://github.com/user2/repository.git (push)</span><br><span class="line">upstream https://github.com/user1/repository.git (push)</span><br><span class="line">upstream https://github.com/user1/repository.git (push)</span><br><span class="line">#origin 表示远程仓库地址的别名</span><br></pre></td></tr></table></figure></p><p>在进行git add ./操作的路径中，实际上已经生成了一个隐藏的.git文件夹。在该路径下输入指令cd ./.git便进入.git文件夹，使用gedit或vim打开文件config，在文件末尾加入内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">   email = your email</span><br><span class="line">    name = your name</span><br></pre></td></tr></table></figure></p><p>3.上传到远程仓库<br>git push -u origin main  （如果出错，可能是没有readme，运行git pull origin main (第一次使用加上了-u参数，是推送内容并关联分支。)<br>如果要使用 git push简短提交代码：<br>git push<br>需要配置 :<br>git config —global push.default simple<br>或者：<br>git config —global push.default matching<br>区别在于，前者只提交你当前所在的分支，而后者会提交本地所有的分支。</p><p>4.版本回退<br><a href="https://www.jianshu.com/p/c2ec5f06cf1a" target="_blank" rel="noopener">参考</a><br>git包括3个区域：<br>Working Tree 当前的工作区域<br>Index/Stage 暂存区域<br>Repository 提交的历史，即使用git commit提交后的结果</p><p><code>$ git reset --hard HEAD^</code>  三个区域所有的内容都被擦除，回到上一个修改前。放弃本地所有的改变。<br><code>$ git reset --soft HEAD^</code>  保留暂存区和工作目录，两者保持一致。中间许多频繁，不具有太大意义的提交，可以用来合并节点，减少无用提交的次数。<br><code>$ git reset HEAD^</code> == <code>git reset --mixed HEAD^</code>  保留工作目录，清空暂存区。soft和mixed中间的区别没有太大，可以用很少的操作来互相代替，只用mixed也完全可以。</p><p><strong>分离HEAD</strong><br>可以指向任意节点，用了查看之前的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 节点哈希值</span><br><span class="line">//也可以直接脱离分支指向当前节点</span><br><span class="line">git checkout --detach</span><br></pre></td></tr></table></figure></p><p>5.分支<br><strong>创建分支</strong><br><code>$ git branch testing</code><br><code>$ git checkout -b testing</code> #创建并切换<br><strong>分支切换</strong><br><code>$ git checkout testing</code><br><strong>删除分支</strong><br><code>$ git branch -d testing</code><br><strong>合并分支</strong><br>merge是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支<br><code>$ git merge 分支名/节点哈希值</code></p><p>6.文件恢复<br><code>git checkout -- &lt;file&gt;</code><br>命令git checkout — README.md，把README.md文件在动作区的修改全部撤销。先从缓存区stage拉取还原，如果缓存区为空则从最近一次版本库中还原。总之，就是让文件回到最近一次git add或者git commit的状态。</p><p>7.git log<br><strong>查看分支图</strong><br><code>git log --graph --decorate --oneline --simplify-by-decoration --all</code><br><code>git log --graph --oneline</code><br><code>git log --oneline --graph --decorate --all</code></p><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>git忽略某个目录或者文件<br>在工程目录下创建一个.gitignore文件<br><code>touch .gitignore</code><br>编辑文件，添加要忽略的文件和目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target //忽略这个target目录</span><br><span class="line">*.pyc  忽略.css文件</span><br><span class="line">log/* //忽略log下的所有文件</span><br><span class="line">test.json //忽略这个test.json文</span><br></pre></td></tr></table></figure></p><p>然后执行 <code>git status</code>， 就没有忽略的目录和文件了。<br>然后 执行 <code>git add .</code> , 已经没有了。 </p><h2 id="在终端通过命令创建仓库"><a href="#在终端通过命令创建仓库" class="headerlink" title="在终端通过命令创建仓库"></a>在终端通过命令创建仓库</h2><ol><li>在.zshrc中添加以下函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">github-create() </span><br><span class="line">&#123;</span><br><span class="line">    if [ $1 ]</span><br><span class="line">    then</span><br><span class="line">        repo_name=$1</span><br><span class="line">    else</span><br><span class="line">        repo_name=`basename $(pwd)`</span><br><span class="line">        echo &quot;set Repo name to $&#123;repo_name&#125;&quot;</span><br><span class="line">    fi </span><br><span class="line">    curl -u &apos;username:token&apos; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;&apos;$repo_name&apos;&quot;&#125;&apos;</span><br><span class="line">    echo &quot;# $&#123;repo_name&#125;&quot; &gt;&gt; README.md</span><br><span class="line">    git init</span><br><span class="line">    git add README.md</span><br><span class="line">    git commit -m &quot;first commit&quot;</span><br><span class="line">    git remote add origin git@github.com:username/$repo_name.git</span><br><span class="line">    git push -u origin master</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>username是github的用户名<br>token需要在<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">github</a>中申请</p><p>在终端中执行以下命令<br><code>github-create repository-name</code></p><h2 id="https-方式"><a href="#https-方式" class="headerlink" title="https 方式"></a>https 方式</h2><p>其他相同，<br>git remote add origin <a href="https://github.com/1608295563/Machine-Learning.git" target="_blank" rel="noopener">https://github.com/1608295563/Machine-Learning.git</a><br>问题：每次提交都的设置用户名密码</p><ol><li><p>在~/下， touch创建文件 .git-credentials, 用vim编辑此文件，输入内容格式：<br>touch .git-credentials<br>vim .git-credentials<br><a href="https://{username}:{password}@github.com" target="_blank" rel="noopener">https://{username}:{password}@github.com</a></p></li><li><p>在终端下执行  git config —global credential.helper store</p></li><li>可以看到~/.gitconfig文件，会多了一项：<br>[credential]<br> helper = store</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2021/03/07/Program-python/"/>
      <url>/2021/03/07/Program-python/</url>
      
        <content type="html"><![CDATA[<p>python 学习中的一些理解<br><a id="more"></a></p><h1 id="成员函数、类函数、静态函数"><a href="#成员函数、类函数、静态函数" class="headerlink" title="成员函数、类函数、静态函数"></a>成员函数、类函数、静态函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def plain_func(self): # 普通方法</span><br><span class="line">        print(&quot;plain_func&quot;)</span><br><span class="line"> </span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func(cls):  # 类方法</span><br><span class="line">        print(&quot;class_func&quot;)</span><br><span class="line"> </span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_func():    # 静态方法</span><br><span class="line">        print(&quot;static_func&quot;)</span><br><span class="line"> </span><br><span class="line"># 必须实例化进行调用</span><br><span class="line">foo = Foo()</span><br><span class="line">foo.plain_func()</span><br><span class="line"># 可通过类名进行调用</span><br><span class="line">Foo.class_func()</span><br><span class="line">Foo.static_func()</span><br></pre></td></tr></table></figure><h2 id="普通成员函数"><a href="#普通成员函数" class="headerlink" title="普通成员函数"></a>普通成员函数</h2><p>普通成员函数是最一般的方法，从调用方式来看，普通函数只能在类的实例中被调用，而后两者可以通过类名进行调用。</p><h2 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h2><p>classmethod 增加了一个 cls 参数，它引用了一个类实例。cls 类似于类中其他函数的 self 参数，例如 <strong>init</strong>(self)，只不过 self 代表创建的实例对象，而 cls 代表类本身。classmethod 可以用于写一个只在类中运行而不在实例中运行的方法，直接通过类进行调用。不管这个方法是从实例调用还是从类调用，它都用第一个参数把类传递过来。对类的用户可见的功能可使用 classmethod。</p><p>好处：</p><ul><li>方法可以判断出自己是通过基类被调用，还是通过某个子类被调用；</li><li>通过子类调用时，方法可以返回子类的实例而非基类的实例；</li><li>通过子类调用时，方法可以调用子类的其他 classmethod。</li></ul><h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>staticmethod 用于跟类有关系的功能但在运行时又不需要实例和类参与的情况，比如更改环境变量或者修改其他类的属性等。在通过类调用时，staticmethod 与 classmethod 对于调用者来说是不可区分的。<br>好处：</p><ul><li>调用时返回的是一个真正的函数，而且每次调用时返回同一个实例（classmethod 则会对基类和子类返回不同的 bound method 实例）</li></ul><p><strong> classmethod 与 staticmethod </strong><br>这两个方法的用法是类似的，在大多数情况下，classmethod 也可以通过 staticmethod 代替，staticmethod 也可以在子类上被重写为 classmethod，反之亦然。</p><h1 id="self"><a href="#self" class="headerlink" title="self"></a>self</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo&apos;)</span><br></pre></td></tr></table></figure><p>Foo().x() 等同于 Foo.x(Foo()), 对象调用成员函数，相当于默认输入了一个对象给self。<br>而且self不是必须用的只是通常用法，所以有没有self并不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Box(object):</span><br><span class="line">    def myInit(this, boxname, size, color):</span><br><span class="line">        print(this.__dict__)#显示为&#123;&#125;空字典</span><br><span class="line">        this.boxname = boxname</span><br><span class="line">        this.__dict__[&apos;aa&apos;] = &apos;w&apos;#甚至可以像字典一样操作</span><br><span class="line">        this.size = size</span><br><span class="line">        this.color = color  # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self</span><br><span class="line"> </span><br><span class="line">    def open(this):</span><br><span class="line">        print(&apos;--&gt;用自己的myself，打开那个%s,%s的%s&apos; % (this.color, this.size, this.boxname))</span><br><span class="line">        print(&apos;--&gt;用类自己的self，打开那个%s,%s的%s&apos; % (this.color, this.size, this.boxname))</span><br><span class="line"> </span><br><span class="line">    def close(this):</span><br><span class="line">        print(&apos;--&gt;关闭%s，谢谢&apos; % this.boxname)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 经过改造，运行结果和标准初始化没区别</span><br><span class="line">box=Box()</span><br><span class="line">box.myInit(&apos;魔盒&apos;, &apos;14m&apos;, &apos;红色&apos;)</span><br><span class="line"># b = Box(&apos;魔盒&apos;, &apos;14m&apos;, &apos;红色&apos;)#注释掉原来标准的初始化方法</span><br><span class="line">box.close()</span><br><span class="line">box.open()  # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。</span><br><span class="line">print(box.__dict__)  #对象会自动生成一个dict用来保存成员变量。</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&#123;&#125;</span><br><span class="line">--&gt;关闭魔盒，谢谢</span><br><span class="line">--&gt;用自己的myself，打开那个红色,14m的魔盒</span><br><span class="line">--&gt;用类自己的self，打开那个红色,14m的魔盒</span><br><span class="line">&#123;&apos;boxname&apos;: &apos;魔盒&apos;, &apos;aa&apos;: &apos;w&apos;, &apos;size&apos;: &apos;14m&apos;, &apos;color&apos;: &apos;红色&apos;&#125;</span><br></pre></td></tr></table></figure><h1 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h1><ol><li>单继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print &apos;Create Base&apos;</span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        super(A, self).__init__() #python2和python3</span><br><span class="line">        super().__init__() #python3</span><br><span class="line">        print &apos;Create A&apos;</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line"></span><br><span class="line"># 测试结果</span><br><span class="line">Create Base</span><br><span class="line">Create A</span><br></pre></td></tr></table></figure></li></ol><p>在单继承时，super().<strong>init</strong>()与Base.<strong>init</strong>()是一样的。super()避免了基类的显式调用。如果Base修改，A类也需要修改，使用super就好很多了。</p><ol><li>多继承<br>super与父类没有实质性的关联。在单继承时，super获取的类刚好是父类，但多继承时，super获取的是继承顺序中的下一个类。<br>Python中的super()方法设计目的是用来解决多重继承时父类的查找问题，所以在单重继承中用不用 super 都没关系；一般我们在子类中需要调用父类的方法时才会这么用。</li></ol><p><strong> 解决多继承带来的重复调用（菱形继承）、查找顺序（MRO）问题 </strong><br>用“父类名.属性”的方法调用出来代码维护时繁琐一点也并无不可，但Python是的继承机制是多继承，还是用这种方法来调用父类属性就会就回带来许多问题。假如有A、B、C、D这4个类，继承关系如下，我们要在各子类方法中显式调用父类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo&apos;)</span><br><span class="line">        </span><br><span class="line">class Foo1(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo1&apos;)</span><br><span class="line">        super(Foo1, self).x()</span><br><span class="line"> </span><br><span class="line">class Foo2(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print(&apos;Foo2&apos;)</span><br><span class="line">        super(Foo2, self).x()  #调用过程中self 是Foo3()</span><br><span class="line"> </span><br><span class="line">class Foo3(Foo2,Foo1):</span><br><span class="line">    def x(self):</span><br><span class="line">        print( &apos;Foo3&apos;)</span><br><span class="line">        super(Foo3,self).x()</span><br><span class="line">        </span><br><span class="line">f = Foo3()</span><br><span class="line">f.x()</span><br><span class="line">print(Foo3.mro())</span><br><span class="line"></span><br><span class="line"># 类按照mro顺序调用</span><br><span class="line">输出：</span><br><span class="line">Foo3</span><br><span class="line">Foo2</span><br><span class="line">Foo1</span><br><span class="line">Foo</span><br><span class="line">[&lt;class &apos;__main__.Foo3&apos;&gt;, &lt;class &apos;__main__.Foo2&apos;&gt;, &lt;class &apos;__main__.Foo1&apos;&gt;, &lt;class &apos;__main__.Foo&apos;&gt;, &lt;class &apos;object&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>如果不用super，Foo会被调用两次，这就是多继承带来的重复调用的问题。<br>事实上，在每个类声明之后，Python都会自动为创建一个名为“<strong>mro</strong>”的内置属性，这个属性就是Python的MRO机制生成的，该属性是一个tuple，定义的是该类的方法解析顺序（继承顺序），当用super调用父类的方法时，会按照<strong>mro</strong>属性中的元素顺序去挨个查找方法。我们可以通过“类名.mro”或“类名.mro()”来查看上面代码中Foo3类的<strong>mro</strong>属性值：</p><ol><li>怎么用super<br>super是一个类（不是方法），实例化之后得到的是一个代理的对象，而不是得到了父类，并且我们使用这个代理对象来调用父类或者兄弟类的方法。使用格式如下：<br><code>super([type[, object-or-type]])</code><br>将这个格式展开来就有一下几种传参方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super()</span><br><span class="line">super(type , obj)</span><br><span class="line">super(type_1 , type_2)</span><br></pre></td></tr></table></figure></li></ol><p>3.1 super(type , obj)<br>先说super(type , obj)，这个方式要传入两个常数，第一个参数type必须是一个类名，第二个参数是一个该类的实例化对象，不过可以不是直接的实例化对象，该类的子类的实例化对象也行。在上文中已经说到，super会按照<strong>mro</strong>属性中的顺序去查找方法，super(type , obj)两个参数中type作用是定义在<strong>mro</strong>数组中的那个位置开始找，obj定义的是用哪个类的<strong>mro</strong>元素。</p><p>3.2 super()<br>super()事实上是懒人版的super(type , obj)，这种方式只能用在类体内部，Python会自动把两个参数填充上，type指代当前类，obj指导当前类的实例对象，相当于super(class , self)。所以，以下三种代码是完全等效的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super().fun()</span><br><span class="line">super(B , self).fun()</span><br><span class="line">super(__class__ , self).fun()</span><br></pre></td></tr></table></figure></p><p>3.3 super(type_1 , type_2)<br>当super传入的两个参数都是类名是，type_2必须是type_1的子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(super(F , F()).fun()) #输出结果为：D.fun</span><br><span class="line">print(super(F , F).fun()) # 报错：TypeError: fun() missing 1 required positional argument: &apos;self&apos;</span><br></pre></td></tr></table></figure></p><p>所以，super(type_1 , type_2)与super(type , obj)有区别，在看一下下列输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(super(F , F()).fun)# 输出结果：&lt;bound method D.fun of &lt;__main__.F object at 0x000001BD44A98B38&gt;&gt;</span><br><span class="line">print(super(F , F).fun) # 输出结果：&lt;function D.fun at 0x000001BD44A9EE18&gt;</span><br><span class="line">print(D.fun) # 输出结果：&lt;function D.fun at 0x000001BD44A9EE18&gt;</span><br></pre></td></tr></table></figure></p><p>所以，当super传入的两个传输都是类时，得到的就是一个指向继承顺序下的类的代理，并未绑定实例，要调用D类的fun方法，还需传入实例：<br><code>print(super(F , F).fun(F())) #输出结果：D.fun</code><br>所以，当super传入的两个参数都是类的时候，最好只用来调用类的静态方法或者类方法。</p><p><a href="https://blog.csdn.net/dxk_093812/article/details/87553937" target="_blank" rel="noopener">参考</a></p><p>3.4 避免使用 super(self.<strong>class</strong>, self)，一般情况下是没问题的，就是怕极端的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo&apos;</span><br><span class="line"> </span><br><span class="line">class Foo2(Foo):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo2&apos;</span><br><span class="line">        super(self.__class__, self).x() # wrong</span><br><span class="line"> </span><br><span class="line">class Foo3(Foo2):</span><br><span class="line">    def x(self):</span><br><span class="line">        print &apos;Foo3&apos;</span><br><span class="line">        super(Foo3, self).x()</span><br><span class="line"> </span><br><span class="line">f = Foo3()</span><br><span class="line">f.x()</span><br></pre></td></tr></table></figure></p><p>在 Foo2 中的 super(self.<strong>class</strong>, self) 导致了死循环，super 永远去找 Foo3 的 MRO 中的下一个类，super 的第一个参数应该总是当前的类。</p><h1 id="global-和-nolocal"><a href="#global-和-nolocal" class="headerlink" title="global 和　nolocal"></a>global 和　nolocal</h1><h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>函数外部定义的变量（即global范围），在函数内部可以引用，但是不能修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 1234</span><br><span class="line">def myfun1():</span><br><span class="line">    print(a)</span><br><span class="line">    a = 123 #UnboundLocalError: local variable &apos;a&apos; referenced before assignment</span><br><span class="line">    print(a)</span><br><span class="line">myfun1()</span><br><span class="line">print(a)</span><br><span class="line"># 运行会报错</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = 1234</span><br><span class="line">def myfun1():</span><br><span class="line">    global a</span><br><span class="line">    print(a)</span><br><span class="line">    a = 123</span><br><span class="line">    print(a)</span><br><span class="line">myfun1()</span><br><span class="line">print(a)</span><br><span class="line"># 输出</span><br><span class="line">1234</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="nolocal"><a href="#nolocal" class="headerlink" title="nolocal"></a>nolocal</h2><p>指定在当前作用域使用上层作用域中（但排除global作用域）的变量名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># nonlocal只能在函数内的函数中使用，如果直接在全局作用域下定义的函数中使用该语句，会报错</span><br><span class="line">def fun():</span><br><span class="line">nonlocal y</span><br><span class="line"># SyntaxError: no binding for nonlocal &apos;y&apos; found</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line">n=&apos;n&apos;</span><br><span class="line">print(n)</span><br><span class="line">def inner():</span><br><span class="line">nonlocal n</span><br><span class="line">n=&apos;nn&apos;</span><br><span class="line">print(n)</span><br><span class="line">inner()</span><br><span class="line">print(n)</span><br><span class="line">outer()</span><br><span class="line"># 输出</span><br><span class="line">ｎ</span><br><span class="line">nn</span><br><span class="line">nn</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#对比修改为global</span><br><span class="line">n = &apos;nnn&apos;</span><br><span class="line">def outer():</span><br><span class="line">n=&apos;n&apos;</span><br><span class="line">print(n)</span><br><span class="line">def inner():</span><br><span class="line">global n</span><br><span class="line">n=&apos;nn&apos;</span><br><span class="line">print(n)</span><br><span class="line">inner()</span><br><span class="line">print(n)</span><br><span class="line">outer()</span><br><span class="line">print(n)</span><br><span class="line"># 输出</span><br><span class="line">ｎ</span><br><span class="line">nn</span><br><span class="line">n　# 第一层函数里的ｎ没有被修改</span><br><span class="line">nn #最外层的ｎ被修改了</span><br></pre></td></tr></table></figure><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="list的底层原理"><a href="#list的底层原理" class="headerlink" title="list的底层原理"></a>list的底层原理</h2><h2 id="list-sort-的底层原理（TimSort）"><a href="#list-sort-的底层原理（TimSort）" class="headerlink" title="list.sort()的底层原理（TimSort）　"></a>list.sort()的底层原理（TimSort）　</h2><p><a href="https://mp.weixin.qq.com/s/0BxXfRsfMWVGf8xr5LnzYQ" target="_blank" rel="noopener">参考</a></p><h1 id="生成器、迭代器、装饰器"><a href="#生成器、迭代器、装饰器" class="headerlink" title="生成器、迭代器、装饰器"></a>生成器、迭代器、装饰器</h1><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h1 id="init-new-call-的作用"><a href="#init-new-call-的作用" class="headerlink" title="__init() ,__new(), __call__()的作用"></a>__init<strong>() ,__new</strong>(), __call__()的作用</h1><h1 id="python-filter-and-map"><a href="#python-filter-and-map" class="headerlink" title="python filter() and map()"></a>python filter() and map()</h1><h1 id="args-kwargs的含义与用法"><a href="#args-kwargs的含义与用法" class="headerlink" title="args *kwargs的含义与用法"></a><em>args *</em>kwargs的含义与用法</h1><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h1 id="内存管理，内存池最大多少"><a href="#内存管理，内存池最大多少" class="headerlink" title="内存管理，内存池最大多少"></a>内存管理，内存池最大多少</h1><h1 id="yield是什么，与return的区别"><a href="#yield是什么，与return的区别" class="headerlink" title="yield是什么，与return的区别"></a>yield是什么，与return的区别</h1><h1 id="copy、deepcopy和赋值的区别"><a href="#copy、deepcopy和赋值的区别" class="headerlink" title="copy、deepcopy和赋值的区别"></a>copy、deepcopy和赋值的区别</h1><h1 id="变量前面一个下划线、变量前面两个下划线、前面和后面各一个下划线（var、-var、-var）"><a href="#变量前面一个下划线、变量前面两个下划线、前面和后面各一个下划线（var、-var、-var）" class="headerlink" title="变量前面一个下划线、变量前面两个下划线、前面和后面各一个下划线（var、__var、_var）"></a>变量前面一个下划线、变量前面两个下划线、前面和后面各一个下划线（<em>var、__var、_var</em>）</h1><h1 id="lambda与def-定义函数的区别"><a href="#lambda与def-定义函数的区别" class="headerlink" title="lambda与def 定义函数的区别"></a>lambda与def 定义函数的区别</h1><h1 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h1><h1 id="read-readline-readlines的区别"><a href="#read-readline-readlines的区别" class="headerlink" title="read readline readlines的区别"></a>read readline readlines的区别</h1><h1 id="python-的数据类型有哪些？"><a href="#python-的数据类型有哪些？" class="headerlink" title="python 的数据类型有哪些？"></a>python 的数据类型有哪些？</h1><h1 id="python如何用一条语句去除列表中的空字符串"><a href="#python如何用一条语句去除列表中的空字符串" class="headerlink" title="python如何用一条语句去除列表中的空字符串"></a>python如何用一条语句去除列表中的空字符串</h1>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> self </tag>
            
            <tag> super </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch-notices</title>
      <link href="/2021/02/05/Program-pytorch-notices/"/>
      <url>/2021/02/05/Program-pytorch-notices/</url>
      
        <content type="html"><![CDATA[<p>pytorch 踩过的坑<br><a id="more"></a></p><h1 id="cuda-数据和模型的差异"><a href="#cuda-数据和模型的差异" class="headerlink" title=".cuda()数据和模型的差异"></a>.cuda()数据和模型的差异</h1><p>nn.Module.cuda() 和 Tensor.cuda() 的作用效果差异，无论是对于模型还是数据，cuda()函数都能实现从CPU到GPU的内存迁移，但是他们的作用效果有所不同。<br>对于nn.Module:<br><code>model = model.cuda()</code>和<code>model.cuda()</code>能够达到一样的效果，即对model自身进行的内存迁移。<br>对于Tensor:<br>调用tensor.cuda()只是返回这个tensor对象在GPU内存上的拷贝，而不会对自身进行改变。因此必须对tensor进行重新赋值，即tensor=tensor.cuda().<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = create_a_model() </span><br><span class="line">tensor = torch.ones([3,3,3,3]) </span><br><span class="line">model.cuda() </span><br><span class="line">tensor.cuda() </span><br><span class="line">model(tensor)    # 会报错 </span><br><span class="line">tensor = tensor.cuda() </span><br><span class="line">model(tensor)    # 正常运行</span><br></pre></td></tr></table></figure></p><h1 id="torch-Tensor-detach-的使用"><a href="#torch-Tensor-detach-的使用" class="headerlink" title="torch.Tensor.detach()的使用"></a>torch.Tensor.detach()的使用</h1><p>detach()的官方说明如下：<br><code>Returns a new Tensor, detached from the current graph. The result will never require gradient.</code><br>假设有模型A和模型B，我们需要将A的输出作为B的输入，但训练时我们只训练模型B. 那么可以这样做：<br><code>input_B = output_A.detach()</code><br>它可以使两个计算图的梯度传递断开，从而实现我们所需的功能。</p><h1 id="使用nn-Dataparallel-数据不在同一个gpu上"><a href="#使用nn-Dataparallel-数据不在同一个gpu上" class="headerlink" title="使用nn.Dataparallel 数据不在同一个gpu上"></a>使用nn.Dataparallel 数据不在同一个gpu上</h1><p><code>model=nn.DataParallel(model)</code><br>问题：但是一次同事训练基于光流检测的实验时发现 data not in same cuda,做代码review时候，打印每个节点tensor，cuda里的数据竟然没有分布在同一个gpu上<br>解决：最终解决方案是在数据，吐出后统一进行执行.cuda()将数据归入到同一个cuda流中解决了该问题。</p><h1 id="pytorch-model-load可能会踩到的坑："><a href="#pytorch-model-load可能会踩到的坑：" class="headerlink" title="pytorch model load可能会踩到的坑："></a>pytorch model load可能会踩到的坑：</h1><p>如果使用了nn.Dataparallel 进行多卡训练在读入模型时候要注意加.module， 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def get_model(self):</span><br><span class="line">  if self.nGPU == 1:         </span><br><span class="line">      return self.model     </span><br><span class="line">  else:         </span><br><span class="line">      return self.model.module</span><br></pre></td></tr></table></figure></p><p><a href="https://zhuanlan.zhihu.com/p/59271905?utm_source=wechat_session" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paper</title>
      <link href="/2021/01/18/Research-paper/"/>
      <url>/2021/01/18/Research-paper/</url>
      
        <content type="html"><![CDATA[<p>文章阅读<br><a id="more"></a></p><h1 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h1><h2 id="Sketch"><a href="#Sketch" class="headerlink" title="Sketch"></a>Sketch</h2><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h3 id="datasets"><a href="#datasets" class="headerlink" title="datasets"></a>datasets</h3><ol><li><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2></li></ol><h1 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h1><h2 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h2><p>１. <a href>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a><br>BERT 的输入可以包含一个句子对 (句子 A 和句子 B)，也可以是单个句子。此外还增加了一些有特殊作用的标志位：<br>[CLS] 标志放在第一个句子的首位，经过 BERT 得到的的表征向量 C 可以用于后续的分类任务。<br>[SEP] 标志用于分开两个输入句子，例如输入句子 A 和 B，要在句子 A，B 后面增加 [SEP] 标志。<br>[UNK]标志指的是未知字符<br>[MASK] 标志用于遮盖句子中的一些单词，将单词用 [MASK] 遮盖之后，再利用 BERT 输出的 [MASK] 向量预测单词是什么。</p><h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2><ol><li><a href="https://mp.weixin.qq.com/s/PxEUU6VhB0iuCi2F_Xy-Kw" target="_blank" rel="noopener">LayoutLM2.0</a><br><a href="https://arxiv.org/abs/2012.14740" target="_blank" rel="noopener">LayoutLMv2: Multi-modal Pre-training for Visually-Rich Document Understanding</a><br>Public: arxiv 2020,Harbin Institute of Technology,Microsoft Research Asia<br><a href="https://github.com/microsoft/unilm/tree/master/layoutlm" target="_blank" rel="noopener">code</a><br>Abstract:主要针对扫描文件或数字商业文档进行理解并分析。特点在于在输入阶段直接引入了图像信息，利用多模态预训练框架对文本、图像和布局信息进行联合建模。</li></ol><h1 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h1><h1 id="MM"><a href="#MM" class="headerlink" title="MM"></a>MM</h1><h2 id="Vison-Language"><a href="#Vison-Language" class="headerlink" title="Vison Language"></a>Vison Language</h2><p>多模特任务主要集中在文本和图像，文本和语音</p><ol><li><p><a href="https://arxiv.org/pdf/2003.13198" target="_blank" rel="noopener">M6-v0: Vision-and-Language Interaction for Multi-modal Pretraining</a><br>Public: arxiv 2020，Alibaba Group,Peking University<br>Abstract: 提出了一个文本和图像多模特预训练方法InterBERT，核心还是transformer中的Attention，里边包含一个 single-stream interaction module和一个 two-stream module，使用三个预训练任务 masked segment modeling (MSM), masked region modeling(MRM) and image-text matching (ITM)来训练模型。single-stream可以有效处理多模特信息，two-stream 保证了每个模特的独立性，避免在单模态任务性能的下降。最后针对downstream stask来精调模型。感觉就是把transformer输入文本变成了同时输入文本和图像，输出也是文本和图像分别输出。<br>预训练模型经过finetune可以用于：text-based image retrieval，Zero-Shot Caption-Based Image Retrieval，Visual Commonsense Reasoning<br>data：提出了一个大规模（3.1Ｍ image-text pairs）基于手机淘宝收集的中文数据集，但是还没有公布。<br>code: 有，未运行。</p><h2 id="Spoke-Lanuage"><a href="#Spoke-Lanuage" class="headerlink" title="　Spoke Lanuage"></a>　Spoke Lanuage</h2></li><li><p><a href="https://arxiv.org/pdf/2012.08549" target="_blank" rel="noopener">Exploring Transfer Learning For End-to-End Spoken Language Understanding</a><br>Public: arxiv 2020<br>Abstract:</p></li><li><p><a href="https://arxiv.org/pdf/2011.06195" target="_blank" rel="noopener">Towards Semi-Supervised Semantics Understanding from Speech</a><br>Public: arxiv 2020<br>Abstract:</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remote-connect</title>
      <link href="/2020/11/12/Install-remote-connect/"/>
      <url>/2020/11/12/Install-remote-connect/</url>
      
        <content type="html"><![CDATA[<p>linux系统安装后远程连接，包括终端和远程桌面。<br>screen和tmux可以保持终端，客户端关闭后也不会退出，再次进入后可以直接进入原终端。<br><a id="more"></a></p><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>安装<br><code>sudo apt-get install openssh-server</code><br>连接<br><code>ssh -p PORT user@IP</code></p><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>缺点：容易使用，没有tmux好用<br>安装<br><code>sudo apt-get install screen</code><br>screen -S  name #创建screen会话，自定义screen虚拟终端的名称<br>关闭ssh<br>screen -r name #查看之前的会话虚拟终端</p><p>错误：<br>There is no screen to be resumed matching <strong><em><br>screen -d *</em></strong><br>然后再使用恢复命令恢复就 ok 了</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>优点：功能较多，可以轻易将终端划分。<br>安装<br>sudo apt-get install tmux<br><a href="https://blog.zhengmingz.top/2019/09/09/ZshTmuxVim/">使用</a></p><h1 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h1><h2 id="不需要安装桌面直接进入当前显示器桌面"><a href="#不需要安装桌面直接进入当前显示器桌面" class="headerlink" title="不需要安装桌面直接进入当前显示器桌面"></a>不需要安装桌面直接进入当前显示器桌面</h2><p>缺点：桌面操作卡顿，只能一个用户进入<br><a href="https://www.jianshu.com/p/9dce33bb490c" target="_blank" rel="noopener">参考</a></p><h2 id="需要安装桌面"><a href="#需要安装桌面" class="headerlink" title="需要安装桌面"></a>需要安装桌面</h2><p>缺点：桌面不够清晰，有部分程序界面打不开（如vs）<br>安装vnc4server<br><code>sudo apt-get install vnc4server</code><br>终端输入<code>vncserver</code>设置密码<br>安装gnome相关组件<br><code>sudo apt-get install gnome-core gnome-panel gnome-session gnome-settings-daemon gnome-terminal metacity nautilus</code><br>关闭已经开启的vnc会话<br>vncserver -kill :1<br>修改vnc启动文件<br>sudo vim ~/.vnc/xstartup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup</span><br><span class="line">[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">#x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;</span><br><span class="line">#x-window-manager &amp;</span><br><span class="line"></span><br><span class="line">export XKL_XMODMAP_DISABLE=1</span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line"></span><br><span class="line">gnome-session&amp;</span><br><span class="line">gnome-panel&amp;</span><br><span class="line">gnome-settings-daemon&amp;</span><br><span class="line">gnome-terminal&amp;</span><br><span class="line">metacity&amp;</span><br><span class="line">nautilus&amp;</span><br></pre></td></tr></table></figure></p><p>打开会话<br>vncserver ：1（2）</p><p>客户端连接：<br>IP：5901（5902）</p><p>多用户登录<br>每个用户执行vncserver，输入密码，修改启动文件<br>在终端打开会话，客户端可以使用vncviewer连接<br><a href="https://blog.csdn.net/w113691/article/details/78396896" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tmux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> remote </tag>
            
            <tag> ssh </tag>
            
            <tag> vnc </tag>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dict-list-tuple-string</title>
      <link href="/2020/06/13/Program-dict-set-tuple/"/>
      <url>/2020/06/13/Program-dict-set-tuple/</url>
      
        <content type="html"><![CDATA[<p>python中dict、list、tuple、string几种数据类型的一些用法。<br><a id="more"></a></p><h1 id="字典按value排序"><a href="#字典按value排序" class="headerlink" title="字典按value排序"></a>字典按value排序</h1><p>保存为字典后，按字典value值大小排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line"># set集合去重</span><br><span class="line">s = set(a) </span><br><span class="line"></span><br><span class="line"># 保存为dict</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">for i in s:</span><br><span class="line">    d[i] = a.count(i)</span><br><span class="line"></span><br><span class="line"># 对字典排序</span><br><span class="line">a = sorted(d.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/DasyDong/interview/blob/master/notes/python_analyse.md" target="_blank" rel="noopener">reference</a></p><h1 id="lambda用法说明"><a href="#lambda用法说明" class="headerlink" title="lambda用法说明"></a>lambda用法说明</h1><p><a href="https://www.cnblogs.com/evening/archive/2012/03/29/2423554.html" target="_blank" rel="noopener">reference 1</a><br><a href="https://blog.csdn.net/zjuxsl/article/details/79437563" target="_blank" rel="noopener">reference 2</a></p><h1 id="list转字符串"><a href="#list转字符串" class="headerlink" title="list转字符串"></a>list转字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">&apos;&apos;.join(list) 为：12345</span><br><span class="line">&apos;,&apos;.join(list) 为：1,2,3,4,5</span><br></pre></td></tr></table></figure><h1 id="根据路径获取文件名"><a href="#根据路径获取文件名" class="headerlink" title="根据路径获取文件名"></a>根据路径获取文件名</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.dirname(path)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dict </tag>
            
            <tag> set </tag>
            
            <tag> tuple </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowsocks</title>
      <link href="/2020/04/20/Install-shadowsocks/"/>
      <url>/2020/04/20/Install-shadowsocks/</url>
      
        <content type="html"><![CDATA[<p>shadowsocks-python,shadowsocks-libev,shadowxocksR等多个版本shadowsocks的服务器端的安装,以ubuntu安装为例<br><a id="more"></a></p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="shadowsocks-python-安装"><a href="#shadowsocks-python-安装" class="headerlink" title="shadowsocks-python 安装"></a>shadowsocks-python 安装</h2><p><a href="https://github.com/zzmshinnosuke/ss/blob/master/ubuntu.sh" target="_blank" rel="noopener">参考</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip  </span><br><span class="line">sudo apt-get install python3-setuptools  </span><br><span class="line">pip3 install shadowsocks</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;server&quot;:&quot;::&quot;,   #同时支持ipv4和ipv6</span><br><span class="line"> &quot;port_password&quot;: &#123;</span><br><span class="line">    &quot;port1&quot;:&quot;password1&quot;,</span><br><span class="line">    &quot;port2&quot;: &quot;password2&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动、结束"><a href="#启动、结束" class="headerlink" title="启动、结束"></a>启动、结束</h3><p>ssserver -c ~/shadowsocks.json -d start<br>ssserver -c ~/shadowsocks.json -d stop</p><h2 id="shadowsocks-libev安装"><a href="#shadowsocks-libev安装" class="headerlink" title="shadowsocks-libev安装"></a>shadowsocks-libev安装</h2><p>shadowsocks-libev可以支持更多的加密方式  </p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common -y   </span><br><span class="line">sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y   </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/shadowsocks-libev/config.json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;server&quot;:[&quot;[::]&quot;,&quot;0.0.0.0&quot;], #同时支持ipv4和ipv6</span><br><span class="line"> &quot;server_port&quot;:443,</span><br><span class="line"> &quot;password&quot;:&quot;123456&quot;,</span><br><span class="line"> &quot;timeout&quot;:600,</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>启动：systemctl restart shadowsocks-libev  </p><p>想要以后每次重启（Linux的CentOS）服务器时都可以自动启动此ss服务，则可以去：  </p><p>设置开机启动：systemctl enable shadowsocks-libev  </p><p>其他相关命令：  </p><pre><code>查看状态：systemctl status shadowsocks-libev  查看日志：journalctl -u shadowsocks-libev重启：systemctl restart shadowsocks-libev</code></pre><p>用shadowsocks-libev实现多账号/多用户  </p><p>上述创建的ss服务，只有一个（账号）密码，只能供一个人用，或者说，如果多个人使用，则使用的是同一个（账号）密码，显得很不方便和不安全。  </p><p>如果想要多个用户每人有不同的账号（密码），则可以：用shadowsocks-libev实现多账号/多用户  </p><p>新建另外一个配置文件，比如：   </p><p>/etc/shadowsocks-libev/config2.json  </p><p>内容和之前一致，只是端口号server_port和密码password改了一下即可：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;: 21501,</span><br><span class="line">    &quot;password&quot;: &quot;passowrd2&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;: 300,</span><br><span class="line">    &quot;mode&quot;: &quot;tcp_and_udp&quot;&#125;Copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>注意: 端口号不要和系统中其他服务的端口号冲突了。  </code></pre><p>另外再去用：<br><code>setsid ss-server -c /etc/shadowsocks-libev/config2.json -uCopy</code><br>启用新端口对应的ss服务。</p><h2 id="shadowsocksR"><a href="#shadowsocksR" class="headerlink" title="shadowsocksR"></a>shadowsocksR</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">git clone -b manyuser https://github.com/shadowsocksr-backup/shadowsocksr.git</span><br></pre></td></tr></table></figure><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup" target="_blank" rel="noopener">参考</a></p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>sudo ufw allow port<br>sudo ufw enable</p><h1 id="客户端（ubuntu）"><a href="#客户端（ubuntu）" class="headerlink" title="客户端（ubuntu）"></a>客户端（ubuntu）</h1><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><p>安装同server版</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>sslocal -c shadowsocks.json</code></p><h1 id="linux-shell代理"><a href="#linux-shell代理" class="headerlink" title="linux shell代理"></a>linux shell代理</h1><p>安装 proxychains<br><code>sudo apt-get install proxychains</code><br>配置代理信息<br><code>sudo vim /etc/proxychains.conf</code><br>最后一行改成自己的代理信息：<br><code>socks5 127.0.0.1 1080</code><br>使用在命令前加上proxychains：<br><code>proxychains git clone *****</code></p><p><strong>注：</strong><br>ubuntu系统自带的代理，和火狐中的代理通过socks5代理都不行，proxychains却可以通过命令行来代理。<br>记录一次多重反向代理的过程：</p><ul><li>有一台公网服务器ubuntu18因为机房被攻击的原因被限制了外网访问，但是和本机的外网ip在同一个网段下，还可以通过本机连接上；</li><li>但是服务器刚重装了系统需要联网安装一些程序，考虑怎么通过本地电脑代理实现服务器上网；  </li><li>先在本地一个ubuntu18上通过<code>apt-get install</code> 安装openssh-server和proxychains，然后在<code>var/cache/apt/archives/</code>找到对应的deb文件，并下载frp，都复制到服务器上并安装；</li><li>配置服务器的frps，以及本机的frpc，实现反向代理，这样在服务器上可以通过服务器的公网端口将流量转到本地电脑的端口；</li><li>然后配置proxychains代理到服务器frps的端口上，服务器ubuntu18和它的火狐浏览器代理都连不上网，proxychains就可以顺利的连上了； </li><li>本地端口是shadowsocks的一个翻墙代理端口。实现了远程服务器的外网访问。</li><li>查了一下，ssh也可以进行反向代理，但是没调通，不知道行不行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> 代理 </tag>
            
            <tag> proxychains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日事务安排应用</title>
      <link href="/2019/12/30/Deal-Develop-DailyManage/"/>
      <url>/2019/12/30/Deal-Develop-DailyManage/</url>
      
        <content type="html"><![CDATA[<p>自己开发一个可以进行事务管理的应用程序，目前只支持网页版，自己开发，自己部署。<br>可以对每天需要做事情按照重要性和紧急性进行排序。<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>重要性： </p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>不重要</td><td>有点重要</td><td>重要</td><td>很重要</td><td>非常重要</td></tr><tr><td>可做可不做</td><td>做了比不做好，不做影响不大</td><td>不做会有一定后果</td><td>必须做，不做后果有点严重</td><td>必须做（有关生命、前途、健康）</td></tr></tbody></table></div><p>紧急性： </p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>不紧急</td><td>有点紧急</td><td>紧急</td><td>很紧急</td><td>非常紧急</td></tr><tr><td>事情期限还早，工作量很小</td><td>事情临近期限，想做可以开始</td><td>现在不开始，后面会比较忙</td><td>今天必须做</td><td>现在必须做</td></tr></tbody></table></div><p>完成情况</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>还没开始</td><td>做了一些</td><td>完成一半</td><td>完成一多半</td><td>完成</td></tr></tbody></table></div><h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><p><strong>user表</strong></p><div class="table-container"><table><thead><tr><th>Userid</th><th>username</th><th>passwd</th><th>Remark</th></tr></thead><tbody><tr><td>char(10)</td><td>uchar(20)</td><td>uchar(20)</td><td>uchar(100)</td></tr></tbody></table></div><p><strong>transaction表</strong></p><div class="table-container"><table><thead><tr><th>Userid</th><th>addtime</th><th>needtime</th><th>deadline</th><th>importance</th><th>urgency</th><th>progress</th></tr></thead><tbody><tr><td>char(10)</td><td>char(10)</td><td>long</td><td>char(10)</td><td>int</td><td>int</td><td>int</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Deal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> 开发 </tag>
            
            <tag> 事务安排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理</title>
      <link href="/2019/12/22/Program-ImageProcess/"/>
      <url>/2019/12/22/Program-ImageProcess/</url>
      
        <content type="html"><![CDATA[<p>处理图像：截取图像<br><a id="more"></a></p><h1 id="python-的图像库-Opencv、PIL、matplotlib、skimage-使用"><a href="#python-的图像库-Opencv、PIL、matplotlib、skimage-使用" class="headerlink" title="python 的图像库(Opencv、PIL、matplotlib、skimage)使用"></a>python 的图像库(Opencv、PIL、matplotlib、skimage)使用</h1><p><a href="https://www.cnblogs.com/skyfsm/p/8276501.html" target="_blank" rel="noopener">参考-更好</a><br><a href="https://blog.csdn.net/qq_36941368/article/details/82998296" target="_blank" rel="noopener">参考</a><br><strong>cv2的记录</strong><br>ret=cv2.bitwise_and(src1,src2,dst,mask) ret和dst都可以，mask相当于在src1和src2与运算结果上又进行了一次mask与运算,但是mask是单通道的。mask区域会被保存下来，其他部分编变成黑色。</p><p><strong>matplotlib的记录</strong><br>plt.imshow()显示只有0,1的图像，但是输出是紫色和黄色的。如果要展示黑白，plt.set_cmat(‘binary’)，但是会把黑白反过来，masked区域为白色，其余为黑色。</p><h1 id="一、截取图像的一部分"><a href="#一、截取图像的一部分" class="headerlink" title="一、截取图像的一部分"></a>一、截取图像的一部分</h1><h2 id="1-使用Pillow"><a href="#1-使用Pillow" class="headerlink" title="1.使用Pillow"></a>1.使用Pillow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(path)</span><br><span class="line">img=img.crop((left, up, right, below))</span><br><span class="line"># left：与左边界的距离</span><br><span class="line"># up：与上边界的距离</span><br><span class="line"># right：还是与左边界的距离</span><br><span class="line"># below：还是与上边界的距离</span><br><span class="line">img.save(target_path+name)</span><br></pre></td></tr></table></figure><h2 id="2-多边形裁剪-多边形外的其他地方透明-python-opencv"><a href="#2-多边形裁剪-多边形外的其他地方透明-python-opencv" class="headerlink" title="2.多边形裁剪(多边形外的其他地方透明)(python-opencv)"></a>2.多边形裁剪(多边形外的其他地方透明)(python-opencv)</h2><p>方法一和二的不同在于：把mask的多边形区域设置为0还是255（黑白）。 如果mask多边形区域设为0，可以直接与原图相加，该区域不变，原图其他位置变成白色；如果mask多边形区域设为255，可以与原图进行与运算，该区域不变，其他区域变成黑色<br>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-7</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&quot;0.jpg&quot;)</span><br><span class="line">print(image.shape)</span><br><span class="line">b  = np.array([[100,100],  [250,100], [300,220],[100,230]], dtype = np.int32)</span><br><span class="line"></span><br><span class="line">roi_t = []</span><br><span class="line">for i in range(4):</span><br><span class="line">    roi_t.append(b[i])</span><br><span class="line"></span><br><span class="line"># 生成mask，多边形区域设为255白色</span><br><span class="line">roi_t = np.asarray(roi_t)</span><br><span class="line">roi_t = np.expand_dims(roi_t, axis=0)</span><br><span class="line">im = np.zeros(image.shape[:2], dtype = &quot;uint8&quot;)</span><br><span class="line">cv2.polylines(im, roi_t, 1, 255)</span><br><span class="line">cv2.fillPoly(im, roi_t, 255)</span><br><span class="line">mask = im</span><br><span class="line">masked = cv2.bitwise_and(image, image, mask=mask)</span><br><span class="line"></span><br><span class="line">#非多边形区域做透明处理</span><br><span class="line">array = np.zeros((masked.shape[0], masked.shape[1], 4), np.uint8)</span><br><span class="line">print(array.shape)</span><br><span class="line">array[:, :, 0:3] = masked</span><br><span class="line">array[:, :, 3] = 0</span><br><span class="line">array[:,:,3][np.where(array[:,:,0]&gt;2)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,1]&gt;2)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,2]&gt;2)]=255</span><br><span class="line">cv2.imwrite(&apos;0_opencv.png&apos;,array,[cv2.IMWRITE_PNG_COMPRESSION,1]) #可以设置图像的压缩程度，9压缩程度最高。</span><br><span class="line"></span><br><span class="line"># 使用PIL.Image 保存图片颜色发生了变化，重新读出来，与原图不一样.</span><br><span class="line">#opencv的接口使用BGR，而matplotlib.pyplot 则是RGB模式</span><br><span class="line">#下面代码cv2读入的是BGR模式，在opencv里面存储的是BGR，所以img用opencv输出就是正常颜色；</span><br><span class="line">#而matplotlib.pyplot是RGB模式，当用cv读入，直接用matplotlib.pyplot输出，颜色就变了，所以需要调整颜色的顺序；</span><br><span class="line"></span><br><span class="line">b,g,r,a = cv2.split(array)</span><br><span class="line">img2 = cv2.merge([r,g,b,a])</span><br><span class="line">print(img2.max())</span><br><span class="line">image_1 = Image.fromarray(img2)</span><br><span class="line">image_1.save(&quot;0_PIL.png&quot;,&quot;PNG&quot;)</span><br><span class="line"></span><br><span class="line">new_image = cv2.imread(&apos;0_opencv.png&apos;,cv2.IMREAD_UNCHANGED) # 不加cv2.IMREAD_UNCHANGED 只能读出三个通道，透明通道不能读取</span><br><span class="line">print((array==new_image).all(),new_image.shape,array.shape) # .all()全部为True，结果为True；.any()有一个为True，结果为True</span><br><span class="line"></span><br><span class="line">cv2.imshow(&quot;cutout Image&quot;, array)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&quot;0.jpg&quot;)</span><br><span class="line"></span><br><span class="line">b  = np.array([[100,100],  [250,100], [300,220],[100,230]], dtype = np.int32)</span><br><span class="line"></span><br><span class="line">roi_t = []</span><br><span class="line">for i in range(4):</span><br><span class="line">    roi_t.append(b[i])</span><br><span class="line"></span><br><span class="line"># 生成mask，，多边形区域设为0黑色</span><br><span class="line">roi_t = np.asarray(roi_t)</span><br><span class="line">roi_t = np.expand_dims(roi_t, axis=0)</span><br><span class="line">im = np.zeros(image.shape[:3], dtype = &quot;uint8&quot;)</span><br><span class="line">im.fill(255)</span><br><span class="line">cv2.polylines(im, roi_t, 1, 0)</span><br><span class="line">cv2.fillPoly(im, roi_t, 0)</span><br><span class="line">mask = im</span><br><span class="line">masked = cv2.add(image, mask)</span><br><span class="line">imp = Image.fromarray(image)</span><br><span class="line"></span><br><span class="line">#非多边形区域做透明处理</span><br><span class="line">array = np.zeros((masked.shape[0], masked.shape[1], 4), np.uint8)</span><br><span class="line">array[:, :, 0:3] = masked</span><br><span class="line">array[:, :, 3] = 0</span><br><span class="line">array[:,:,3][np.where(array[:,:,0]&lt;255)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,1]&lt;255)]=255</span><br><span class="line">array[:,:,3][np.where(array[:,:,2]&lt;255)]=255</span><br><span class="line">cv2.imwrite(&apos;0_opencv.png&apos;,array,[cv2.IMWRITE_PNG_COMPRESSION,1]) #可以设置图像的压缩程度，9压缩程度最高。</span><br><span class="line">cv2.imshow(&quot;cutout Image&quot;, array)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></p><h1 id="二、修改图像大小"><a href="#二、修改图像大小" class="headerlink" title="二、修改图像大小"></a>二、修改图像大小</h1><h2 id="1-使用Pillow-1"><a href="#1-使用Pillow-1" class="headerlink" title="1.使用Pillow"></a>1.使用Pillow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(path)</span><br><span class="line">reim=img.resize((128,128))</span><br><span class="line">reim=img.thumnail((128,128))</span><br><span class="line">#resize()方法可以缩小也可以放大，而thumbnail()方法只能缩小；</span><br><span class="line">#resize()方法不会改变对象的大小，只会返回一个新的Image对象，而thumbnail()方法会直接改变对象的大小，返回值为none；</span><br><span class="line">#resize()方法中的size参数直接规定了修改后的大小，而thumbnail()方法按比例缩小，size参数只规定修改后size的最大值。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Image </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2019/10/24/Install-mysql/"/>
      <url>/2019/10/24/Install-mysql/</url>
      
        <content type="html"><![CDATA[<p>在ubuntu18中安装mysql，并进行相关配置<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install mysql-server</p><h1 id="首次安装后root用户密码不正确的问题"><a href="#首次安装后root用户密码不正确的问题" class="headerlink" title="首次安装后root用户密码不正确的问题"></a>首次安装后root用户密码不正确的问题</h1><p>通过apt-get 命令安装的MySQL，默认的登录名和登录密码是保存在 /etc/mysql/debian.cnf 下的。<br>在命令行输入  sudo vi /etc/mysql/debian.cnf 。通过默认登录名和密码进行修改。<br><a href="https://blog.csdn.net/verylonglongago/article/details/85479704" target="_blank" rel="noopener">参考</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>（首次安装后直接运行这个会显示密码错误，需要先修改root密码）<br>sudo mysql_secure_installation<br>安装完mysql-server 会提示可以运行mysql_secure_installation。运行mysql_secure_installation会执行几个设置：<br>—为root用户设置密码<br>—删除匿名账号<br>—取消root用户远程登录<br>—删除test库和对test库的访问权限<br>—刷新授权表使修改生效<br>通过这几项的设置能够提高mysql库的安全。</p><p>建议生产环境中mysql安装这完成后一定要运行一次mysql_secure_installation，相关操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mysql_secure_installation</span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL</span><br><span class="line">SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line">In order to log into MySQL to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user. If you&apos;ve just installed MySQL, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line">Enter current password for root (enter for none):&lt;–初次运行直接回车</span><br><span class="line">OK, successfully used password, moving on…</span><br><span class="line">Setting the root password ensures that nobody can log into the MySQL</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line">Set root password? [Y/n]    #是否设置root用户密码，输入y并回车或直接回车</span><br><span class="line">New password:               #设置root用户的密码</span><br><span class="line">Re-enter new password:      #再输入一次你设置的密码</span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line">… Success!</span><br><span class="line">By default, a MySQL installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MySQL without having to have a user account created for</span><br><span class="line">them. This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother. You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line">Remove anonymous users? [Y/n]   #是否删除匿名用户,生产环境建议删除，所以直接回车</span><br><span class="line">… Success!</span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;. This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line">Disallow root login remotely? [Y/n] #是否禁止root远程登录,根据自己的需求选择Y/n并回车,建议禁止</span><br><span class="line">… Success!</span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access. This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line">Remove test database and access to it? [Y/n] #是否删除test数据库,直接回车</span><br><span class="line">- Dropping test database…</span><br><span class="line">… Success!</span><br><span class="line">- Removing privileges on test database…</span><br><span class="line">… Success!</span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line">Reload privilege tables now? [Y/n] #是否重新加载权限表，直接回车</span><br><span class="line">… Success!</span><br><span class="line">Cleaning up…</span><br><span class="line">All done! If you&apos;ve completed all of the above steps, your MySQL</span><br><span class="line">installation should now be secure.</span><br><span class="line">Thanks for using MySQL!</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h1><p><a href="https://www.cnblogs.com/xbxxf/p/9174028.html" target="_blank" rel="noopener">参考</a><br>1.使用root用户登录mysql<br>mysql -u root -p<br>2.新增一个用户<br>use mysql;<br>CREATE USER ‘username’@’localhost’ IDENTIFIED BY ‘password’;<br>3.给新用户添加权限<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘username’@’%’ IDENTIFIED BY ‘password’ WITH GRANT OPTION;<br>flush privileges;<br>quit<br>4.修改mysql配置文件<br>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf<br>找到bind-address = 127.0.0.1<br>修改为 bind-address = 0.0.0.0<br>:wq<br>5.重启mysql<br>service mysql restart<br>6.开放3306端口<br>服务器需要配置安全组规则<br>有防火墙需要开放3306<br>sudo ufw allow 3306</p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c中指针地址加1</title>
      <link href="/2019/10/22/Program-c-point-addr/"/>
      <url>/2019/10/22/Program-c-point-addr/</url>
      
        <content type="html"><![CDATA[<p>c、c++中一些指针、数组地址加减的问题<br><a id="more"></a></p><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a[5]=&#123;0,1,2,3,4&#125;;</span><br><span class="line">int *p=(int *)(&amp;a+1);</span><br><span class="line">printf(&quot;%p\n&quot;,&amp;a);</span><br><span class="line">printf(&quot;%p\n&quot;,&amp;a+1);</span><br><span class="line">printf(&quot;%d\n&quot;,*(p));</span><br><span class="line">printf(&quot;%d\n&quot;,*(p-1));</span><br><span class="line">printf(&quot;%d\n&quot;,*(p-2));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcfb1f5830</span><br><span class="line">0x7ffcfb1f5844</span><br><span class="line">32764</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>指针P+n = 指针P + sizeof（指针的类型）<em> n<br>sizeof(a)=20 a的类型是int(</em>)[5]</p><p>如果改为<code>int *p=(int *)(&amp;a[0]+1);</code>结果就完全不同了</p><p><a href="https://blog.csdn.net/qq_23996069/article/details/89309016" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/m0_37605407/article/details/79198118" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 地址 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2019/10/08/Install-docker/"/>
      <url>/2019/10/08/Install-docker/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎， 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br><a id="more"></a><br><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">参考</a><br><a href="https://blog.csdn.net/talkxin/article/details/83061973" target="_blank" rel="noopener">参考</a><br><a href="https://www.cnblogs.com/me115/p/5539047.html" target="_blank" rel="noopener">参考</a><br><a href="https://hub.docker.com/" target="_blank" rel="noopener">dockerhub</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>更新ubuntu的apt源索引<br><code>sudo apt-get update</code><br>安装包允许apt通过HTTPS使用仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p>添加Docker官方GPG key<br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code><br>设置Docker稳定版仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></p><p>添加仓库后，更新apt源索引<br><code>sudo apt-get update</code><br>安装最新版Docker CE（社区版）<br><code>sudo apt-get install docker-ce</code><br>检查Docker CE是否安装正确<br><code>sudo docker run hello-world</code></p><h2 id="支持gpu"><a href="#支持gpu" class="headerlink" title="支持gpu"></a>支持gpu</h2><p>安装 nvidia-container-toolkit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | \</span><br><span class="line">  sudo apt-key add -</span><br><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">sudo curl -s -L https://nvidia.github.io/nvidia-container-runtime/$distribution/nvidia-container-runtime.list | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">apt-get install nvidia-container-runtime</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>查看<br><code>$which nvidia-container-runtime-hook</code><br>验证下-gpus选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run --help | grep -i gpus</span><br><span class="line">       --gpus gpu-request               GPU devices to add to the container (&apos;all&apos; to pass all GPUs)</span><br></pre></td></tr></table></figure></p><p>运行利用GPU的Ubuntu容器<br><code>$ docker run -it --rm --gpus all ubuntu nvidia-smi</code></p><h1 id="添加到docker用户组"><a href="#添加到docker用户组" class="headerlink" title="添加到docker用户组"></a>添加到docker用户组</h1><p>关于Docker时的权限问题解决dial unix /var/run/docker.sock: connect: ‘permission denied’<br>将当前用户加入到docker组中<br><code>sudo gpasswd -a $USER docker</code><br>将当前用户切换到docker组中<br><code>newgrp - docker</code>  </p><h1 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h1><p><strong>运行容器</strong><br>docker run -d -P training/webapp python app.py<br>-d 后台运行<br>-P 自动映射端口<br>-p 指定端口 #-p 5000:5000<br><strong>查看容器</strong><br>docker ps<br><strong>停止容器</strong><br>docker stop id/name<br><strong>重启容器</strong><br>docker start id/name</p><p><strong>附着容器</strong><br>附着到正在运行的容器<br>docker attach <id、container_name><br>进入正在运行的容器内部，同时运行bash(比attach更好用)<br>docker exec -t -i <id container_name>  /bin/bash</id></id、container_name></p><h2 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images  #列出本地镜像</span><br><span class="line">$ docker pull ubuntu:13.10 #获取新镜像</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 在 pycharm（社区版）上安装运行</title>
      <link href="/2019/09/26/Install-django/"/>
      <url>/2019/09/26/Install-django/</url>
      
        <content type="html"><![CDATA[<p>django可以基于python后端开发web<br><a id="more"></a></p><h1 id="环境及版本"><a href="#环境及版本" class="headerlink" title="环境及版本"></a>环境及版本</h1><p>ubuntu 16<br>python<br>pycharm（community）<br>pip 安装，需要先安装python，下载tar.gz文件，解压，python setup.py install</p><h1 id="Django安装"><a href="#Django安装" class="headerlink" title="Django安装"></a>Django安装</h1><p>pip install django<br>输入 django-admin 验证是否安装成功</p><p>在pycharm中创建django工程<br>1.创建项目<br>django-admin startproject Demo  （Demo为项目名称）<br>使用pycharm open生成的项目工程目录如下：<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/1.png" alt="1"><br>2.创建应用<br>点击pycharm左下角，选择terminal<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/3.png" alt="3"><br>在Terminal中输入：<br>python manage.py startapp web （web为应用名称）<br>项目目录如下：<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/2.png" alt="2"><br>3.启动服务<br>在terminal中输入<br>python manage.py runserver<br>在服务启动后，在浏览其中输入127.0.0.1:8000<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/4.png" alt="4"><br>可以看到服务启动成功。<br>4.允许其他电脑访问该服务<br>在settings.py中将<br>ALLOWED_HOSTS = []  改为 ALLOWED_HOSTS = [‘*’,]，注意不要漏掉“,”<br>在Terminal中输入：<br>python manage.py runserver 0.0.0.0:9000<br>支持ipv6：  python manage.py runserver [::]:9000<br>在其他机器可以使用本机器的ip和port访问<br>如:<code>192.168.2.5:9000</code><br> <code>[ipv6]:9000</code></p><p>5.问题<br>（1）Django app接口url报错Forbidden (CSRF cookie not set.)<br>这是因为Django对表单post请求做的安全性验证，在app开发中，可以干掉这一项，具体操作如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改settings.py文件，注释掉</span><br><span class="line">django.middleware.csrf.CsrfViewMiddleware&apos;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = [ </span><br><span class="line">&apos;django.middleware.security.SecurityMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, </span><br><span class="line">&apos;django.middleware.common.CommonMiddleware&apos;, </span><br><span class="line"># &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.auth.middleware.SessionAuthenticationMiddleware&apos;, </span><br><span class="line">&apos;django.contrib.messages.middleware.MessageMiddleware&apos;, </span><br><span class="line">&apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;, </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>(2) 跨域问题<br>pip install django-cors-headers</p><p>配置settings.py文件<br>添加<br>设置可跨域范围<br>CORS_ALLOW_CREDENTIALS = True<br>CORS_ORIGIN_ALLOW_ALL = True<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/5.png" alt="5"><br>定义跨域中间件<br>‘corsheaders.middleware.CorsMiddleware’,<br><img src="//blog.zhengmingz.top/2019/09/26/Install-django/6.png" alt="6"></p><h1 id="django-性能优化，提高并发数量"><a href="#django-性能优化，提高并发数量" class="headerlink" title="django 性能优化，提高并发数量"></a>django 性能优化，提高并发数量</h1><p>nginx+uwsgi+django<br><a href="https://www.jianshu.com/p/4db9581353a1" target="_blank" rel="noopener">参考1</a> (未验证可行性)<br><a href="https://blog.csdn.net/u013378306/article/details/76215982" target="_blank" rel="noopener">参考2</a> (未验证可行性)<br><a href="https://www.cnblogs.com/1204guo/p/8056641.html" target="_blank" rel="noopener">参考3</a> (未验证可行性)</p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取某目录下的全部文件和目录</title>
      <link href="/2019/09/26/Program-ReadDirectory/"/>
      <url>/2019/09/26/Program-ReadDirectory/</url>
      
        <content type="html"><![CDATA[<p>Python和linux shell中读取某目录下的文件和目录<br><a id="more"></a></p><h1 id="一、python"><a href="#一、python" class="headerlink" title="一、python"></a>一、python</h1><h2 id="1-获取某目录下的全部文件"><a href="#1-获取某目录下的全部文件" class="headerlink" title="1.获取某目录下的全部文件"></a>1.获取某目录下的全部文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isfile(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h2 id="2-获取某目录下的全部目录"><a href="#2-获取某目录下的全部目录" class="headerlink" title="2.获取某目录下的全部目录"></a>2.获取某目录下的全部目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if not os.path.isfile(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path=&apos;/home/user/program&apos;</span><br><span class="line">roots=os.listdir(path)</span><br><span class="line">print(&apos;root_dir:&apos;,roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isdir(path+file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure></p><h2 id="3-walk一次拿到全部分开的文件和目录"><a href="#3-walk一次拿到全部分开的文件和目录" class="headerlink" title="3.walk一次拿到全部分开的文件和目录"></a>3.walk一次拿到全部分开的文件和目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def file_name(file_dir):</span><br><span class="line">    root= os.walk(file_dir,topdown=True)</span><br><span class="line">    print(root.__next__())</span><br><span class="line">file_name(&apos;/home/user/program&apos;)</span><br></pre></td></tr></table></figure><p> 输出：<br> <code>(&#39;/home/zzm/program&#39;, [&#39;sketch_rnn&#39;, &#39;semantic_image_inpainting-master&#39;, &#39;timage&#39;, &#39;.ipynb_checkpoints&#39;, &#39;Gan_Mnist&#39;, &#39;GlobalLocalImageCompletion_TF-master&#39;, &#39;11Class_1_new_64&#39;, &#39;.git&#39;, &#39;11Class_3_new_64&#39;], [&#39;aa.c&#39;, &#39;test.py&#39;, &#39;aa&#39;, &#39;Untitled.ipynb&#39;, &#39;linerRegression.py&#39;, &#39;DealImage.py&#39;])</code></p><h2 id="4-递归获取所有子目录下的文件和目录"><a href="#4-递归获取所有子目录下的文件和目录" class="headerlink" title="4.递归获取所有子目录下的文件和目录"></a>4.递归获取所有子目录下的文件和目录</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def file_name(file_dir):</span><br><span class="line">    for root,dirs,files in os.walk(file_dir,topdown=True):</span><br><span class="line">        print(&apos;root_dir:&apos;,root)</span><br><span class="line">        print(&apos;sub_dirs:&apos;,dirs)</span><br><span class="line">        print(&apos;files&apos;,files)</span><br><span class="line"></span><br><span class="line">file_name(&apos;/home/user/program&apos;)</span><br></pre></td></tr></table></figure><h2 id="5-获取某一类型的文件，并获取没有后缀的文件名"><a href="#5-获取某一类型的文件，并获取没有后缀的文件名" class="headerlink" title="5.获取某一类型的文件，并获取没有后缀的文件名"></a>5.获取某一类型的文件，并获取没有后缀的文件名</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">roots=os.listdir(&apos;/home/zzm/program&apos;)</span><br><span class="line">print(&apos;root_dir:&apos;, roots)</span><br><span class="line">for file in roots:</span><br><span class="line">    if os.path.isfile(&apos;/home/zzm/program/&apos; + file) and os.path.splitext(file)[1] == &apos;.py&apos; :</span><br><span class="line">        print(os.path.splitext(file)[0])</span><br></pre></td></tr></table></figure><h2 id="6-glob"><a href="#6-glob" class="headerlink" title="6. glob"></a>6. glob</h2><p> os.listdir: 获取文件夹下的文件和文件夹的名称<br> glob.glob: 获取文件夹下，符合通配符的文件及文件夹的路径<br>注意：不要在末尾加 \，文件夹参数就到文件夹，不用加\，文件通配符，也不用加 \<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">paths = glob.glob(os.path.join(path,&apos;*.json&apos;))</span><br><span class="line"># 输出带路径</span><br></pre></td></tr></table></figure></p><h1 id="二、linux-bash"><a href="#二、linux-bash" class="headerlink" title="二、linux bash"></a>二、linux bash</h1><h2 id="1-获取某目录下全部子目录"><a href="#1-获取某目录下全部子目录" class="headerlink" title="1.获取某目录下全部子目录"></a>1.获取某目录下全部子目录</h2><p>ls -F | grep ‘/$’<br>注：ls -F 显示的目录以/结尾,再用grep筛选出来,-F参数使得ls命令可以在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符。而文件后面的星号(“*”)字符表示这是一个可执行程序</p><p>ls -l | grep ‘^d’<br>注：ls -l 显示的目录以d开头</p><p>ls -ld */</p><p>ls -ap | grep ‘/‘<br>注：ls -p可以给目录加上一个’/’，过滤一下就能只显示目录了,-a显示隐藏文件。</p><h2 id="2-获取某目录下全部文件"><a href="#2-获取某目录下全部文件" class="headerlink" title="2.获取某目录下全部文件"></a>2.获取某目录下全部文件</h2><p>ls -F | grep -v ‘/$’<br>注：grep -v 找相反的，也就是不以/结尾的文件</p><p>ls  -F | grep -v ‘/$’ | grep ‘.py$’<br>注：找出文件，且以.py结尾的。</p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> file </tag>
            
            <tag> directory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法</title>
      <link href="/2019/09/26/Algorithm-PartOptim/"/>
      <url>/2019/09/26/Algorithm-PartOptim/</url>
      
        <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><ol><li>粒子群优化算法是一种基于种群寻优的启发式搜索算法。在1995年由Kennedy 和Eberhart 首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我们经常可以观察到鸟群表现出来的同步性，虽然每只鸟的运动行为都是互相独立的，但是在整个鸟群的飞行过程中却表现出了高度一致性的复杂行为，并且可以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每只鸟在飞行过程中都遵循了一定的行为规则，并能够掌握邻域内其它鸟的飞行信息。<a id="more"></a><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1></li><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所经过的位置进行评价，并根据这些信息和位置速度更新规则，改变自身的两个状态量，在“飞行”过程中传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题的近似最优解。<h1 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h1>连续解空间的优化问题求解<br>数值优化问题<br>问题描述<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1>粒子群优化算法求解函数f(x)=x^3-5x^2-2x+3在[-2,5]的最大值</li></ol><p>java源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class Pos &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        Pos pos=new Pos();</span><br><span class="line">        pos.Initialize();</span><br><span class="line">        pos.Search();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;PosNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i&lt;PosNum*2/7)</span><br><span class="line">                p_pos[i]=(random.nextDouble()-1)*2;</span><br><span class="line">            else</span><br><span class="line">                p_pos[i]=random.nextDouble()*5;</span><br><span class="line">                p_v[i]=p_best[i]=p_pos[i];</span><br><span class="line">            if(function(g_best)&lt;function(p_best[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                g_best=p_best[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Search()</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;step;j++)  //迭代</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=0;i&lt;PosNum;i++)  //更新</span><br><span class="line">            &#123;</span><br><span class="line">                p_v[i]=w*p_v[i]+c1*random.nextDouble()*(p_best[i]-p_pos[i])+c2*random.nextDouble()*(g_best-p_pos[i]);</span><br><span class="line">                if(-2&lt;(p_pos[i]+p_v[i])&amp;&amp;(p_pos[i]+p_v[i])&lt;5)</span><br><span class="line">                    p_pos[i]+=p_v[i];</span><br><span class="line">                if(function(p_best[i])&lt;function(p_pos[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    p_best[i]=p_pos[i];</span><br><span class="line">                &#125;</span><br><span class="line">                if(function(g_best)&lt;function(p_best[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_best=p_best[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(p_pos[i]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(g_best+&quot; &quot;+function(g_best));</span><br><span class="line">    &#125;</span><br><span class="line">    public double function(double x)</span><br><span class="line">    &#123;</span><br><span class="line">        double y=x*x*x-5*x*x-2*x+3;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final int step=10000; //迭代次数</span><br><span class="line">    private final int PosNum=70; //粒子数</span><br><span class="line">    private final double w=0.9;//惯性权重</span><br><span class="line">    private final double c1=2;//局部权重参数</span><br><span class="line">    private final double c2=2;//全局权重参数</span><br><span class="line">    </span><br><span class="line">    private double g_best; //全局最优解</span><br><span class="line">    private double p_best[]=new double[PosNum];;//粒子本身历史最优解</span><br><span class="line">    private double[] p_v=new double[PosNum];;//粒子速度</span><br><span class="line">    private double[] p_pos=new double[PosNum];//粒子位置</span><br><span class="line">    </span><br><span class="line">    private Random random=new Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 粒子群 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg转png格式</title>
      <link href="/2019/09/26/Program-svg2png/"/>
      <url>/2019/09/26/Program-svg2png/</url>
      
        <content type="html"><![CDATA[<p>矢量图svg转化为png格式<br><a id="more"></a></p><h1 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h1><h2 id="1-安装cairosvg"><a href="#1-安装cairosvg" class="headerlink" title="1.安装cairosvg"></a>1.安装cairosvg</h2><p>直接安装会出错，需要安装依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-lxml</span><br><span class="line">sudo apt install python3-dev</span><br><span class="line">sudo apt install libffi-dev</span><br><span class="line">sudo apt install libcairo2</span><br></pre></td></tr></table></figure></p><p><code>pip3 install cairosvg</code></p><h2 id="2-运行"><a href="#2-运行" class="headerlink" title="2.运行"></a>2.运行</h2><p>在command-line：<br><code>$ cairosvg image.svg -o image.png</code><br>导入 python3 运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import cairosvg</span><br><span class="line">&gt;&gt;&gt; cairosvg.svg2pdf(url=&apos;image.svg&apos;, write_to=&apos;image.pdf&apos;)</span><br></pre></td></tr></table></figure></p><p>批量转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3.5</span><br><span class="line"></span><br><span class="line">import cairosvg</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">filetype=&apos;test&apos;</span><br><span class="line">filepath=&apos;/data/sketch_rnn/svg/arron_sheep/&apos;+filetype+&apos;/&apos;</span><br><span class="line">targepath=&apos;/data/sketch_rnn/png/arron_sheep/&apos;+filetype+&apos;/&apos;</span><br><span class="line">if os.path.exists(targepath):</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    os.makedirs(targepath)</span><br><span class="line">for i in range(1,7400):</span><br><span class="line">    print (i) </span><br><span class="line">    aa=cairosvg.svg2png(WIDTH=64,url=filepath+str(i)+&apos;.svg&apos;,write_to=targepath+str(i)+&apos;.png&apos;,dpi=250)</span><br><span class="line">    print (aa)</span><br></pre></td></tr></table></figure></p><h2 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h2><p>svg转化后的png跟原图一样大，不能改变大小，设置width和height等参数不管用。</p><h1 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h1><h2 id="1-使用ubuntu系统的ImageMagick进行转化。"><a href="#1-使用ubuntu系统的ImageMagick进行转化。" class="headerlink" title="1.使用ubuntu系统的ImageMagick进行转化。"></a>1.使用ubuntu系统的ImageMagick进行转化。</h2><p><code>convert test.svg test.png</code></p><h2 id="2-批量转换图片"><a href="#2-批量转换图片" class="headerlink" title="2.批量转换图片"></a>2.批量转换图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">#源svg所在目录</span><br><span class="line">sourcepath=&quot;tuberling_svg/&quot;  </span><br><span class="line">#保存png目录</span><br><span class="line">targetpath=&quot;tuberling_stroke_png/&quot;</span><br><span class="line">mkdir $targetpath</span><br><span class="line">for dir in $(ls $sourcepath)</span><br><span class="line">do</span><br><span class="line">    echo $dir</span><br><span class="line">    mkdir $targetpath$dir</span><br><span class="line">    for file in $(ls $sourcepath$dir)</span><br><span class="line">    do</span><br><span class="line">        #删除文件名后面的svg，用来获取文件名保存png。</span><br><span class="line">        temp=$&#123;file%.svg&#125;</span><br><span class="line">        convert $sourcepath$dir&quot;/&quot;$temp&quot;.svg&quot; $targetpath$dir&quot;/&quot;$temp&quot;.png&quot; </span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> svg </tag>
            
            <tag> png </tag>
            
            <tag> image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长子数组</title>
      <link href="/2019/09/17/Algorithm-longestSubarray/"/>
      <url>/2019/09/17/Algorithm-longestSubarray/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，修改其中一个数字，找到最长子数组<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个无序的整型数组，允许将其中一个元素修改为任意整型值（包括原值），使修改后的数组存在尽可能长的连续递增序列。<br>输出修改后数组最长递增序列的长度</p><p><strong>输入描述</strong><br>第一行输入为数组长度；第二行输入为数组元素，以空格隔开。数组中无重复元素，输入元素的取值范围为[-100000,100000]。<br><strong>输出描述</strong><br>修改之后数组内最长连续递增序列的长度<br><strong>示例1</strong><br>输入<br><code>5</code><br><code>3 1 2 5 4</code><br>输出<br><code>4</code><br>说明：将5改为3，或将3改为0<br><strong>示例2</strong><br>输入<br><code>4</code><br><code>3 7 4 8</code><br>输出<br><code>3</code><br>说明：将7改为小于4的值</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>先找到所有递增子数组，<br>将所有的子数组与相邻子数组进行修改一位合并，如果不能合并则+1，可以合并则+另一个数组长度。<br>找到合并后的最长子数组。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#判断两个子数组能否合并</span><br><span class="line">def check(nums,seq1,seq2):</span><br><span class="line">    if (seq1[1]-seq1[0]+1)==1:</span><br><span class="line">        return seq2[1]-seq2[0]+1+1</span><br><span class="line">    if (seq2[1]-seq2[0]+1)==1:</span><br><span class="line">        return seq1[1]-seq1[0]+1+1</span><br><span class="line">    if (nums[seq2[0]+1]&gt;nums[seq1[1]]+2) or (nums[seq2[0]]&gt;nums[seq1[1]-1]+2):</span><br><span class="line">        return seq2[1]-seq2[0]+1+seq1[1]-seq1[0]+1</span><br><span class="line">    len1=seq1[1]-seq1[0]+1</span><br><span class="line">    len2=seq2[1]-seq2[0]+1</span><br><span class="line">    if len1&gt;len2:</span><br><span class="line">        return len1+1</span><br><span class="line">    else:</span><br><span class="line">        return len2+1</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    count=int(input())</span><br><span class="line">    nums=[int(a) for a in input().split(&apos; &apos;)]</span><br><span class="line">    seqs=[]</span><br><span class="line">    index=0</span><br><span class="line">    #先将原数组划分为递增的多个子数组</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        i=i+1</span><br><span class="line">        if i==len(nums):</span><br><span class="line">            seqs.append([index,i-1])</span><br><span class="line">            break</span><br><span class="line">        if nums[i-1]&gt;=nums[i]:</span><br><span class="line">            seqs.append([index,i-1])</span><br><span class="line">            index=i</span><br><span class="line">    #将相邻的子数组合并，找到最长的子数组</span><br><span class="line">    max=seqs[0][1]+seqs[0][0]+1</span><br><span class="line">    for i in range(len(seqs)):</span><br><span class="line">        if i==len(seqs)-1:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            result=check(nums,seqs[i],seqs[i+1])</span><br><span class="line">            if result&gt;max:</span><br><span class="line">                max=result</span><br><span class="line">    print(max)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改bug</title>
      <link href="/2019/09/17/Algorithm-bugNum/"/>
      <url>/2019/09/17/Algorithm-bugNum/</url>
      
        <content type="html"><![CDATA[<p>p某看见Q头上的bug太多了<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="//blog.zhengmingz.top/2019/09/17/Algorithm-bugNum/title.png" alt="title"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以看做，n个数的数组，中每次消除连续个相同的数，使每次消除个数的平方和最大。首先找到个数最多的数字，然后按照数字最多的位置将原数组划分成多个子数组，可以递归求每个子数组的最大bug数。数组中可能会出现个数相同的多个数字，需要对每个数字分别计算，找到不同划分的最大值。</p><h1 id="python源码"><a href="#python源码" class="headerlink" title="python源码"></a>python源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#递归最大bug数</span><br><span class="line">def maxbug(balls):</span><br><span class="line">    if len(balls)==1:</span><br><span class="line">        return  1</span><br><span class="line">    max_index=select(balls);</span><br><span class="line">    max_sum=0</span><br><span class="line">    for mi in max_index:</span><br><span class="line">        sum= mi[1]*mi[1]</span><br><span class="line">        index=0</span><br><span class="line">        for i,m in enumerate(balls):</span><br><span class="line">            if m==int(mi[0]):</span><br><span class="line">                if i-index&gt;=1:</span><br><span class="line">                    #print(&apos;index&apos;, index, i - 1,mi,balls[index:i])</span><br><span class="line">                    sum+=maxbug(balls[index:i])</span><br><span class="line">                index=i+1</span><br><span class="line">            if i==len(balls)-1:</span><br><span class="line">                if i-index&gt;=0:</span><br><span class="line">                   # print(&apos;index&apos;, index, i ,mi,balls[index:i])</span><br><span class="line">                    sum+=maxbug(balls[index:i+1])</span><br><span class="line">        if sum&gt;max_sum:</span><br><span class="line">            max_sum=sum</span><br><span class="line">        #print(&apos;sum&apos;,sum)</span><br><span class="line">    return max_sum</span><br><span class="line">#每次选出数组中个数最大的一个或者多个数</span><br><span class="line">def select(balls):</span><br><span class="line">    temp=&#123;&#125;</span><br><span class="line">    for ball in balls:</span><br><span class="line">        if str(ball) in temp.keys():</span><br><span class="line">            temp[str(ball)]+=1</span><br><span class="line">        else:</span><br><span class="line">            temp[str(ball)]=1</span><br><span class="line">    temp = sorted(temp.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line">    #print(temp)</span><br><span class="line">    result=[]</span><br><span class="line">    max=temp[0][1]</span><br><span class="line">    #print(&apos;max:&apos;,max)</span><br><span class="line">    for i in temp:</span><br><span class="line">        if i[1]==max:</span><br><span class="line">            result.append(i)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">balls=[2,1,6,10,8,8,6,3,2,1]</span><br><span class="line">balls=[8,6,2,6,6,3,2,3,2,2]</span><br><span class="line">print(maxbug(balls))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装</title>
      <link href="/2019/09/16/Install-ubuntu/"/>
      <url>/2019/09/16/Install-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>分为两种方式：<br>（1）通过U盘制作启动盘安装<br>（2）在已经安装windows的基础上，安装ubuntu16双系统，使用硬盘安装的方式，不用u盘。<br><a id="more"></a></p><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><h3 id="U盘安装"><a href="#U盘安装" class="headerlink" title="U盘安装"></a>U盘安装</h3><p>发现了一个好用的工具<a href="https://www.ventoy.net/" target="_blank" rel="noopener">Ventoy</a>,程序不需要安装（绿色启动），操作系统不需要写入U盘，直接通过iso文件启动安装。</p><ul><li>打开Ventoy中的exe文件，选择做启动盘的U盘，点击“安装”制作启动盘</li><li>将Ubuntu系统iso文件，复制到U盘中（格式为exFAT）。</li><li>插入U盘，重启系统，按键盘进入bios的按键，进入启动页面设置从U盘启动，然后保存并重启系统<br>注：如果Ventoy图形界面不能对多个iso文件进行切换选择，可以进入字符界面</li></ul><h3 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h3><ul><li>在Win系统下载安装easybcd，创建启动条目<br>title Install Ubuntu<br>root (hd0,0)<br>kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8<br>initrd (hd0,0)/initrd.lz</li><li>将vmlinuz.efi   initrd.lz   系统iso复制到 对应的分区目录下</li></ul><h2 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h2><ul><li>进入临时系统，执行下面命令，可以防止安装过程卡死（ubuntu硬盘安装一直正在探测文件系统）<br>sudo umount -l /isodevice/    </li><li>分区<br>/ 根分区 主分区 ext4<br>/home 用户分区 ext4  尽可能大<br>/swap 交换分区，和内存一样大<br>注：boot选择在对应的根分区，不用新建分区</li><li>在easybcd中添加ubuntu启动项，选择grub2（U盘安装，忽略这一步）</li></ul><h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><ul><li>在联想p318上安装的时候，卡死。failed to create kernel channel, -22<br>在安装界面，按‘e’，进入编辑，在<code>quiet splash</code>后添加<br><code>quiet splash nouveau.modeset=0</code><br>装完后系统特别卡，键盘鼠标都不能用。也可以用使用上面方法临时解决。<br>终极解决，需要安装NVIDIA显卡驱动。</li></ul><h3 id="卸载一些没用的软件"><a href="#卸载一些没用的软件" class="headerlink" title="卸载一些没用的软件"></a>卸载一些没用的软件</h3><ul><li>卸载libreoffices<br>sudo apt-get remove libreoffice-common</li><li>删除Amazon广告图标<br>sudo rm -f /usr/share/applications/com.canonical.launcher.amazon.desktop<br>sudo rm -f /usr/share/applications/ubuntu-amazon-default.desktop</li><li>删除多余的软件<br>sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install transmission-common</li></ul><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="解决linux终端路径过长的问题"><a href="#解决linux终端路径过长的问题" class="headerlink" title="解决linux终端路径过长的问题"></a>解决linux终端路径过长的问题</h3><p>vim ~/.bashrc<br>找到61行左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &apos;</span><br></pre></td></tr></table></figure></p><p>\u 表示当前用户名<br>\h 表示当前主机名（hostname）<br>\w 表示当前路径<br>把\w改为\W（小写的w改为大写），不显示全路径，只显示basename（当前文件夹名）<br>用户名和主机名也没有什么用</p><h3 id="ubuntu-开机自动挂载硬盘"><a href="#ubuntu-开机自动挂载硬盘" class="headerlink" title="ubuntu 开机自动挂载硬盘"></a>ubuntu 开机自动挂载硬盘</h3><p><a href="https://www.cnblogs.com/tanrong/p/10225229.html" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/fieldtianye/p/9295986.html" target="_blank" rel="noopener">参考二</a></p><p><strong>挂载/home到新硬盘</strong>  </p><ul><li>识别硬盘<br><code>sudo fdisk -l</code>  </li><li>格式化硬盘<br><code>sudo mkfs.ext4 /dev/sdb1</code></li><li><p>挂载新硬盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/tmp</span><br><span class="line">sudo mount /dev/sdb1 /mnt/tmp</span><br></pre></td></tr></table></figure></li><li><p>同步home所有的文件到/mnt/tmp<br><code>sudo rsync -avx /home /mnt/tmp</code></p></li><li><p>备份旧home，创建新home  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /home /home_bak</span><br><span class="line">sudo mkdir /home</span><br></pre></td></tr></table></figure></li><li><p>查看新硬盘的UUID<br><code>sudo blkid</code><br>编辑/etc/fstab文件，末尾添加<br><code>UUID=175ab25f-5190-4df7-8795-8a00a0f78fd6 /home           ext4    defaults      0       2</code>  </p></li><li>保存<br><code>sudo mount -a</code><br>不保存就可以了（但是/home中的东西并没有复制成功，还的从/home_bak复制）<br><a href="https://blog.csdn.net/weixin_43167547/article/details/106457983" target="_blank" rel="noopener">参考</a></li></ul><h3 id="创建sudo新用户"><a href="#创建sudo新用户" class="headerlink" title="创建sudo新用户"></a>创建sudo新用户</h3><p>加入用户<br><code>sudo adduser zzm</code><br>查看用户组<br><code>groups</code><br>加入sudo组<br><code>sudo usermod -aG sudo zzm</code><br>删除用户<br>sudo deluser, sudo deluser —remove-home<br><a href="https://blog.csdn.net/wowocpp/article/details/100115112" target="_blank" rel="noopener">参考</a></p><h3 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h3><p>useradd和adduser都可以创建用户，adduser属于快捷创建，主要介绍useradd。  </p><ul><li><p>格式<br>useradd  [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name<br>-c：加上备注文字，备注文字保存在passwd的备注栏中。<br>-d：指定用户登入时的启始目录。<br>-D：变更预设值。<br>-e：指定账号的有效期限，缺省表示永久有效。<br>-f：指定在密码过期后多少天即关闭该账号。<br>-g：指定用户所属的起始群组。<br>-G：指定用户所属的附加群组。<br>-m：自动建立用户的登入目录。<br>-M：不要自动建立用户的登入目录。<br>-n：取消建立以用户名称为名的群组。<br>-r：建立系统账号。<br>-s：指定用户登入后所使用的shell。<br>-u：指定用户ID号。  </p></li><li><p>创建密码<br><code>sudo passwd name</code></p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h3><p>安装ssh<br>打开”终端窗口”，输入”sudo apt-get install openssh-server”—&gt;回车—&gt;输入”y”—&gt;回车—&gt;安装完成。</p><p>查看ssh服务是否启动<br>打开”终端窗口”，输入”sudo ps -e | grep ssh”—&gt;回车—&gt;有sshd,说明ssh服务已经启动，如果没有启动，输入”sudo service ssh start”—&gt;回车—&gt;ssh服务就会启动。</p><p>使用gedit修改配置文件”/etc/ssh/sshd_config”<br>打 开”终端窗口”，输入”sudo gedit /etc/ssh/sshd_config”—&gt;回车—&gt;把配置文件中的”PermitRootLogin without-password”加一个”#”号,把它注释掉—&gt;再增加一句”PermitRootLogin yes”—&gt;保存，修改成功。（否则远程密码不管用）</p><h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><p>卸载openJDK<br>卸载：sudo apt-get remove openjdk*<br>环境设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bashrc 或  /etc/profile</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_05 </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>执行： source ~/.bashrc</p><h3 id="安装FileZilla"><a href="#安装FileZilla" class="headerlink" title="安装FileZilla"></a>安装FileZilla</h3><p>可以远程连接其他的linux，方便传送文件<br>可以直接在 Ubuntu Software 中下载安装。</p><h3 id="MySQL-Workbenck"><a href="#MySQL-Workbenck" class="headerlink" title="MySQL Workbenck"></a>MySQL Workbenck</h3><p>mysql远程连接，可视化<br>sudo apt-get install mysql-workbench<br><a href="https://blog.csdn.net/Jgirl_333/article/details/48575281" target="_blank" rel="noopener">参考</a></p><h3 id="安装LaTex"><a href="#安装LaTex" class="headerlink" title="安装LaTex"></a>安装LaTex</h3><p>用于生成pdf文档<br><a href="https://blog.csdn.net/qq_41814939/article/details/82288145" target="_blank" rel="noopener">参考</a></p><h3 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h3><p><a href="https://blog.csdn.net/areigninhell/article/details/79696751" target="_blank" rel="noopener">参考</a></p><h3 id="安装chrome"><a href="#安装chrome" class="headerlink" title="安装chrome"></a>安装chrome</h3><p><a href="https://jingyan.baidu.com/article/335530da98061b19cb41c31d.html" target="_blank" rel="noopener">参考</a></p><h3 id="安装Foxit-pdf阅读器"><a href="#安装Foxit-pdf阅读器" class="headerlink" title="安装Foxit pdf阅读器"></a>安装Foxit pdf阅读器</h3><p><a href="https://blog.csdn.net/u011722133/article/details/79242695/" target="_blank" rel="noopener">参考</a></p><h3 id="安装QQ"><a href="#安装QQ" class="headerlink" title="安装QQ"></a>安装QQ</h3><p><a href="https://im.qq.com/linuxqq/download.html" target="_blank" rel="noopener">下载地址</a></p><h3 id="ubuntu-浏览器不支持html5-视频播放"><a href="#ubuntu-浏览器不支持html5-视频播放" class="headerlink" title="ubuntu 浏览器不支持html5 视频播放"></a>ubuntu 浏览器不支持html5 视频播放</h3><p>sudo apt-get install ubuntu-restricted-extras</p><h3 id="ubuntu-打开usb摄像头（uvc）"><a href="#ubuntu-打开usb摄像头（uvc）" class="headerlink" title="ubuntu 打开usb摄像头（uvc）"></a>ubuntu 打开usb摄像头（uvc）</h3><p>sudo apt install cheese<br><code>$ cheese</code> 即可使用</p><h3 id="安装Trash-CLI-防止rm误删"><a href="#安装Trash-CLI-防止rm误删" class="headerlink" title="安装Trash CLI 防止rm误删"></a>安装Trash CLI 防止rm误删</h3><p>sudo apt-get install trash-cli<br><a href="https://www.linuxidc.com/Linux/2018-11/155406.htm" target="_blank" rel="noopener">参考</a> </p><h3 id="安装图片工具gimp-和-pinta"><a href="#安装图片工具gimp-和-pinta" class="headerlink" title="安装图片工具gimp 和 pinta"></a>安装图片工具gimp 和 pinta</h3><p>sudo apt-get install gimp<br>sudo apt-get install pinta</p><h3 id="安装视频剪辑工具kdenlive"><a href="#安装视频剪辑工具kdenlive" class="headerlink" title="安装视频剪辑工具kdenlive"></a>安装视频剪辑工具kdenlive</h3><p>通过ubuntu 自带的软件下载</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><h3 id="ubuntu查看内存情况"><a href="#ubuntu查看内存情况" class="headerlink" title="ubuntu查看内存情况"></a>ubuntu查看内存情况</h3><ul><li><p>查看内存的插槽数，已经使用多少插槽。每条内存多大，已使用内存多大  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -P -A5 &quot;Memory\s+Device&quot;|grep Size|grep -v Range</span><br></pre></td></tr></table></figure></li><li><p>查看内存支持的最大内存容量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -P &apos;Maximum\s+Capacity&apos;</span><br></pre></td></tr></table></figure></li><li><p>查看内存的频率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode|grep -A16 &quot;Memory Device&quot;</span><br><span class="line">sudo dmidecode|grep -A16 &quot;Memory Device&quot;|grep &apos;Speed&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看cpu情况"><a href="#查看cpu情况" class="headerlink" title="查看cpu情况"></a>查看cpu情况</h3><p><a href="https://blog.csdn.net/u013066730/article/details/82783083" target="_blank" rel="noopener">参考</a></p><h3 id="查看显卡情况"><a href="#查看显卡情况" class="headerlink" title="查看显卡情况"></a>查看显卡情况</h3><p>nvidia-smi<br>如果特别慢，<a href="https://blog.csdn.net/minione_2016/article/details/81088414" target="_blank" rel="noopener">执行</a><br><code>sudo nvidia-persistenced --persistence-mode</code><br><code>lspci -vnn | grep VGA -A 12</code></p><h3 id="查看内存条信息"><a href="#查看内存条信息" class="headerlink" title="查看内存条信息"></a>查看内存条信息</h3><p><code>sudo dmidecode --type memory</code></p><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><p>硬盘数量、大小：<code>sudo fdisk -l |grep &quot;Disk /dev/sd&quot;</code><br>硬盘型号：<code>sudo hdparm -i /dev/sda |grep &quot;Model&quot;</code><br><a href="https://www.cnblogs.com/ranxf/p/6903200.html" target="_blank" rel="noopener">参考</a></p><h3 id="查看主板"><a href="#查看主板" class="headerlink" title="查看主板"></a>查看主板</h3><p>主板型号,主板支持最大内存,单条内存的参数<br>sudo dmidecode -t 2 //查看主板信息<br>sudo dmidecode -t 16 |grep Maximum //查看主板支持最大内存<br>sudo dmidecode -t memory //查看单条内存的参数<br><a href="https://blog.csdn.net/djd1234567/article/details/48372911" target="_blank" rel="noopener">参考</a>  </p><h3 id="打开usb摄像头"><a href="#打开usb摄像头" class="headerlink" title="打开usb摄像头"></a>打开usb摄像头</h3><p>命令：<code>cheese</code> </p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> NVIDIA显卡驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分割数组的最大值</title>
      <link href="/2019/09/12/Algorithm-splitArray/"/>
      <url>/2019/09/12/Algorithm-splitArray/</url>
      
        <content type="html"><![CDATA[<p>分割数组的最大值，将一个数组分割成n个连续的子数组，使每个子数组的最大值最小。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在m个节点的分布式计算系统中，有一批任务需要执行，每个任务需要的时间式array[i]，每个节点同一时间只能执行一个任务，每个节点只能执行连续的任务，例如i，i+1，i+2，但是不能执行i，i+2。请问任务完成的最短时间<br><strong>输入</strong><br><code>输入数据包含两行</code><br><code>第一行，空格分割的两个整数m和n，分布表示节点个数和任务个数(m&gt;0,n&gt;=0)</code><br><code>第二行，空格分割的正整数序列，表示每个任务需要的时间</code><br><strong>输出</strong><br><code>一个整数，表示最短完成时间</code><br><strong>样例输入</strong><br><code>3 5</code><br><code>1 5 3 4 2</code><br><strong>样例输入</strong><br><code>6</code><br><strong>提示</strong><br><code>第一个节点执行：任务1和任务2，耗时=1+5=6</code><br><code>第二个节点执行：任务3，耗时=3</code><br><code>第三个节点执行：任务4和任务5，耗时=2+4=6</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将一个数组分割成n个连续的子数组，使每个子数组的最大值最小。（同leecode 410）</p><h2 id="解法一、-二分法"><a href="#解法一、-二分法" class="headerlink" title="解法一、  二分法"></a>解法一、  二分法</h2><p>1.给出一个完成任务的时间x，然后将任务分成每个子节点任务时间&lt;=x，如果完成任务需要的节点数&lt;=给出的节点数，那么满足条件。用来判断是否满足条件的过程可以用暴力方法求解。<br>2.给出时间x可以从完成任务的平均时间开始不断+1，找到第一个满足条件的x，就是完成任务最短时间。或者使用二分法 sum/m&lt;=x&lt;=sum，不断二分计算中间值，可以减少时间复杂度。<br><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class test3 &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int nodeNum=sc.nextInt();</span><br><span class="line">        int taskNum=sc.nextInt();</span><br><span class="line">        int time[] = new int[taskNum];</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;taskNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        time[i]=sc.nextInt();</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(splitArray(time,nodeNum));</span><br><span class="line">    &#125;</span><br><span class="line">//二分法划分，每次给出一个时长x，判断是否满足条件</span><br><span class="line">public static int splitArray(int[] nums, int m) &#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">int low=sum/m;</span><br><span class="line">int high=sum;</span><br><span class="line">int result=low;</span><br><span class="line">while(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">int mid=(low+high)/2;</span><br><span class="line">if(isFit(nums,mid,m))</span><br><span class="line">&#123;</span><br><span class="line">if(isFit(nums,low,m)) &#123;</span><br><span class="line">result=low;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">low+=1;</span><br><span class="line">high=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        if(result&lt;nums[i])</span><br><span class="line">        result=nums[i];</span><br><span class="line">        &#125; </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//暴力求解当前时长是否满足条件</span><br><span class="line">private static Boolean isFit(int time[],int maxsumtime,int nodeNum)</span><br><span class="line">&#123;</span><br><span class="line">int count=0,sum=0;</span><br><span class="line">for(int i=0;i&lt;time.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=time[i];</span><br><span class="line">if(i+1&lt;time.length-1)</span><br><span class="line">&#123;</span><br><span class="line">if(sum&lt;=maxsumtime&amp;&amp;(sum+time[i+1])&gt;maxsumtime)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">sum=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if(sum&lt;=maxsumtime&amp;&amp;(sum+time[i+1])&gt;maxsumtime)</span><br><span class="line">&#123;</span><br><span class="line">count=count+2;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">count+=1;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;count:&quot;+count);</span><br><span class="line">System.out.println(&quot; maxsumtime:&quot;+maxsumtime);</span><br><span class="line">if(count&gt;nodeNum)</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br>第一行是使用二分的结果，第二行是顺序查找的结果<br><img src="//blog.zhengmingz.top/2019/09/12/Algorithm-splitArray/result1.png" alt="result1"></p><h2 id="解法二、-动态规划"><a href="#解法二、-动态规划" class="headerlink" title="解法二、  动态规划"></a>解法二、  动态规划</h2><p>这是一类最大最小问题。<br>简单说就是将数组划分为多组，每组会求一个和，多组的和最大值的可能性很多，求多组和的最小值的可能性。<br>状态定义：f[i][j]表示nums[0] ~ nums[j]共j+1个元素划分为i组的和的最大最小值。<br>可初始化的状态：f[1][j]表示nums[0]~nums[j]划分为1组的分组和的最大最小值，显然f[1][j] = sum(0, j)，包含边界。<br>状态迁移方程：f[i][j] = min(max(f[i-1][k], sum(k+1, j))), 0&lt;= k &lt; j<br>这种问题的状态迁移方程很具有代表性，即在右边划一段出来，先把问题规模-1，然后剩下的只需要再切分为i-1组即可。<br>其中k是这缩小问题规模的切分点。</p><p><strong>源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class dp &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int nodeNum=sc.nextInt();</span><br><span class="line">        int taskNum=sc.nextInt();</span><br><span class="line">        int time[] = new int[taskNum];</span><br><span class="line">        for(int i=0;i&lt;taskNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        time[i]=sc.nextInt();</span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(dp(time,nodeNum));</span><br><span class="line">    &#125;</span><br><span class="line">public static int dp(int time[],int nodeNum)</span><br><span class="line">&#123;</span><br><span class="line">int f[][]=new int[nodeNum+1][time.length] ;</span><br><span class="line">int presum[]=new int[time.length];</span><br><span class="line">for(int i=2;i&lt;nodeNum+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;time.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=2147483647;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[1][0]=time[0];</span><br><span class="line">presum[0]=time[0];</span><br><span class="line">for(int i=1;i&lt;time.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">presum[i]=presum[i-1]+time[i];</span><br><span class="line">f[1][i]=presum[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=2;i&lt;nodeNum+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i-1;j&lt;time.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;j;k++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=Math.min(f[i][j], Math.max(f[i-1][k], presum[j]-presum[k]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[nodeNum][time.length-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><img src="//blog.zhengmingz.top/2019/09/12/Algorithm-splitArray/result2.png" alt="result2"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wpf加载gif</title>
      <link href="/2019/09/09/Program-wpfgif/"/>
      <url>/2019/09/09/Program-wpfgif/</url>
      
        <content type="html"><![CDATA[<p>wpf加载gif显示问题<br><a id="more"></a><br>wpf 程序需要动态显示gif图片，试过MediaElement、Image  以及winform 的 pictureBox，要不图片显示不出来，要不显示出来不动，亲测以下方法可用。</p><ol><li>打开vs 工具-&gt;库程序包管理工具-&gt;程序包管理器控制台</li><li>PM&gt;Install-Package WpfAnimatedGif </li><li>要使用这个包需要加入新的命名空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;Meeting.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:gif=&quot;http://wpfanimatedgif.codeplex.com&quot; </span><br><span class="line">        Icon=&quot;/images/icon.ico&quot;</span><br><span class="line">        Title=&quot; MainWindows&quot;  Height=&quot;610&quot; Width=&quot;900&quot;  &gt;</span><br><span class="line">      &lt;Grid&gt;</span><br><span class="line">          &lt;Image gif:ImageBehavior.AnimatedSource=&quot;Images/animated.gif&quot; /&gt;</span><br><span class="line">      &lt;/Grid&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wpf </tag>
            
            <tag> gif </tag>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux+vim+zsh 配置</title>
      <link href="/2019/09/09/Install-ZshTmuxVim/"/>
      <url>/2019/09/09/Install-ZshTmuxVim/</url>
      
        <content type="html"><![CDATA[<p>tmux、vim、zsh等shell工具的配置与使用<br><a id="more"></a></p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p><a href="http://man.openbsd.org/OpenBSD-current/man1/tmux.1" target="_blank" rel="noopener">官方手册</a><br><a href="https://pragprog.com/book/bhtmux2/tmux-2" target="_blank" rel="noopener">电子数</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install tmux</code><br><strong>Session 命令</strong><br>启动新会话： tmux new -s 会话名  -n  窗口名<br>恢复会话： tmux a  -t  会话名<br>列出所有会话：tmux  ls<br>关闭会话：tmux  kill-session  -t  会话名<br>关闭所有会话：<br>tmux ls | grep : | cut -d. -f1 | awk ‘{print substr($1, 0, length($1)-1)}’ | xargs kill<br>脱离会话： Ctrl+b，d<br>重新附加会话：  tmux  attach-session<br>列出会话：tmux list-sessions<br>重命名会话：tmux  rename -t  oldname  newname<br>Ctrl+b，：  可以不用退出，直接在下方输入命令（如： new -s  会话名）<br>Ctrl+b，s    可以显示所有的session，并切换<br><strong>Window 命令</strong><br>Ctrl+b，c  新建窗口<br>Ctrl+b，p 移动到上一个窗口<br>Ctrl+b，n  移动到下一个窗口<br>Ctrl+b, w  通过窗口列表切换窗口<br>退出所有panel，window也关闭<br><strong>Panel 命令</strong><br>Ctrl+b，箭头    选择操作不同的窗格<br>Ctrl+b，”     水平分割窗格，形成上下两个panel<br>Ctrl+b，%    垂直分割窗格，形成左右两个panel<br>Ctrl+b+箭头   Ctrl+b不放，可以一直按箭头调整窗格的大小，1<br>Ctrl+b，Alt+箭头   调整窗格大小，5<br>Ctrl+b，Page Up和Page Down  可以上下翻看历史记录<br>Ctrl+b，q  显示窗格对应的数字<br>Ctrl+d     exit     logout  退出当前窗格<br><strong>tmux打开shell自启动</strong><br>打开<code>.bashrc</code>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $TERM != &quot;screen-256color&quot; ] &amp;&amp; [  $TERM != &quot;screen&quot; ]; then</span><br><span class="line">    tmux attach || tmux new; exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>新建session错误</strong><br>报错sessions should be nested with care, unset $TMUX to force<br>按错误提示执行命令：<br>需要使用命令 unset TMUX<br>再次执行 ：问题解决</p><p>vim报错：_arguments:450: _vim_files: function definition file not found<br>直接删除~/.zcompdump文件，但是不知道会不会影响其他插件的功能。</p><p><strong>远程安装tmux，scp传输出错</strong><br><strong>xshell 使用rzsz出差</strong><br>open terminal failed: not a terminal<br>需要关闭tmux才可以</p><p><a href="https://www.cnblogs.com/lizhang4/p/7325086.html" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/williamyuyuyu/article/details/79283374" target="_blank" rel="noopener">参考2</a></p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim鼠标右键不能复制、粘贴"><a href="#vim鼠标右键不能复制、粘贴" class="headerlink" title="vim鼠标右键不能复制、粘贴"></a>vim鼠标右键不能复制、粘贴</h3><ol><li>在普通模式下键入:set mouse-=a</li><li>在.vimrc 中添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if has(&apos;mouse&apos;)</span><br><span class="line">   set mouse-=a </span><br><span class="line">endif</span><br></pre></td></tr></table></figure></li></ol><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p><strong>安装</strong><br><code>sudo apt-get install zsh</code><br><strong>安装 oh My Zsh</strong><br><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code><br><strong>修改zsh为默认的shell：</strong><br><code>chsh -s /bin/zsh  #该命令会修改 /etc/passwd 文件中对应的用户名</code><br><strong>修改主题</strong><br>打开~/.zshrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 找到如下这一行，将引号中的部分修改为`ys`即可</span><br><span class="line">ZSH_THEME=&quot;ys&quot;</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/qixizhuang/article/details/82958198" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/smallrivers/article/details/78701804" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> zsh </tag>
            
            <tag> tmux </tag>
            
            <tag> vim </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda</title>
      <link href="/2019/09/08/Install-conda/"/>
      <url>/2019/09/08/Install-conda/</url>
      
        <content type="html"><![CDATA[<p>conda的安装与配置<br><a id="more"></a></p><h2 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h2><p> <strong>下载</strong><br> <code>wget https://repo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh</code><br> <strong>安装</strong><br> <code>bash Miniconda2-latest-Linux-x86_64.sh -b -p /home/user/miniconda2</code><br> <code>mv Miniconda2-latest-Linux-x86_64.sh download</code><br><strong>配置环境</strong><br>在<code>.bashrc</code>中添加<br><code>export PATH=/home/user/miniconda2/bin:$PATH</code><br><code>source .bashrc</code></p><h2 id="conda-环境"><a href="#conda-环境" class="headerlink" title="conda 环境"></a>conda 环境</h2><p><strong>创建环境</strong><br><code>conda create -n py36 python=3.7</code><br><strong>删除环境</strong><br><code>conda remove -n py36 --all</code><br><strong>激活环境</strong><br><code>source activate py36</code><br><strong>退出环境</strong><br><code>source deactivate</code></p><h2 id="分享环境"><a href="#分享环境" class="headerlink" title="分享环境"></a>分享环境</h2><p><strong>conda分享环境</strong></p><ul><li>激活要分享的环境　　</li><li>导出环境　<code>conda env export &gt; environment.yml</code>（导出所有的环境包括ｐｉｐ安装的）</li><li>安装环境　<code>conda env create -f environment.yml</code>  </li></ul><p><strong>pip分享环境</strong></p><ul><li>到出环境　<code>pip freeze &gt; requirements.txt</code></li><li>安装环境　<code>pip install -r requirements.txt</code></li></ul><h2 id="conda安装python包"><a href="#conda安装python包" class="headerlink" title="conda安装python包"></a>conda安装python包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda install  tensorflow=1.8.0 #安装包</span><br><span class="line">conda list         #查看已经安装的包</span><br><span class="line">conda update xxx   #更新xxx包</span><br><span class="line">conda uninstall xxx   #卸载xxx包</span><br></pre></td></tr></table></figure><p><strong>清理</strong><br><code>conda clean -p      //删除没有用的包</code><br><code>conda clean -t      //tar打包</code></p><h2 id="cuda安装"><a href="#cuda安装" class="headerlink" title="cuda安装"></a>cuda安装</h2><p><strong>解决CUDA driver version is insufficient for CUDA runtime version</strong><br><code>tensorflow.python.framework.errors_impl.InternalError: cudaGetDevice() failed. Status: CUDA driver version is insufficient for CUDA runtime version</code><br><strong>原因</strong><br>CUDA版本对显卡驱动版本有要求，见如下链接。<br><code>https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</code><br><strong>解决</strong><br>卸载旧版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall cudnn</span><br><span class="line">conda uninstall cudatoolkit</span><br></pre></td></tr></table></figure></p><p>安装新版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install cudatoolkit=9.0</span><br><span class="line">conda install cudnn</span><br></pre></td></tr></table></figure></p><p><a href="http://www.pianshen.com/article/6406282694/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> conda </tag>
            
            <tag> cuda </tag>
            
            <tag> tensorflow </tag>
            
            <tag> jupyter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp服务器搭建</title>
      <link href="/2019/09/03/Install-ftp/"/>
      <url>/2019/09/03/Install-ftp/</url>
      
        <content type="html"><![CDATA[<p>在ubuntu服务器上搭建ftp服务，用于个人使用<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装VSFTPD</strong><br>使用 apt-get 安装 vsftpd：<br><code>sudo apt-get install vsftpd -y</code><br><strong>启动 VSFTPD</strong><br>安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经[监听了 21 端口]：<br><code>sudo netstat -nltp | grep 21</code><br>如果没有启动，可以手动开启 VSFTPD 服务：<br><code>sudo systemctl start vsftpd.service</code><br>FTP 协议默认使用 21 端口作为服务端口<br><strong>配置用户访问目录</strong><br>新建用户主目录<br><code>sudo mkdir /home/ftp</code><br><strong>新建用户uftp并设置密码</strong><br>创建一个用户 uftp ：<br><code>sudo useradd -d /home/uftp -s /bin/bash uftp</code><br>为用户 uftp 设置密码：<br><code>sudo passwd uftp</code><br>删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：<br><code>sudo rm /etc/pam.d/vsftpd</code><br><strong>限制该用户只能通过ftp访问，不可以直接登录服务器</strong><br>sudo usermod -s /sbin/nologin uftp<br><strong>修改vsftpd配置</strong><br>修改 <code>/etc/vsftpd.conf</code> 文件中的配置（直接将如下配置添加到配置文件最下方）：<br>限制用户对主目录以外目录访问<br><code>chroot_local_user=YES</code><br>指定一个 userlist 存放允许访问 ftp 的用户列表<br><code>userlist_deny=NO</code><br><code>userlist_enable=YES</code><br>记录允许访问 ftp 用户列表<br><code>userlist_file=/etc/vsftpd.user_list</code><br>不配置可能导致莫名的530问题<br><code>seccomp_sandbox=NO</code><br>允许文件上传<br><code>write_enable=YES</code><br>使用utf8编码<br><code>utf8_filesystem=YES</code><br>新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：<br><code>sudo touch /etc/vsftpd.user_list</code><br><code>sudo chmod a+w /etc/vsftpd.user_list</code><br>修改 <code>/etc/vsftpd.user_list</code> ，加入刚刚创建的用户：<br><code>uftp</code><br><strong>设置访问权限</strong><br>设置主目录访问权限（只读）：<br><code>sudo chmod a-w /home/ftp</code><br>新建公共目录，并设置权限（读写）：<br><code>sudo mkdir /home/ftp/public &amp;&amp; sudo chmod 777 -R/home/ftp/public</code><br>重启vsftpd 服务：<br><code>sudo systemctl restart vsftpd.service</code></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>1.购买域名<br>2.设置域名解析，直接将域名绑定到ftp服务器的ip上。</p><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p><strong>1.ftp连接错误</strong><code>500 OOPS: vsftpd</code><br><strong>解决</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br><span class="line"># 添加一行配置 allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure></p><p><a href="https://www.php.cn/linux-363729.html" target="_blank" rel="noopener">参考</a></p><h2 id="ftp命令"><a href="#ftp命令" class="headerlink" title="ftp命令"></a>ftp命令</h2><p><strong>命令行连接ftp</strong><br><code>ftp ip</code><br>输入用户名，密码<br>或者 <code>ftp&gt;open ip</code><br><strong>下载文件</strong><br><code>ftp&gt;get filename</code><br><strong>上传文件</strong><br><code>ftp&gt;put filename</code><br><strong>查看目录</strong><br><code>ftp&gt;ls</code><br><strong>查看本地目录</strong><br><code>ftp&gt;!ls</code></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> ftp </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo创建个人博客</title>
      <link href="/2019/08/27/Install-Hexo/"/>
      <url>/2019/08/27/Install-Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo安装、配置，在github上部署，yelee主题配置<br><a id="more"></a></p><h1 id="安装nodejs和npm"><a href="#安装nodejs和npm" class="headerlink" title="安装nodejs和npm"></a>安装nodejs和npm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>创建文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Hexo  </span><br><span class="line">cd Hexo</span><br></pre></td></tr></table></figure></p><p>安装Hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure></p><p>初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>此步骤会在hexo文件夹下生成默认的网站模板文件。</p><p>清除之前生成的静态模板文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p><p>生成新的静态模板文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate（hexo g）</span><br></pre></td></tr></table></figure></p><p>启动hexo的本地服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server（hexo s）</span><br></pre></td></tr></table></figure></p><h1 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h1><p>1.新建一个仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github名.github.io</span><br></pre></td></tr></table></figure></p><p>(名称必须与github名一致)<br>在该仓库Settings下GitHub Pageszhong设置Custom domain为自己的域名（和hexo中CNAME设置一样）<br>在source目录下创建文件CNAME<br>写入自己的域名</p><p>2.修改_config.yml文件<br>deploy:<br>type: git<br>repository: <a href="https://github.com/githubID/仓库名.github.io.git" target="_blank" rel="noopener">https://github.com/githubID/仓库名.github.io.git</a><br>branch: master</p><p>3.部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy（hexo d）</span><br></pre></td></tr></table></figure></p><h1 id="安装-Hexo-Admin插件"><a href="#安装-Hexo-Admin插件" class="headerlink" title="安装 Hexo Admin插件"></a>安装 Hexo Admin插件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure><p>打开本地管理界面<br><a href="http://localhost:4000/admin" target="_blank" rel="noopener">http://localhost:4000/admin</a></p><h1 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h1><p>1.创建文章<br>hexo根目录命令行输入<code>hexo new &lt;模板&gt; &lt;文章名&gt;</code>新建文章  </p><p><table>  <tr><td>参数</td><td>功能</td><td>路径</td></tr>  <tr><td>post</td><td>新建文章</td><td>/source/_posts/</td></tr>  <tr><td>draft</td><td>新建草稿</td><td>/source/_drafts/</td></tr>  <tr><td>page</td><td>新建页面（标签、分类等）</td><td>/source/</td></tr></table><br>通常情况下使用<code>hexo new post name</code><br>会在<code>source/_posts</code>下生成一个<code>name.md</code>的文件。  </p><h1 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h1><p>配置<code>_config_yml</code>里面的post_asset_folder:false这个选项设置为true。<br>安装<code>hexo-asset-image</code>，运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了xxxx.md文件还有一个同名的文件夹，把图片放入该文件夹。<br>问题直接运行<code>npm install hexo-asset-image save</code>安装的插件有问题，图片不能正确显示，生成的html中图片路径不对（显示 /.top//name.png），使用如下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><p>插入图片，在md中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![xxx](blogName/imageName.png)</span><br></pre></td></tr></table></figure></p><p>需要配置_config.yml中的url，本地配置为localhost，远程配置为对应的域名<br><a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">参考</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="安装hexo错误：（nodejs版本太低，不能用apt直接升级）"><a href="#安装hexo错误：（nodejs版本太低，不能用apt直接升级）" class="headerlink" title="安装hexo错误：（nodejs版本太低，不能用apt直接升级）"></a>安装hexo错误：（nodejs版本太低，不能用apt直接升级）</h2><p><strong>解决</strong><br>1.产看node版本，没安装的请先安装；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  node -v</span><br></pre></td></tr></table></figure></p><p>2.清楚node缓存；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm cache clean -f</span><br></pre></td></tr></table></figure></p><p>3.安装node版本管理工具’n’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo npm install n -g</span><br></pre></td></tr></table></figure></p><p>4.使用版本管理工具安装指定node或者升级到最新node版本；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo n stable  （安装node最新版本）</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/legendjslc/articles/10131412.html" target="_blank" rel="noopener">参考</a></p><h2 id="hexo-d-ERROR-Deployer-not-found-git"><a href="#hexo-d-ERROR-Deployer-not-found-git" class="headerlink" title="hexo d(ERROR Deployer not found: git)"></a>hexo d(ERROR Deployer not found: git)</h2><p><strong>解决</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></p><h2 id="hexo输入数学公式不显示"><a href="#hexo输入数学公式不显示" class="headerlink" title="hexo输入数学公式不显示"></a>hexo输入数学公式不显示</h2><ol><li><p>在开始部分插入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; async</span><br><span class="line">  src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在网页中插入所需数学公式的特定格式(或者见yelee):<br>（插入1后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;</span><br><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">tex2jax: &#123;inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\\(&apos;,&apos;\\)&apos;]]&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://daniellaah.github.io/2016/Mathmatical-Formula-within-Markdown.html" target="_blank" rel="noopener">参考</a></p><h2 id="有序列表显示问题“-A空格”"><a href="#有序列表显示问题“-A空格”" class="headerlink" title="有序列表显示问题“- A空格”"></a>有序列表显示问题<code>“- A空格”</code></h2><ul><li>A boy</li><li>A- boy<br>如上显示正常显示，前面应该有一个圆点，第一行A空格前面没有圆点。暂时解决只能在A后直接加字符</li></ul><h1 id="yelee"><a href="#yelee" class="headerlink" title="yelee"></a>yelee</h1><p>1.在 themes下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></p><p>2.修改_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: yelee</span><br></pre></td></tr></table></figure></p><p>3.支持数学公式<br>修改 <code>themes/yelee/_config.yml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p>4.不喜欢yelee的标题风格<br>修改 themes/yelee/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heading_stytle:2  //改为github风格</span><br></pre></td></tr></table></figure></p><p>5.社交图标设置<br>themes/yelee/source/css/_partial/customise/social-icon.styl</p><p><strong>参考</strong><br><a href="http://moxfive.coding.me/yelee/2.Basic-Usage/post-excerpt.html" target="_blank" rel="noopener">yelee配置中文说明</a><br><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">yelee github</a><br><a href="https://www.imooc.com/article/44667" target="_blank" rel="noopener">博客搭建</a></p>]]></content>
      
      
      <categories>
          
          <category> Install </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2019/08/26/Algorithm-knapsack-problem/"/>
      <url>/2019/08/26/Algorithm-knapsack-problem/</url>
      
        <content type="html"><![CDATA[<p>背包问题(Knapsack problem)是一种组合优化的NP完全问题<br><a id="more"></a></p><h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><p><strong>问题描述</strong><br>假设有N个物品，其中第i个物品的重量为W<sub>i</sub>。 现在需要将这些物品分成两堆，使得在“第一堆物品的总重量与第二堆物品的总重量之差尽可能小”的前提下，第一堆物品的数量与第二堆物品的数量之差尽可能大。那么，两堆物品总重量之差最小是多少？在总重量之差最小的前提下，两堆物品的数量之差最大是多少？</p><p><strong>输入</strong><br>第一行包含一个整数N，2<script type="math/tex">\leq</script>N<script type="math/tex">\leq</script>100。<br>第二行包含N个空格隔开的整数W<sub>1</sub>到W<sub>N</sub>，1<script type="math/tex">\leq</script>W<sub>i</sub><script type="math/tex">\leq</script>100。</p><p><strong>输出</strong><br>输出两个空格隔开的整数，第一个整数表示两堆物品的总重量之差的最小值，第二个整数表示在总重量之差最小的提前下，两堆物品的数量之差的最大值。</p><p><strong>样例输入</strong>  </p><table><tr><td>6</td></tr><tr><td>1 2 3 4 5 6</td></tr></table><p><strong>样例输出</strong></p><table><tr><td>1 2</td></tr></table><p><strong>解析</strong><br>思路：<br>重量之差最小：可以理解为可以放N个物品重量一半的背包问题，在背包中放入的物体总量最大。<br>数量之差最大：若总重量为偶数，两个背包一样大。若总总量为奇数，一个背包比另外一个背包大1。在总重量小（或相等）的一个背包中放入数量尽可能少的物品，在另一个背包中放入数据尽可能多的物品。<br>以样例为例，背包重量空间为10，如果当前背包的重量小于放入前一个物品的（当前背包重量-当前物品重量）所对应的重量+当前物品重量则放入，表格中写入放入后背包的重量。（第一行表示背包重量剩余空间，表格中表示当前背包的重量和放入的数量）。记录放入背包的物品数，如果放入则+1。如果放入与不放重量一样，则判断放入数量+1与不放数量更小的表示新的记录。<br>按行更新，使不同背包空间放入尽可能重量多数量少的物品</p><table>  <tr><td>物品\背包空间</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>  <tr><td>1</td><td>1  1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td>1 1</td><td bgcolor="“#8A2BE2”">1 1</td><td>0 0</td></tr>  <tr><td>2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td>3 2</td><td bgcolor="“#8A2BE2”">3 2</td><td>2 1</td><td>1 1</td><td bgcolor="#FF7F50">0 0 </td></tr>  <tr><td>3</td><td>6 3</td><td>6 3</td><td>6 3</td><td>6 3</td><td bgcolor="“#8A2BE2”">6 3</td><td>5 2</td><td>4 2</td><td>3 1</td><td>2 1</td><td bgcolor="#FF7F50">1 1</td><td> 0 0</td></tr>  <tr><td>4</td><td bgcolor="“#8A2BE2”">10 4</td><td>9 3</td><td>8 3</td><td>7 2</td><td>6 2</td><td bgcolor="#FF7F50">5 2</td><td>4 1</td><td>3 1</td><td>2 1</td><td>1 1</td><td bgcolor="#00FF00">0 0 </td></tr>  <tr><td>5</td><td bgcolor="#FF7F50">10 3</td><td>9 2</td><td>8 2</td><td>7 2</td><td>6 2</td><td>5 1</td><td bgcolor="#00FF00">4 1</td><td>3 1</td><td>2 1</td><td>1 1 </td><td>0 0</td></tr>  <tr><td>6</td><td bgcolor="#00FF00">10 2</td><td>9 2</td><td>8 2</td><td>7 2</td><td>6 1</td><td>5 1</td><td>4 1</td><td>3 1</td><td>2 1</td><td>1 1</td><td>0 0</td></tr></table><p><strong>源码</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class bag2 &#123;</span><br><span class="line">//动态规划 背包问题</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int num=sc.nextInt();</span><br><span class="line">        int weight[] = new int[num];</span><br><span class="line">        int sum=0,m=0;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        weight[i]=sc.nextInt();</span><br><span class="line">        sum+=weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m=sum;</span><br><span class="line">        sum/=2;</span><br><span class="line">        int dp[]=new int[sum+1];</span><br><span class="line">        int count[]=new int[sum+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=sum;j&gt;=weight[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[j]&lt;(dp[j-weight[i]]+weight[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        dp[j]=dp[j-weight[i]]+weight[i];</span><br><span class="line">        count[j]=count[j-weight[i]]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[j]==(dp[j-weight[i]]+weight[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(count[j]&gt;count[j-weight[i]]+1)</span><br><span class="line">        &#123;</span><br><span class="line">        count[j]=count[j-weight[i]]+1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(dp[j]+<span class="string">" "</span>+count[j]+<span class="string">"   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((m-2*dp[sum])+<span class="string">" "</span>);//输出重量最小差</span><br><span class="line"></span><br><span class="line">        System.out.print(num-2*count[sum]);//输出数量最大差</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>另一种思路</strong><br>先考虑重量最小，然后可以得知，两个背包分别放入总量。可以转化为N个整数，选出M个整数的和为固定值，找出所有可能的组合。（速度太慢了，不能通过测试）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class bag1 &#123;</span><br><span class="line">//动态规划 背包问题</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int num=sc.nextInt();</span><br><span class="line">        int weight[] = new int[num];</span><br><span class="line">        int sum=0,m=0;</span><br><span class="line">        int dp[]=new int[10000];</span><br><span class="line">        for(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        weight[i]=sc.nextInt();</span><br><span class="line">        sum+=weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m=sum;</span><br><span class="line">        sum/=2;</span><br><span class="line">        for(int i=0;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        for(int j=sum;j&gt;=weight[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">        dp[j]=(dp[j]&gt;(dp[j-weight[i]]+weight[i]))?dp[j]:(dp[j-weight[i]]+weight[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print((m-2*dp[sum])+&quot; &quot;);//输出重量最小差</span><br><span class="line">        int A=m-2*dp[sum];</span><br><span class="line">        int B=m;</span><br><span class="line">        int C=(A+B)/2; //重量更多的物体的和</span><br><span class="line">        int large=binaryCal(weight,C);</span><br><span class="line">        System.out.print(large-(num-large));//输出数量最大差</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public static int binaryCal(int[] a,int m) &#123;</span><br><span class="line">int n = a.length;</span><br><span class="line">        //最大的数为2的n次方</span><br><span class="line">int max = 1 &lt;&lt; n;</span><br><span class="line">int result=0;</span><br><span class="line">for(int i = 1;i &lt; max;i++) &#123;</span><br><span class="line">            //转成二进制数</span><br><span class="line">String binaryNum = Integer.toBinaryString(i);</span><br><span class="line">//转成相同的位数，不足n位的在前补0</span><br><span class="line">            binaryNum = toSameLen(binaryNum,n);</span><br><span class="line">char[] bitNum = binaryNum.toCharArray();</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int j = 0;j &lt; bitNum.length;j++) &#123;</span><br><span class="line">                //二进制数当前位置为1，则加起来</span><br><span class="line">if (bitNum[j] == &apos;1&apos;) &#123;</span><br><span class="line">sum += a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            //和为m了，输出</span><br><span class="line">if (sum == m) &#123;</span><br><span class="line">int tmp=output(bitNum,a);</span><br><span class="line">if(result&lt;tmp)</span><br><span class="line">result=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String toSameLen(String binaryNum, int len) &#123;</span><br><span class="line">//数的长度</span><br><span class="line">        int numLen = binaryNum.length();</span><br><span class="line">if (numLen == len) &#123;</span><br><span class="line">return binaryNum;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">        //差几位补几个0</span><br><span class="line">for(int i = 0;i &lt; len - numLen;i++) &#123;</span><br><span class="line">sb.append(0);</span><br><span class="line">&#125;</span><br><span class="line">return sb.append(binaryNum).toString();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static int output(char[] bitNum, int[] a) &#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i = 0;i &lt; bitNum.length;i++) &#123;</span><br><span class="line">if (bitNum[i] == &apos;1&apos;) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
